<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>行路のblog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://todcsw.github.io/"/>
  <updated>2020-05-12T10:00:29.102Z</updated>
  <id>https://todcsw.github.io/</id>
  
  <author>
    <name>Todcsw</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>mysql事件</title>
    <link href="https://todcsw.github.io/2020/05/12/mysql-mysql-event/"/>
    <id>https://todcsw.github.io/2020/05/12/mysql-mysql-event/</id>
    <published>2020-05-12T09:52:32.000Z</published>
    <updated>2020-05-12T10:00:29.102Z</updated>
    
    <content type="html"><![CDATA[<h1 id="mysql事件"><a href="#mysql事件" class="headerlink" title="mysql事件"></a>mysql事件</h1><h2 id="事件是什么"><a href="#事件是什么" class="headerlink" title="事件是什么"></a>事件是什么</h2><blockquote><p>MySQL5.1版本开始引进event概念，MySQL<br>中的事件(event：时间触发器)是用于执行定时或周期性的任务，类似Linux中的crontab，但是后者只能精确到分钟，事件可以精确到秒。通过单独或调用存储过程使用，在某一特定的时间点，触发相关的SQL语句或存储过程。事件由一个特定的线程来管理的，也就是所谓的事件调度器，但是事件不能直接调用。</p></blockquote><h2 id="事件的优缺点"><a href="#事件的优缺点" class="headerlink" title="事件的优缺点"></a>事件的优缺点</h2><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><p>一些对数据定时性操作不再依赖外部程序，而直接使用数据库本身提供的功能。<br>可以实现每秒钟执行一个任务，这在一些对实时性要求较高的环境下就非常实用了。</p><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><p>定时触发，不可以调用。</p><h2 id="创建事件"><a href="#创建事件" class="headerlink" title="创建事件"></a>创建事件</h2><blockquote><p>  一条create event语句创建一个事件。每个事件由两个主要部分组成，第一部分是事件调度（event<br>schedule），表示事件何时启动以及按什么频率启动，第二部分是事件动作（event action<br>），这是事件启动时执行的代码，事件的动作包含一条SQL语句，它可能是一个简单地insert或者update语句，也可以使一个存储过程或者benin…end语句块，这两种情况允许我们执行多条SQL。</p><p>一个事件可以是活动（打开）的或停止（关闭）的，活动意味着事件调度器检查事件动作是否必须调用，停止意味着事件的声明存储在目录中，但调度器不会检查它是否应该调用。在一个事件创建之后，它立即变为活动的，一个活动的事件可以执行一次或者多次。</p></blockquote><h2 id="创建事件的语法"><a href="#创建事件的语法" class="headerlink" title="创建事件的语法"></a>创建事件的语法</h2><pre><code>CREATE[DEFINER = { user | CURRENT_USER }] //定义事件执行的时候检查权限的用户EVENT[IF NOT EXISTS]event_nameON SCHEDULE schedule //定义执行的时间和时间间隔。[ON COMPLETION [NOT] PRESERVE] //定义事件是一次执行还是永久执行，默认为一次执行，即NOT PRESERVE。[ENABLE | DISABLE | DISABLE ON SLAVE] // 定义事件创建以后是开启还是关闭，以及在从上关闭。如果是从服务器自动同步主上的创建事件的语句的话，会自动加上DISABLE ON SLAVE。[COMMENT &apos;comment&apos;] //定义事件的注释。DO sql_statement; //事件的主题,执行语句</code></pre><p>事件语法的相关解释：</p><ul><li>event_name：事件是模式对象，与表、存储过程和触发器一样。 event_name 必须是有效的标识符，且可以按正常方式通过模式名称进行引用和 / 或限定。事件名称在模式中必须是唯一的。</li><li>schedule ：调度表是一种规则，用于指定 MySQL 执行与事件相关联的操作的时间</li><li>sql_statement ：您必须包含按调度表执行的有效 SQL 语句或存储过程语句。此语句受到的限制与适用于存储函数和动态 SQL 的限制相同。例如，该语句无法返回结果集（如 SELECT 或 SHOW 所生成的结果集）。通常会使用 CALL 语句调用过程来执行实际操作。</li></ul><h3 id="schedule"><a href="#schedule" class="headerlink" title="schedule"></a>schedule</h3><p>调度表是指定应在何时执行操作的规则。可以在 CREATE EVENT 和 ALTER EVENT 语句的 SCHEDULE 子句中指定调度表。<br>有两种类型的调度表：执行一次的调度表（使用 AT 关键字）和可重复执行的调度表（使用 EVERY 关键字）。对于后者，必须定义事件的重复频率。还可以定义一个时间段，以确定应重复执行事件的期限。<br>SCHEDULE 子句的语法如下所示：</p><pre><code>AT timestamp [+ INTERVAL interval]| EVERY interval [STARTS timestamp [+ INTERVAL interval]] [ENDS timestamp [+ INTERVAL interval]]</code></pre><p>SCHEDULE 子句可包含以下变量元素：<br>timestamp ： DATETIME 或 TIMESTAMP 类型的表达式；<br>interval ：用于指定持续时间。持续时间的表示方法为，指定一个整数数量，后跟用于定义特定种类持续时间的关键字。有效的关键字包括：</p><ul><li>YEAR，QUARTER， MONTH， DAY， HOUR， MINUTE， WEEK， SECOND， YEAR_MONTH， DAY_HOUR， DAY_MINUTE， DAY_SECOND， HOUR_MINUTE， HOUR_SECOND， MINUTE_SECOND</li></ul><p>事件调度程序是 mysqld 进程中的一个单独线程，负责执行调度事件。调度程序会检查是否应执行事件；如果应执行事件，则会创建新的连接来执行操作。<br>使用事件来自动地定期执行（维护）任务，如更新汇总表或刷新查询中的表（物化视图 仿真），或者执行夜间作业。例如，处理白天的工作、加载数据仓库或者将数据导出到 文件中。</p><h2 id="启用事件调度程序"><a href="#启用事件调度程序" class="headerlink" title="启用事件调度程序"></a>启用事件调度程序</h2><p>创建事件后，该事件将存储在数据库中，以便按调度表执行。 event_scheduler线程会监控所有事件的调度表，在到达调度表中的时间时，该线程会启动一个新的线程来执行每个事件。</p><p>默认情况下， event_scheduler 线程设置为 OFF 。您必须显式启用该线程，方法为修改全局 event_scheduler服务器变量的值，将其设置为 ON。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">查看event功能是否开启</span><br><span class="line">show variables like &#39;event%&#39;;</span><br><span class="line">set global event_scheduler &#x3D; ON; &#x2F;&#x2F;将event功能开启</span><br></pre></td></tr></table></figure><h2 id="创建事件的例子"><a href="#创建事件的例子" class="headerlink" title="创建事件的例子"></a>创建事件的例子</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">delimiter &amp;&amp;</span><br><span class="line">DROP EVENT if EXISTS direct_happen; &#x2F;&#x2F;如果存在改事件则删除</span><br><span class="line">CREATE EVENT direct_happen &#x2F;&#x2F;创建事件</span><br><span class="line">on SCHEDULE AT NOW() &#x2F;&#x2F;事件发生的时刻,这里是立即发生</span><br><span class="line">DO</span><br><span class="line">BEGIN</span><br><span class="line">delete from test wehre id&#x3D;&#39;1&#39; ; &#x2F;&#x2F;删除teat表id为1的数据</span><br><span class="line">end &amp;&amp;</span><br><span class="line">Delimiter;</span><br></pre></td></tr></table></figure><h2 id="查看事件"><a href="#查看事件" class="headerlink" title="查看事件"></a>查看事件</h2><p>查看当前所在库的事件:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">show events;</span><br></pre></td></tr></table></figure><h2 id="启用和禁用"><a href="#启用和禁用" class="headerlink" title="启用和禁用"></a>启用和禁用</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">alter event event_name disable; &#x2F;&#x2F;event_name事件的名称</span><br><span class="line">alter event event_name enable;</span><br></pre></td></tr></table></figure><h2 id="删除事件"><a href="#删除事件" class="headerlink" title="删除事件"></a>删除事件</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">drop event [if exists] event_name</span><br></pre></td></tr></table></figure><h2 id="又一个例子"><a href="#又一个例子" class="headerlink" title="又一个例子"></a>又一个例子</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">delimiter $$</span><br><span class="line">create event insert_currenttime_in_table1 &#x2F;&#x2F;insert_currenttime_in_table1事件名</span><br><span class="line">on schedule every 5 second &#x2F;&#x2F; 每隔5秒中就向 &#96;table1&#96; 插入当前时间</span><br><span class="line">on completion preserve &#x2F;&#x2F;当event到期了,event会被disable,但是该event还是会存在</span><br><span class="line">&#x2F;&#x2F;当为on completion not preserve的时候,当event到期的时候,该event会被自动删除掉.</span><br><span class="line">enable &#x2F;&#x2F;定义事件创建以后是开启还是关闭 disable是关闭</span><br><span class="line">comment &#39;每隔5秒中就向 &#96;table1&#96; 插入当前时间的事件&#39; &#x2F;&#x2F;定义事件的注释</span><br><span class="line">do</span><br><span class="line">begin</span><br><span class="line">    insert into &#96;table1&#96; values(null, now()); &#x2F;&#x2F;事件执行的执行语句</span><br><span class="line">end$$</span><br><span class="line">delimiter ;</span><br></pre></td></tr></table></figure><p>写事件时建议模仿上面这个例子</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;mysql事件&quot;&gt;&lt;a href=&quot;#mysql事件&quot; class=&quot;headerlink&quot; title=&quot;mysql事件&quot;&gt;&lt;/a&gt;mysql事件&lt;/h1&gt;&lt;h2 id=&quot;事件是什么&quot;&gt;&lt;a href=&quot;#事件是什么&quot; class=&quot;headerlink&quot; ti
      
    
    </summary>
    
    
      <category term="mysql" scheme="https://todcsw.github.io/categories/mysql/"/>
    
    
      <category term="学习" scheme="https://todcsw.github.io/tags/%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="mysql" scheme="https://todcsw.github.io/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>mysql触发器</title>
    <link href="https://todcsw.github.io/2020/05/11/mysql-mysql-trigger/"/>
    <id>https://todcsw.github.io/2020/05/11/mysql-mysql-trigger/</id>
    <published>2020-05-11T03:06:48.000Z</published>
    <updated>2020-05-11T04:45:05.021Z</updated>
    
    <content type="html"><![CDATA[<h1 id="mysql触发器"><a href="#mysql触发器" class="headerlink" title="mysql触发器"></a>mysql触发器</h1><h2 id="什么是触发器？"><a href="#什么是触发器？" class="headerlink" title="什么是触发器？"></a>什么是触发器？</h2><p>触发器与函数、存储过程一样，触发器是一种对象，它能根据对表的操作时间，触发一些动作，这些动作可以是insert,update,delete等修改操作。</p><h2 id="触发器的概念"><a href="#触发器的概念" class="headerlink" title="触发器的概念"></a>触发器的概念</h2><p>触发器（trigger）：监视某种情况，并触发某种操作，它是提供给程序员和数据分析员来保证数据完整性的一种方法，它是与表事件相关的特殊的存储过程，它的执行不是由程序调用，也不是手工启动，而是由事件来触发，例如当对一个表进行操作(insert，delete， update)时就会激活它执行。<br>触发器经常用于加强数据的完整性约束和业务规则等。 触发器创建语法四要素：<br>1.监视地点(table)<br>2.监视事件(insert/update/delete)<br>3.触发时间(after/before)<br>4.触发事件(insert/update/delete)</p><h2 id="触发器语法"><a href="#触发器语法" class="headerlink" title="触发器语法"></a>触发器语法</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Delimiter &amp;&amp;</span><br><span class="line">CREATE TRIGGER &#x2F;&#x2F;创建触发器</span><br><span class="line">trigger_name  &#x2F;&#x2F;触发器的名称</span><br><span class="line">trigger_time &#x2F;&#x2F;触发器的时间 参数为BEFORE和AFTER参数指定了触发执行的时间，在事件之前或是之后。</span><br><span class="line">trigger_event &#x2F;&#x2F;是触发器的触发事件，包括insert、update和delete</span><br><span class="line">ON tbl_name        &#x2F;&#x2F;表示在这个表上 </span><br><span class="line">FOR EACH ROW &#x2F;&#x2F;表示任何一条记录上的操作满足触发事件都会触发该触发器，也就是说触发器的触发频率是针对每一行数据触发一次。</span><br><span class="line">[trigger_order]    &#x2F;&#x2F;是MySQL5.7之后的一个功能，用于定义多个触发器，使用follows(尾随)或precedes(在…之先)来选择触发器执行的先后顺序。 </span><br><span class="line">begin</span><br><span class="line">sql语句</span><br><span class="line">end &amp;&amp; &#x2F;&#x2F; 从begin到end就是触发器的主体,触发了什么。</span><br><span class="line">Delimiter ;</span><br></pre></td></tr></table></figure><h2 id="创建只有一个执行语句的触发器"><a href="#创建只有一个执行语句的触发器" class="headerlink" title="创建只有一个执行语句的触发器"></a>创建只有一个执行语句的触发器</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE TRIGGER 触发器名 BEFORE|AFTER 触发事件 ON 表名 FOR EACH ROW 执行语句;</span><br></pre></td></tr></table></figure><p>定义一个名为trig1的触发器，一旦在work表中有插入动作，就会自动往time表里插入当前时间</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DELIMITER &amp;&amp;</span><br><span class="line"> CREATE TRIGGER trig1 AFTER INSERT</span><br><span class="line">  ON work FOR EACH ROW</span><br><span class="line"> INSERT INTO time VALUES(NOW());</span><br><span class="line">&amp;&amp;</span><br><span class="line">DELIMITER ;</span><br></pre></td></tr></table></figure><h2 id="创建有多个执行语句的触发器"><a href="#创建有多个执行语句的触发器" class="headerlink" title="创建有多个执行语句的触发器"></a>创建有多个执行语句的触发器</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DELIMITER &amp;&amp;</span><br><span class="line">CREATE TRIGGER 触发器名 BEFORE|AFTER 触发事件</span><br><span class="line"></span><br><span class="line">ON 表名 FOR EACH ROW</span><br><span class="line"></span><br><span class="line">BEGIN</span><br><span class="line">        执行语句列表</span><br><span class="line">END &amp;&amp;</span><br><span class="line">DELIMITER ;</span><br></pre></td></tr></table></figure><p>定义一个触发器，一旦有满足条件的删除操作，就会执行BEGIN和END中的语句</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DELIMITER ||</span><br><span class="line">CREATE TRIGGER trig2 BEFORE DELETE</span><br><span class="line">ON work FOR EACH ROW</span><br><span class="line">BEGIN</span><br><span class="line"> 　　INSERT INTO time VALUES(NOW());</span><br><span class="line"> 　　INSERT INTO time VALUES(NOW());</span><br><span class="line"> END||</span><br><span class="line">mysql&gt; DELIMITER ;</span><br></pre></td></tr></table></figure><h2 id="NEW与OLD详解"><a href="#NEW与OLD详解" class="headerlink" title="NEW与OLD详解"></a>NEW与OLD详解</h2><p>MySQL 中定义了 NEW 和 OLD，用来表示触发器的所在表中，触发了触发器的那一行数据，来引用触发器中发生变化的记录内容，具体地：</p><ul><li>在INSERT型触发器中，NEW用来表示将要（BEFORE）或已经（AFTER）插入的新数据;</li><li>在UPDATE型触发器中，OLD用来表示将要或已经被修改的原数据，NEW用来表示将要或已经修改为的新数据;</li><li>在DELETE型触发器中，OLD用来表示将要或已经被删除的原数据;</li></ul><p>使用方法：<br>NEW.columnName （columnName为相应数据表某一列名）<br>另外，OLD是只读的，而NEW则可以在触发器中使用 SET 赋值，这样不会再次触发触发器，造成循环调用（如每插入一个学生前，都在其学号前加“2013”）。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">delimiter $$</span><br><span class="line">CREATE TRIGGER upd_check BEFORE UPDATE ON account</span><br><span class="line">FOR EACH ROW</span><br><span class="line">BEGIN</span><br><span class="line"> 　　IF NEW.amount &lt; 0 THEN</span><br><span class="line"> 　　　　SET NEW.amount &#x3D; 0;</span><br><span class="line"> 　　ELSEIF NEW.amount &gt; 100 THEN</span><br><span class="line"> 　　　　SET NEW.amount &#x3D; 100;</span><br><span class="line"> 　　END IF;</span><br><span class="line"> END$$</span><br><span class="line">delimiter ;</span><br></pre></td></tr></table></figure><p>上面触发器的意思是当新修改的数&lt;0 ，则把该数值改为0 如果修改成为&gt;100的数则把数组改为100</p><h2 id="查看触发器"><a href="#查看触发器" class="headerlink" title="查看触发器"></a>查看触发器</h2><p>1、SHOW TRIGGERS语句查看触发器信息<br>结果，显示所有触发器的基本信息；无法查询指定的触发器。<br>2、在information_schema.triggers表中查看触发器信息<br>SELECT * FROM information_schema.triggers<br>结果，显示所有触发器的详细信息；同时，该方法可以查询制定触发器的详细信息。<br>所有触发器信息都存储在information_schema数据库下的triggers表中，可以使用SELECT语句查询，如果触发器信息过多，最好通过TRIGGER_NAME字段指定查询。</p><h2 id="删除触发器"><a href="#删除触发器" class="headerlink" title="删除触发器"></a>删除触发器</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DROP TRIGGER [IF EXISTS] [schema_name.]trigger_name</span><br></pre></td></tr></table></figure><p>如果不需要某个触发器时一定要将这个触发器删除，以免造成意外操作，这很关键。</p><h1 id="触发器尽量避免使用"><a href="#触发器尽量避免使用" class="headerlink" title="触发器尽量避免使用"></a>触发器尽量避免使用</h1><p> 为什么大家都不推荐使用MySQL触发器而用存储过程？</p><ul><li>存储过程和触发器二者是有很大的联系的，我的一般理解就是触发器是一个隐藏的存储过程，因为它不需要参数，不需要显示调用，往往在你不知情的情况下已经做了很多操作。从这个角度来说，由于是隐藏的，无形中增加了系统的复杂性，非DBA人员理解起来数据库就会有困难，因为它不执行根本感觉不到它的存在。</li><li>再有，涉及到复杂的逻辑的时候，触发器的嵌套是避免不了的，如果再涉及几个存储过程，再加上事务等等，很容易出现死锁现象，再调试的时候也会经常性的从一个触发器转到另外一个，级联关系的不断追溯，很容易使人头大。其实，从性能上，触发器并没有提升多少性能，只是从代码上来说，可能在coding的时候很容易实现业务，所以我的观点是：摒弃触发器！触发器的功能基本都可以用存储过程来实现。</li><li>在编码中存储过程显示调用很容易阅读代码，触发器隐式调用容易被忽略。</li><li>存储过程的致命伤在于移植性，存储过程不能跨库移植，比如事先是在mysql数据库的存储过程，考虑性能要移植到oracle上面那么所有的存储过程都需要被重写一遍。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;mysql触发器&quot;&gt;&lt;a href=&quot;#mysql触发器&quot; class=&quot;headerlink&quot; title=&quot;mysql触发器&quot;&gt;&lt;/a&gt;mysql触发器&lt;/h1&gt;&lt;h2 id=&quot;什么是触发器？&quot;&gt;&lt;a href=&quot;#什么是触发器？&quot; class=&quot;header
      
    
    </summary>
    
    
      <category term="mysql" scheme="https://todcsw.github.io/categories/mysql/"/>
    
    
      <category term="学习" scheme="https://todcsw.github.io/tags/%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="mysql" scheme="https://todcsw.github.io/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>数据结构和算法小结</title>
    <link href="https://todcsw.github.io/2020/05/10/dataStructure-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95%E5%B0%8F%E7%BB%93/"/>
    <id>https://todcsw.github.io/2020/05/10/dataStructure-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95%E5%B0%8F%E7%BB%93/</id>
    <published>2020-05-10T15:50:43.000Z</published>
    <updated>2020-05-08T08:21:21.274Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Algorithm"><a href="#Algorithm" class="headerlink" title="Algorithm"></a>Algorithm</h1><p>数据结构和算法非常重要！加油干,不想做码农,就得好好学数据结构和算法。</p><h2 id="数据结构和算法"><a href="#数据结构和算法" class="headerlink" title="数据结构和算法"></a>数据结构和算法</h2><p>包含了各种基础数据结构和算法(链表、栈、图、树、递归、十大排序算法、查找算法、常用的十大算法(例如:克鲁斯卡尔算法,普里姆算法,kmp算法,马踏棋盘算法等)) </p><h2 id="关于该项目"><a href="#关于该项目" class="headerlink" title="关于该项目"></a>关于该项目</h2><ul><li>我是看尚硅谷韩顺平老师的数据结构和算法写的</li><li>附哔哩哔哩视频地址:<a href="https://www.bilibili.com/video/BV1E4411H73v" target="_blank" rel="noopener">https://www.bilibili.com/video/BV1E4411H73v</a></li><li>项目博客地址:<a href="https://todcsw.github.io">https://todcsw.github.io</a></li><li>项目地址:<a href="https://github.com/Todcsw/Algorithm.git" target="_blank" rel="noopener">https://github.com/Todcsw/Algorithm.git</a></li><li>项目学习笔记地址:<a href="https://note.youdao.com/ynoteshare1/index.html?id=2611437fa56c5d139a552e643448a816&amp;type=notebook" target="_blank" rel="noopener">https://note.youdao.com/ynoteshare1/index.html?id=2611437fa56c5d139a552e643448a816&amp;type=notebook</a><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2>我个人认为数据结构比较重要得好好学,而且上面的视频教程也非常的好。加油！奥里给！<h2 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h2>学完数据结构和算法就可以刷leetcode。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Algorithm&quot;&gt;&lt;a href=&quot;#Algorithm&quot; class=&quot;headerlink&quot; title=&quot;Algorithm&quot;&gt;&lt;/a&gt;Algorithm&lt;/h1&gt;&lt;p&gt;数据结构和算法非常重要！加油干,不想做码农,就得好好学数据结构和算法。&lt;/p&gt;
&lt;h
      
    
    </summary>
    
    
      <category term="数据结构" scheme="https://todcsw.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="学习" scheme="https://todcsw.github.io/tags/%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="java" scheme="https://todcsw.github.io/tags/java/"/>
    
      <category term="数据结构" scheme="https://todcsw.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>java实现马踏棋盘算法(骑士周游问题)</title>
    <link href="https://todcsw.github.io/2020/05/09/dataStructure-java%E5%AE%9E%E7%8E%B0%E9%A9%AC%E8%B8%8F%E6%A3%8B%E7%9B%98%E7%AE%97%E6%B3%95-%E9%AA%91%E5%A3%AB%E5%91%A8%E6%B8%B8%E9%97%AE%E9%A2%98/"/>
    <id>https://todcsw.github.io/2020/05/09/dataStructure-java%E5%AE%9E%E7%8E%B0%E9%A9%AC%E8%B8%8F%E6%A3%8B%E7%9B%98%E7%AE%97%E6%B3%95-%E9%AA%91%E5%A3%AB%E5%91%A8%E6%B8%B8%E9%97%AE%E9%A2%98/</id>
    <published>2020-05-09T10:04:43.000Z</published>
    <updated>2020-05-08T08:28:48.711Z</updated>
    
    <content type="html"><![CDATA[<h1 id="java实现马踏棋盘算法-骑士周游问题"><a href="#java实现马踏棋盘算法-骑士周游问题" class="headerlink" title="java实现马踏棋盘算法(骑士周游问题)"></a>java实现马踏棋盘算法(骑士周游问题)</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package com.csw.algorithm.horse;</span><br><span class="line"></span><br><span class="line">import java.awt.*;</span><br><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.Comparator;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * @Auther: 行路</span><br><span class="line"> * @Date: Created on 2020&#x2F;5&#x2F;9 17:22 星期六</span><br><span class="line"> * @Description: com.csw.algorithm.horse</span><br><span class="line"> * @version: 1.0 马踏棋盘算法(骑士周游问题)</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class HorseChessBoard &#123;</span><br><span class="line"></span><br><span class="line">    private static int X;&#x2F;&#x2F;棋盘的列数</span><br><span class="line">    private static int Y;&#x2F;&#x2F;棋盘的行数</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;创建一个数组标记棋盘的各个位置是否被访问过</span><br><span class="line">    private static boolean visited[];</span><br><span class="line">    &#x2F;&#x2F;使用一个属性,标记是否棋盘的所有位置都被访问过</span><br><span class="line">    private static boolean finished; &#x2F;&#x2F;如果为true表示成功</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        System.out.println(&quot;测试骑士周游算法&quot;);</span><br><span class="line">        &#x2F;&#x2F;测试骑士周游算法是否正确</span><br><span class="line">        X&#x3D;8;</span><br><span class="line">        Y&#x3D;8;</span><br><span class="line">        int row&#x3D;1; &#x2F;&#x2F;马儿初始位置的行,从1开始编号</span><br><span class="line">        int column&#x3D;1; &#x2F;&#x2F;马儿初始位置列,从1开始编号</span><br><span class="line">        &#x2F;&#x2F;创建棋盘,</span><br><span class="line">        int[][] chessboard&#x3D;new int[X][Y];</span><br><span class="line">        visited&#x3D;new boolean[X*Y]; &#x2F;&#x2F;初始值都是false</span><br><span class="line">        &#x2F;&#x2F;测试耗时</span><br><span class="line">        long start &#x3D; System.currentTimeMillis();</span><br><span class="line">        traversalChessboard(chessboard,row-1,column-1,1);</span><br><span class="line">        long end&#x3D;System.currentTimeMillis();</span><br><span class="line">        System.out.println(&quot;共耗时：&quot;+(end-start)+&quot;毫秒&quot;);</span><br><span class="line">        &#x2F;&#x2F;输出棋盘最后的情况</span><br><span class="line">        for(int[] rows:chessboard)&#123;</span><br><span class="line">            for(int step:rows)&#123;</span><br><span class="line">                System.out.print(step+&quot;\t&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(&quot;&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 骑士周游问题的算法</span><br><span class="line">     * @param chessboard 棋盘</span><br><span class="line">     * @param row 马儿当前位置的行</span><br><span class="line">     * @param column 马儿当前位置的列</span><br><span class="line">     * @param step 马儿走的第几步</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public static void traversalChessboard(int[][] chessboard,int row,int column,int step)&#123;</span><br><span class="line">        chessboard[row][column]&#x3D;step;</span><br><span class="line">        &#x2F;&#x2F;row&#x3D;4 X&#x3D;8 colum&#x3D;4  4*8+4&#x3D;36</span><br><span class="line">        visited[row*X+column]&#x3D;true; &#x2F;&#x2F;标记该位置已经访问</span><br><span class="line">        &#x2F;&#x2F;获取当前位置可以走的下一个位置的集合</span><br><span class="line">        ArrayList&lt;Point&gt; ps &#x3D; next(new Point(column, row));</span><br><span class="line">        &#x2F;&#x2F;对ps进行排序,排序的规则就是对所有的Point对象的下一步位置的数目,进行非递减排序</span><br><span class="line">        sort(ps);</span><br><span class="line">        &#x2F;&#x2F;遍历ps</span><br><span class="line">        while (!ps.isEmpty())&#123;</span><br><span class="line">            Point p &#x3D; ps.remove(0);&#x2F;&#x2F;取出下一个可以走的位置</span><br><span class="line">            &#x2F;&#x2F;判断该点是否已经访问过x</span><br><span class="line">            if(!visited[p.y*X+p.x])&#123; &#x2F;&#x2F;说明没有访问过</span><br><span class="line">                traversalChessboard(chessboard,p.y,p.x,step+1);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;判断马儿是否完成了任务,使用step和应该的步数比较,</span><br><span class="line">        &#x2F;&#x2F;如果没有达到数量,则表示没有完成任务,将整个棋盘置为0</span><br><span class="line">        &#x2F;&#x2F;说明：step&lt;X*Y成立的情况有两种</span><br><span class="line">        &#x2F;&#x2F;1.棋盘到目前为止,仍然没有走完,</span><br><span class="line">        &#x2F;&#x2F;2.处于回溯的过程</span><br><span class="line">        if(step&lt;X*Y&amp;&amp;!finished)&#123;</span><br><span class="line">            chessboard[row][column]&#x3D;0;</span><br><span class="line">            visited[row*X+column]&#x3D;false;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            finished&#x3D;true;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 功能:根据当前的位置(point对象),计算马还能走那些位置(Point),并放入到一个集合中(ArrayList),做多有8个位置</span><br><span class="line">     * @param curPoint</span><br><span class="line">     * @return</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public static ArrayList&lt;Point&gt; next(Point curPoint)&#123;</span><br><span class="line">        &#x2F;&#x2F;创建一个ArrayList</span><br><span class="line">        ArrayList&lt;Point&gt; ps&#x3D;new ArrayList&lt;&gt;();</span><br><span class="line">        &#x2F;&#x2F;创建一个point</span><br><span class="line">        Point p1&#x3D;new Point();</span><br><span class="line">        &#x2F;&#x2F;&#x2F;&#x2F;判断马可以走5位置</span><br><span class="line">        if((p1.x&#x3D;curPoint.x-2)&gt;&#x3D;0&amp;&amp;(p1.y&#x3D;curPoint.y-1)&gt;&#x3D;0)&#123;</span><br><span class="line">            ps.add(new Point(p1));</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;判断马可以走6位置</span><br><span class="line">        if((p1.x&#x3D;curPoint.x-1)&gt;&#x3D;0&amp;&amp;(p1.y&#x3D;curPoint.y-2)&gt;&#x3D;0)&#123;</span><br><span class="line">            ps.add(new Point(p1));</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;判断马可以走7位置</span><br><span class="line">        if((p1.x&#x3D;curPoint.x+1)&lt;X&amp;&amp;(p1.y&#x3D;curPoint.y-2)&gt;&#x3D;0)&#123;</span><br><span class="line">            ps.add(new Point(p1));</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;判断马可以走0位置</span><br><span class="line">        if((p1.x&#x3D;curPoint.x+2)&lt;X&amp;&amp;(p1.y&#x3D;curPoint.y-1)&gt;&#x3D;0)&#123;</span><br><span class="line">            ps.add(new Point(p1));</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;判断马可以走1位置</span><br><span class="line">        if((p1.x&#x3D;curPoint.x+2)&lt;X&amp;&amp;(p1.y&#x3D;curPoint.y+1)&lt;Y)&#123;</span><br><span class="line">            ps.add(new Point(p1));</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;判断马可以走2位置</span><br><span class="line">        if((p1.x&#x3D;curPoint.x+1)&lt;X&amp;&amp;(p1.y&#x3D;curPoint.y+2)&lt;Y)&#123;</span><br><span class="line">            ps.add(new Point(p1));</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;判断马可以走3位置</span><br><span class="line">        if((p1.x&#x3D;curPoint.x-1)&gt;&#x3D;0&amp;&amp;(p1.y&#x3D;curPoint.y+2)&lt;Y)&#123;</span><br><span class="line">            ps.add(new Point(p1));</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;判断马可以走4位置</span><br><span class="line">        if((p1.x&#x3D;curPoint.x-2)&gt;&#x3D;0&amp;&amp;(p1.y&#x3D;curPoint.y+1)&lt;Y)&#123;</span><br><span class="line">            ps.add(new Point(p1));</span><br><span class="line">        &#125;</span><br><span class="line">        return ps;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;根据当前这一步的所有的下一步的选择位置,进行非递减排序，减少回溯次数</span><br><span class="line">    public static void  sort(ArrayList&lt;Point&gt; ps)&#123;</span><br><span class="line">        ps.sort(new Comparator&lt;Point&gt;() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public int compare(Point o1, Point o2) &#123;</span><br><span class="line">                &#x2F;&#x2F;获取到01,这个点的下一步的所有位置</span><br><span class="line">                int count1 &#x3D; next(o1).size();</span><br><span class="line">                &#x2F;&#x2F;获取到02,这个点的下一步的所有位置</span><br><span class="line">                int count2&#x3D;next(o2).size();</span><br><span class="line">                if(count1&lt;count2)&#123;</span><br><span class="line">                    return -1;</span><br><span class="line">                &#125;else if(count1&#x3D;&#x3D;count2)&#123;</span><br><span class="line">                    return 0;</span><br><span class="line">                &#125;else&#123;</span><br><span class="line">                    return 1;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;java实现马踏棋盘算法-骑士周游问题&quot;&gt;&lt;a href=&quot;#java实现马踏棋盘算法-骑士周游问题&quot; class=&quot;headerlink&quot; title=&quot;java实现马踏棋盘算法(骑士周游问题)&quot;&gt;&lt;/a&gt;java实现马踏棋盘算法(骑士周游问题)&lt;/h1&gt;&lt;fi
      
    
    </summary>
    
    
      <category term="数据结构" scheme="https://todcsw.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="学习" scheme="https://todcsw.github.io/tags/%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="java" scheme="https://todcsw.github.io/tags/java/"/>
    
      <category term="数据结构" scheme="https://todcsw.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>java弗洛伊德算法(最短路径问题)</title>
    <link href="https://todcsw.github.io/2020/05/08/dataStructure-java%E5%BC%97%E6%B4%9B%E4%BC%8A%E5%BE%B7%E7%AE%97%E6%B3%95-%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E9%97%AE%E9%A2%98/"/>
    <id>https://todcsw.github.io/2020/05/08/dataStructure-java%E5%BC%97%E6%B4%9B%E4%BC%8A%E5%BE%B7%E7%AE%97%E6%B3%95-%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E9%97%AE%E9%A2%98/</id>
    <published>2020-05-08T09:23:54.000Z</published>
    <updated>2020-05-08T08:29:12.056Z</updated>
    
    <content type="html"><![CDATA[<h1 id="java弗洛伊德算法-最短路径问题"><a href="#java弗洛伊德算法-最短路径问题" class="headerlink" title="java弗洛伊德算法(最短路径问题)"></a>java弗洛伊德算法(最短路径问题)</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package com.csw.algorithm.floyd;</span><br><span class="line"></span><br><span class="line">import sun.security.util.Length;</span><br><span class="line"></span><br><span class="line">import java.util.Arrays;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * @Auther: 行路</span><br><span class="line"> * @Date: Created on 2020&#x2F;5&#x2F;8 16:06 星期五</span><br><span class="line"> * @Description: com.csw.algorithm.floyd</span><br><span class="line"> * @version: 1.0 弗洛伊德算法</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class FloydAlgorithm &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        &#x2F;&#x2F;测试图是否创建成功</span><br><span class="line">        char[] vertex&#x3D;&#123;&#39;A&#39;,&#39;B&#39;,&#39;C&#39;,&#39;D&#39;,&#39;E&#39;,&#39;F&#39;,&#39;G&#39;&#125;;</span><br><span class="line">        &#x2F;&#x2F;创建领接矩阵</span><br><span class="line">        int[][] matrix&#x3D;new int[vertex.length][vertex.length];</span><br><span class="line">        final int N&#x3D;65535;</span><br><span class="line">        matrix[0] &#x3D; new int[]&#123;0, 5, 7, N, N, N, 2&#125;;</span><br><span class="line">        matrix[1] &#x3D; new int[]&#123;5, 0, N, 9, N, N, 3&#125;;</span><br><span class="line">        matrix[2] &#x3D; new int[]&#123;7, N, 0, N, 8, N, N&#125;;</span><br><span class="line">        matrix[3] &#x3D; new int[]&#123;N, 9, N, 0, N, 4, N&#125;;</span><br><span class="line">        matrix[4] &#x3D; new int[]&#123;N, N, 8, N, 0, 5, 4&#125;;</span><br><span class="line">        matrix[5] &#x3D; new int[]&#123;N, N, N, 4, 5, 0, 6&#125;;</span><br><span class="line">        matrix[6] &#x3D; new int[]&#123;2, 3, N, N, 4, 6, 0&#125;;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;创建Graph对象</span><br><span class="line">        Graph graph &#x3D; new Graph(vertex.length, matrix, vertex);</span><br><span class="line">        &#x2F;&#x2F;调用弗洛伊德算法</span><br><span class="line">        graph.floyd();</span><br><span class="line">        graph.show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;创建图</span><br><span class="line">class Graph &#123;</span><br><span class="line">    private char[] vertex; &#x2F;&#x2F;存放顶点的数组</span><br><span class="line">    private int[][] dis; &#x2F;&#x2F;记录从各个顶点出发到其他顶点的距离,最后的结果,也是保留在该数组总</span><br><span class="line">    private int[][] pre; &#x2F;&#x2F;保存到达目标顶点的前驱节点</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     *构造器</span><br><span class="line">     * @param length  大小</span><br><span class="line">     * @param matrix  领接矩阵</span><br><span class="line">     * @param vertex  顶点数组</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public Graph(int length,int[][] matrix,char[] vertex)&#123;</span><br><span class="line">        this.vertex&#x3D;vertex;</span><br><span class="line">        this.dis&#x3D;matrix;</span><br><span class="line">        this.pre&#x3D;new int[length][length];</span><br><span class="line">        &#x2F;&#x2F;对pre数组初始化,存放的是前驱节点的下标</span><br><span class="line">        for(int i&#x3D;0;i&lt;length;i++)&#123;</span><br><span class="line">            Arrays.fill(pre[i],i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;显示pre数组和dis数组</span><br><span class="line">    public void show()&#123;</span><br><span class="line">        &#x2F;&#x2F;为了显示便于阅读,优化输出</span><br><span class="line">        for(int k&#x3D;0;k&lt;dis.length;k++)&#123;</span><br><span class="line">            &#x2F;&#x2F;先将pre数组输出一行数据</span><br><span class="line">            for(int i&#x3D;0;i&lt;dis.length;i++)&#123;</span><br><span class="line">                System.out.print(vertex[pre[k][i]]+&quot; &quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(&quot;&quot;);</span><br><span class="line">            &#x2F;&#x2F;输出dis数组的一行数据</span><br><span class="line">            for(int i&#x3D;0;i&lt;dis.length;i++)&#123;</span><br><span class="line">                System.out.print(&quot;(&quot;+vertex[k]+&quot;到&quot;+vertex[i]+&quot;的最短路径&quot;+dis[k][i]+&quot;) &quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(&quot;&quot;);</span><br><span class="line">            System.out.println(&quot;&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;弗洛伊德算法</span><br><span class="line">    public void floyd()&#123;</span><br><span class="line">        int len&#x3D;0; &#x2F;&#x2F;记录变量保存距离</span><br><span class="line">        &#x2F;&#x2F;中间顶点的遍历,k就是中间顶点的下标 [&#39;A&#39;,&#39;B&#39;,&#39;C&#39;,&#39;D&#39;,&#39;E&#39;,&#39;F&#39;,&#39;G&#39;]</span><br><span class="line">        for(int k&#x3D;0;k&lt;dis.length;k++)&#123;</span><br><span class="line">            &#x2F;&#x2F;从i顶点开始出发[&#39;A&#39;,&#39;B&#39;,&#39;C&#39;,&#39;D&#39;,&#39;E&#39;,&#39;F&#39;,&#39;G&#39;]</span><br><span class="line">            for(int i&#x3D;0;i&lt;dis.length;i++)&#123;</span><br><span class="line"></span><br><span class="line">                &#x2F;&#x2F;j到达顶点 [&#39;A&#39;,&#39;B&#39;,&#39;C&#39;,&#39;D&#39;,&#39;E&#39;,&#39;F&#39;,&#39;G&#39;]</span><br><span class="line">                for(int j&#x3D;0;j&lt;dis.length;j++)&#123;</span><br><span class="line">                    len&#x3D;dis[i][k]+dis[k][j]; &#x2F;&#x2F;从i顶点出发,经过k中间顶点,到达J顶点距离</span><br><span class="line">                    if(len&lt;dis[i][j])&#123;</span><br><span class="line">                        &#x2F;&#x2F;如果len小于dis[i][j]</span><br><span class="line">                        dis[i][j]&#x3D;len; &#x2F;&#x2F;更新距离</span><br><span class="line">                        pre[i][j]&#x3D;pre[k][j]; &#x2F;&#x2F;更新前驱节点</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;java弗洛伊德算法-最短路径问题&quot;&gt;&lt;a href=&quot;#java弗洛伊德算法-最短路径问题&quot; class=&quot;headerlink&quot; title=&quot;java弗洛伊德算法(最短路径问题)&quot;&gt;&lt;/a&gt;java弗洛伊德算法(最短路径问题)&lt;/h1&gt;&lt;figure cla
      
    
    </summary>
    
    
      <category term="数据结构" scheme="https://todcsw.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="学习" scheme="https://todcsw.github.io/tags/%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="java" scheme="https://todcsw.github.io/tags/java/"/>
    
      <category term="数据结构" scheme="https://todcsw.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>java实现迪杰斯特拉算法(最短路径问题)</title>
    <link href="https://todcsw.github.io/2020/05/07/dataStructure-java%E5%AE%9E%E7%8E%B0%E8%BF%AA%E6%9D%B0%E6%96%AF%E7%89%B9%E6%8B%89%E7%AE%97%E6%B3%95-%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E9%97%AE%E9%A2%98/"/>
    <id>https://todcsw.github.io/2020/05/07/dataStructure-java%E5%AE%9E%E7%8E%B0%E8%BF%AA%E6%9D%B0%E6%96%AF%E7%89%B9%E6%8B%89%E7%AE%97%E6%B3%95-%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E9%97%AE%E9%A2%98/</id>
    <published>2020-05-07T06:50:45.000Z</published>
    <updated>2020-05-08T08:28:29.084Z</updated>
    
    <content type="html"><![CDATA[<h1 id="java实现迪杰斯特拉算法-最短路径问题"><a href="#java实现迪杰斯特拉算法-最短路径问题" class="headerlink" title="java实现迪杰斯特拉算法(最短路径问题)"></a>java实现迪杰斯特拉算法(最短路径问题)</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package com.csw.algorithm.dijkstra;</span><br><span class="line"></span><br><span class="line">import java.util.Arrays;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * @Auther: 行路</span><br><span class="line"> * @Date: Created on 2020&#x2F;5&#x2F;7 13:30 星期四</span><br><span class="line"> * @Description: com.csw.algorithm.dijkstra</span><br><span class="line"> * @version: 1.0 迪杰斯特拉算法</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class DijkstraAlgorithm &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        char[] vertex &#x3D; &#123;&#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;, &#39;E&#39;, &#39;F&#39;, &#39;G&#39;&#125;;</span><br><span class="line">        &#x2F;&#x2F;领接矩阵</span><br><span class="line">        int[][] matrix &#x3D; new int[vertex.length][vertex.length];</span><br><span class="line">        final int N &#x3D; 65536; &#x2F;&#x2F;表示不可以连接</span><br><span class="line">        matrix[0] &#x3D; new int[]&#123;N, 5, 7, N, N, N, 2&#125;;</span><br><span class="line">        matrix[1] &#x3D; new int[]&#123;5, N, N, 9, N, N, 3&#125;;</span><br><span class="line">        matrix[2] &#x3D; new int[]&#123;7, N, N, N, 8, N, N&#125;;</span><br><span class="line">        matrix[3] &#x3D; new int[]&#123;N, 9, N, N, N, 4, N&#125;;</span><br><span class="line">        matrix[4] &#x3D; new int[]&#123;N, N, 8, N, N, 5, 4&#125;;</span><br><span class="line">        matrix[5] &#x3D; new int[]&#123;N, N, N, 4, 5, N, 6&#125;;</span><br><span class="line">        matrix[6] &#x3D; new int[]&#123;2, 3, N, N, 4, 6, N&#125;;</span><br><span class="line">        &#x2F;&#x2F;创建Graph对象</span><br><span class="line">        Graph graph &#x3D; new Graph(vertex, matrix);</span><br><span class="line">        &#x2F;&#x2F;看图矩阵</span><br><span class="line">        graph.showGraph();</span><br><span class="line">        &#x2F;&#x2F;测试迪杰斯特拉算法</span><br><span class="line">         graph.dsj(6);</span><br><span class="line">         graph.showDijkstra();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Graph &#123;</span><br><span class="line">    private char[] vertex; &#x2F;&#x2F;顶点数组</span><br><span class="line">    private int[][] matrix; &#x2F;&#x2F;领接矩阵</span><br><span class="line">    private VisitedVertex vv; &#x2F;&#x2F;已经访问的顶点集合</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;构造器</span><br><span class="line">    public Graph(char[] vertex, int[][] matrix) &#123;</span><br><span class="line">        this.vertex &#x3D; vertex;</span><br><span class="line">        this.matrix &#x3D; matrix;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;显示结果</span><br><span class="line">    public void showDijkstra()&#123;</span><br><span class="line">        vv.show();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;显示图</span><br><span class="line">    public void showGraph() &#123;</span><br><span class="line">        for (int[] link : matrix) &#123;</span><br><span class="line">            System.out.println(Arrays.toString(link));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 迪杰斯特拉算法</span><br><span class="line">     * @param index 表示出发顶点的下标</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public void dsj(int index)&#123;</span><br><span class="line">         vv&#x3D; new VisitedVertex(vertex.length, index);</span><br><span class="line">         update(index); &#x2F;&#x2F;更新index下标顶点到周围顶点的距离和前驱顶点</span><br><span class="line">         for(int j&#x3D;1;j&lt;vertex.length;j++)&#123;</span><br><span class="line">             index&#x3D;vv.updateArr();&#x2F;&#x2F;选择并返回新的访问顶点</span><br><span class="line">             update(index);</span><br><span class="line">         &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;更新Index下标顶点到周围顶点的距离和周围顶点的前驱</span><br><span class="line">    public void update(int index)&#123;</span><br><span class="line">        int len&#x3D;0;</span><br><span class="line">        &#x2F;&#x2F;根据遍历我们的领接矩阵的matrix[index]行</span><br><span class="line">        for(int j&#x3D;0;j&lt;matrix[index].length;j++)&#123;</span><br><span class="line">            &#x2F;&#x2F;len含义:出发顶点到index顶点的距离+从Index顶点到j顶点的距离和</span><br><span class="line">            len&#x3D;vv.getDis(index)+matrix[index][j];</span><br><span class="line">            &#x2F;&#x2F;如果j这个顶点没有被访问过并且len小于出发顶点的距离,就需要更新</span><br><span class="line">            if(!vv.in(j)&amp;&amp;len&lt;vv.getDis(j))&#123;</span><br><span class="line">                vv.updatePre(j,index); &#x2F;&#x2F;更新j顶点的前驱为index顶点</span><br><span class="line">                vv.updateDis(j,len); &#x2F;&#x2F;更新出发顶点到j顶点的距离</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * Description: 以访问顶点的集合</span><br><span class="line"> *</span><br><span class="line"> * @author Todcsw</span><br><span class="line"> * @date</span><br><span class="line"> *&#x2F;</span><br><span class="line">class VisitedVertex &#123;</span><br><span class="line">    &#x2F;&#x2F;记录各个顶点是否访问过,1表示已经访问过,0未访问,会动态更新</span><br><span class="line">    public int[] already_arr;</span><br><span class="line">    &#x2F;&#x2F;每个小标对应的值为前一个顶点下标,会动态更新</span><br><span class="line">    public int[] pre_visited;</span><br><span class="line">    &#x2F;&#x2F;记录出发顶点到其他所有顶点的距离,比如G为出发顶点,就会记录G到其他顶点的距离,会动态更新,求的最短距离就会存放到ids</span><br><span class="line">    public int[] dis;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 构造器</span><br><span class="line">     *</span><br><span class="line">     * @param length :表示顶点的个数</span><br><span class="line">     * @param index  :出发顶点 对用的下标,比如G顶点,下标就是6</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public VisitedVertex(int length, int index) &#123;</span><br><span class="line">        this.already_arr &#x3D; new int[length];</span><br><span class="line">        this.pre_visited &#x3D; new int[length];</span><br><span class="line">        this.dis &#x3D; new int[length];</span><br><span class="line">        &#x2F;&#x2F;初始化dis数组</span><br><span class="line">        Arrays.fill(dis, 65535);</span><br><span class="line">        this.already_arr[index]&#x3D;1; &#x2F;&#x2F;设置出发顶点被访问过</span><br><span class="line">        this.dis[index] &#x3D; 0; &#x2F;&#x2F;设置出发顶点的访问距离为0</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 功能:判断Index顶点是否被访问过</span><br><span class="line">     *</span><br><span class="line">     * @param index</span><br><span class="line">     * @return 如果访问过, 就返回true，否则就返回false</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public boolean in(int index) &#123;</span><br><span class="line">        return already_arr[index] &#x3D;&#x3D; 1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 功能:更新出发顶点到index顶点的距离</span><br><span class="line">     * @param index</span><br><span class="line">     * @param len</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public void updateDis(int index, int len) &#123;</span><br><span class="line">        dis[index]&#x3D;len;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 功能:更新pre这个顶点的前驱节点为index节点</span><br><span class="line">     * @param pre</span><br><span class="line">     * @param index</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public void updatePre(int pre,int index)&#123;</span><br><span class="line">        pre_visited[pre]&#x3D;index;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 功能：放回出发顶点到index顶点的距离</span><br><span class="line">     * @param index</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public int getDis(int index)&#123;</span><br><span class="line">        return dis[index];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 继续选择并返回新的访问节点,比如这里的G,就是A点作为新的访问顶点(不是出发顶点)</span><br><span class="line">     * @return</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public int updateArr()&#123;</span><br><span class="line">        int min&#x3D;65535,index&#x3D;0;</span><br><span class="line">        for(int i&#x3D;0;i&lt;already_arr.length;i++)&#123;</span><br><span class="line">            if(already_arr[i]&#x3D;&#x3D;0&amp;&amp;dis[i]&lt;min)&#123;</span><br><span class="line">                min&#x3D;dis[i];</span><br><span class="line">                index&#x3D;i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;更新index顶点被访问过</span><br><span class="line">        already_arr[index]&#x3D;1;</span><br><span class="line">        return index;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;显示最后的结果</span><br><span class="line">    &#x2F;&#x2F;将三个数组情况输出</span><br><span class="line">    public void show()&#123;</span><br><span class="line">        System.out.println(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;);</span><br><span class="line">        &#x2F;&#x2F;输出already_arr</span><br><span class="line">        for(int i:already_arr)&#123;</span><br><span class="line">            System.out.print(i+&quot; &quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot;&quot;);</span><br><span class="line">        &#x2F;&#x2F;输出pre_visited</span><br><span class="line">        for(int i:pre_visited)&#123;</span><br><span class="line">            System.out.print(i+&quot; &quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot;&quot;);</span><br><span class="line">        &#x2F;&#x2F;输出dis</span><br><span class="line">        for(int i:dis)&#123;</span><br><span class="line">            System.out.print(i+&quot; &quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;&quot;);</span><br><span class="line">        &#x2F;&#x2F;处理距离</span><br><span class="line">        char[] vertex &#x3D; &#123;&#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;, &#39;E&#39;, &#39;F&#39;, &#39;G&#39;&#125;;</span><br><span class="line">        int count&#x3D;0;</span><br><span class="line">        for(int i:dis)&#123;</span><br><span class="line">            if(i!&#x3D;65535)&#123;</span><br><span class="line">                System.out.print(vertex[count]+&quot;(&quot;+i+&quot;)&quot;);</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                System.out.println(&quot;N &quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot;&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;java实现迪杰斯特拉算法-最短路径问题&quot;&gt;&lt;a href=&quot;#java实现迪杰斯特拉算法-最短路径问题&quot; class=&quot;headerlink&quot; title=&quot;java实现迪杰斯特拉算法(最短路径问题)&quot;&gt;&lt;/a&gt;java实现迪杰斯特拉算法(最短路径问题)&lt;/h1
      
    
    </summary>
    
    
      <category term="数据结构" scheme="https://todcsw.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="学习" scheme="https://todcsw.github.io/tags/%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="java" scheme="https://todcsw.github.io/tags/java/"/>
    
      <category term="数据结构" scheme="https://todcsw.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>java实现最小生成树分别使用普里姆算法和克鲁斯卡尔算法</title>
    <link href="https://todcsw.github.io/2020/05/06/dataStructure-java%E5%AE%9E%E7%8E%B0%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%E5%88%86%E5%88%AB%E4%BD%BF%E7%94%A8%E6%99%AE%E9%87%8C%E5%A7%86%E7%AE%97%E6%B3%95%E5%92%8C%E5%85%8B%E9%B2%81%E6%96%AF%E5%8D%A1%E5%B0%94%E7%AE%97%E6%B3%95/"/>
    <id>https://todcsw.github.io/2020/05/06/dataStructure-java%E5%AE%9E%E7%8E%B0%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%E5%88%86%E5%88%AB%E4%BD%BF%E7%94%A8%E6%99%AE%E9%87%8C%E5%A7%86%E7%AE%97%E6%B3%95%E5%92%8C%E5%85%8B%E9%B2%81%E6%96%AF%E5%8D%A1%E5%B0%94%E7%AE%97%E6%B3%95/</id>
    <published>2020-05-06T05:00:05.000Z</published>
    <updated>2020-05-03T05:00:30.870Z</updated>
    
    <content type="html"><![CDATA[<h1 id="普里姆算法"><a href="#普里姆算法" class="headerlink" title="普里姆算法"></a>普里姆算法</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package com.csw.algorithm.prem;</span><br><span class="line"></span><br><span class="line">import com.csw.graph.Graph;</span><br><span class="line"></span><br><span class="line">import java.util.Arrays;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * @Auther: 行路</span><br><span class="line"> * @Date: Created on 2020&#x2F;5&#x2F;5 22:54 星期二</span><br><span class="line"> * @Description: com.csw.algorithm.prem</span><br><span class="line"> * @version: 1.0 普里姆算法</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class PrimAlgorithm &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;测试图是否创建成功</span><br><span class="line">        char[] data &#x3D; new char[]&#123;&#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;, &#39;E&#39;, &#39;F&#39;, &#39;G&#39;&#125;;</span><br><span class="line">        int vertex &#x3D; data.length;</span><br><span class="line">        &#x2F;&#x2F;将领接矩阵的关系,使用二维数组来表示</span><br><span class="line">        int[][] weight &#x3D; new int[][]&#123;</span><br><span class="line">                &#123;10000, 5, 7, 10000, 10000, 10000, 2&#125;,</span><br><span class="line">                &#123;5, 10000, 10000, 9, 10000, 10000, 3&#125;,</span><br><span class="line">                &#123;7, 10000, 10000, 10000, 8, 10000, 10000&#125;,</span><br><span class="line">                &#123;10000, 9, 10000, 10000, 10000, 4, 10000&#125;,</span><br><span class="line">                &#123;10000, 10000, 8, 10000, 10000, 5, 4&#125;,</span><br><span class="line">                &#123;10000, 10000, 10000, 4, 5, 10000, 6&#125;,</span><br><span class="line">                &#123;2, 3, 10000, 10000, 4, 6, 10000&#125;,&#125;;</span><br><span class="line">        &#x2F;&#x2F;创建MGraph对象</span><br><span class="line">        MGraph graph &#x3D; new MGraph(vertex);</span><br><span class="line">        &#x2F;&#x2F;创建一个MinTree对象</span><br><span class="line">        MinTree minTree &#x3D; new MinTree();</span><br><span class="line">        minTree.createGraph(graph,vertex,data,weight);</span><br><span class="line">        &#x2F;&#x2F;输出</span><br><span class="line">        minTree.showGraph(graph);</span><br><span class="line">        &#x2F;&#x2F;测试普里姆算法</span><br><span class="line">        minTree.prim(graph,0);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;创建最小生成树-&gt;村庄的图</span><br><span class="line"></span><br><span class="line">class MinTree &#123;</span><br><span class="line">    &#x2F;&#x2F;创建图的领接矩阵</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * @param graph  图对象</span><br><span class="line">     * @param vertex 图对应的顶点个数</span><br><span class="line">     * @param data   图的各个顶点的值</span><br><span class="line">     * @param weight 图的领接矩阵</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public void createGraph(MGraph graph, int vertex, char[] data, int[][] weight) &#123;</span><br><span class="line">        int i, j;</span><br><span class="line">        for (i &#x3D; 0; i &lt; vertex; i++) &#123;</span><br><span class="line">            graph.data[i] &#x3D; data[i];</span><br><span class="line">            for (j &#x3D; 0; j &lt; vertex; j++) &#123;</span><br><span class="line">                graph.weight[i][j] &#x3D; weight[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 显示图的领接矩阵</span><br><span class="line">     *</span><br><span class="line">     * @param graph</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public void showGraph(MGraph graph) &#123;</span><br><span class="line">        for (int[] link : graph.weight) &#123;</span><br><span class="line">            System.out.println(Arrays.toString(link));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 编写prim算法,得到最小生成树</span><br><span class="line">     * @param graph 图</span><br><span class="line">     * @param v 表示从图的第几个顶点开始生成</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public void prim(MGraph graph,int v)&#123;</span><br><span class="line">        &#x2F;&#x2F;visited[] 标记节点是否被访问过</span><br><span class="line">        int visited[]&#x3D;new int[graph.vertex];</span><br><span class="line">        &#x2F;&#x2F;visited[] 默认元素的值都是0,表示没有访问过</span><br><span class="line">&#x2F;&#x2F;        for(int i&#x3D;0;i&lt;graph.vertex;i++)&#123;</span><br><span class="line">&#x2F;&#x2F;            visited[i]&#x3D;0;</span><br><span class="line">&#x2F;&#x2F;        &#125; 默认都是0</span><br><span class="line">        &#x2F;&#x2F;把当前这个节点标记未以访问</span><br><span class="line">        visited[v]&#x3D;1;</span><br><span class="line">        &#x2F;&#x2F;h1,h2记录两个顶点的下标</span><br><span class="line">        int h1&#x3D;-1;</span><br><span class="line">        int h2&#x3D;-1;</span><br><span class="line">        int minWeight&#x3D;10000; &#x2F;&#x2F;将minWeight初始化成一个大数,后面在遍历过程中,会被替换</span><br><span class="line">        for(int k&#x3D;1;k&lt;graph.vertex;k++)&#123;</span><br><span class="line">            &#x2F;&#x2F;因为有graph.vertex顶点,普里姆算法结束后,有graph.vertex-1边</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F;这个是确定每一次生成的子图,和那个节点的距离最近</span><br><span class="line">            for(int i&#x3D;0;i&lt;graph.vertex;i++)&#123; &#x2F;&#x2F;i节点被访问过的节点</span><br><span class="line">                for(int j&#x3D;0;j&lt;graph.vertex;j++)&#123; &#x2F;&#x2F;j的节点表示还没有访问过的节点</span><br><span class="line">                    if(visited[i]&#x3D;&#x3D;1&amp;&amp;visited[j]&#x3D;&#x3D;0&amp;&amp;graph.weight[i][j]&lt;minWeight)&#123;</span><br><span class="line">                        &#x2F;&#x2F;替换minWeight(寻找已经访问过的节点和未访问过的节点间的权值最小的边)</span><br><span class="line">                        minWeight&#x3D;graph.weight[i][j];</span><br><span class="line">                        h1&#x3D;i;</span><br><span class="line">                        h2&#x3D;j;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F;找到一条边是最小的</span><br><span class="line">            System.out.println(&quot;边&lt;&quot;+graph.data[h1]+&quot;,&quot;+graph.data[h2]+&quot;&gt;权值:&quot;+minWeight);</span><br><span class="line">            &#x2F;&#x2F;将当前找到的节点标记为已经访问</span><br><span class="line">            visited[h2]&#x3D;1;</span><br><span class="line">            &#x2F;&#x2F;minWeight重新设置为最大值10000</span><br><span class="line">            minWeight&#x3D;10000;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class MGraph &#123;</span><br><span class="line">    int vertex; &#x2F;&#x2F;表示图的节点个数</span><br><span class="line">    char[] data;&#x2F;&#x2F;存放节点数据</span><br><span class="line">    int[][] weight;&#x2F;&#x2F;存放边,就是领接矩阵</span><br><span class="line"></span><br><span class="line">    public MGraph(int vertex) &#123;</span><br><span class="line">        this.vertex &#x3D; vertex;</span><br><span class="line">        data &#x3D; new char[vertex];</span><br><span class="line">        weight &#x3D; new int[vertex][vertex];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="克鲁斯卡尔算法"><a href="#克鲁斯卡尔算法" class="headerlink" title="克鲁斯卡尔算法"></a>克鲁斯卡尔算法</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package com.csw.algorithm.kruskal;</span><br><span class="line"></span><br><span class="line">import java.util.Arrays;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * @Auther: 行路</span><br><span class="line"> * @Date: Created on 2020&#x2F;5&#x2F;6 10:48 星期三</span><br><span class="line"> * @Description: com.csw.algorithm.kruskal</span><br><span class="line"> * @version: 1.0 克鲁斯卡尔算法</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class KruskalCase &#123;</span><br><span class="line"></span><br><span class="line">    private int edgeNum; &#x2F;&#x2F;边的个数</span><br><span class="line">    private char[] vertexs;&#x2F;&#x2F;顶点数组</span><br><span class="line">    private int[][] matrix; &#x2F;&#x2F;领接矩阵</span><br><span class="line">    &#x2F;&#x2F;使用INF表示两个顶点不能联通</span><br><span class="line">    private static final int INF &#x3D; Integer.MAX_VALUE;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        char[] vertexs &#x3D; &#123;&#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;, &#39;E&#39;, &#39;F&#39;, &#39;G&#39;&#125;;</span><br><span class="line">        &#x2F;&#x2F;克鲁斯卡尔算法的领接矩阵</span><br><span class="line">        int matrix[][] &#x3D; &#123;</span><br><span class="line">                &#x2F;&#x2F;A B C D E F G</span><br><span class="line">                &#123;0, 12, INF, INF, INF, 16, 14&#125;, &#x2F;&#x2F;A</span><br><span class="line">                &#123;12, 0, 10, INF, INF, 7, INF&#125;,  &#x2F;&#x2F;B</span><br><span class="line">                &#123;INF, 10, 0, 3, 5, 6, INF&#125;,     &#x2F;&#x2F;C</span><br><span class="line">                &#123;INF, INF, 3, 0, 4, INF, INF&#125;,  &#x2F;&#x2F;D</span><br><span class="line">                &#123;INF, INF, 5, 4, 0, 2, 8&#125;,      &#x2F;&#x2F;E</span><br><span class="line">                &#123;16, 7, 6, INF, 2, 0, 9&#125;,       &#x2F;&#x2F;F</span><br><span class="line">                &#123;14, INF, INF, INF, 8, 9, 0&#125;&#125;;  &#x2F;&#x2F;G</span><br><span class="line">        &#x2F;&#x2F;创建KruskalCase,对象实例</span><br><span class="line">        KruskalCase kruskalCase &#x3D; new KruskalCase(vertexs, matrix);</span><br><span class="line">        &#x2F;&#x2F;输出构建</span><br><span class="line">        kruskalCase.println();</span><br><span class="line">        &#x2F;&#x2F;输出边数</span><br><span class="line">        &#x2F;&#x2F;System.out.println(kruskalCase.edgeNum);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;先得到边</span><br><span class="line">        EData[] edges &#x3D; kruskalCase.getEdges();</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;测试 未排序的</span><br><span class="line">        System.out.println(Arrays.toString(edges));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;排序后的结果</span><br><span class="line">&#x2F;&#x2F;        kruskalCase.sortEdges(edges);</span><br><span class="line">&#x2F;&#x2F;        System.out.println(Arrays.toString(edges));</span><br><span class="line">        kruskalCase.kruskal();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 构造器</span><br><span class="line">     *</span><br><span class="line">     * @param vertexs</span><br><span class="line">     * @param matrix</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public KruskalCase(char[] vertexs, int[][] matrix) &#123;</span><br><span class="line">        &#x2F;&#x2F;初始化顶点数和边的个数</span><br><span class="line">        int vlen &#x3D; vertexs.length;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;初始化顶点，复制拷贝的方式</span><br><span class="line">        this.vertexs &#x3D; new char[vlen];</span><br><span class="line">        for (int i &#x3D; 0; i &lt; vertexs.length; i++) &#123;</span><br><span class="line">            this.vertexs[i] &#x3D; vertexs[i];</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;初始化边,使用复制拷贝方式</span><br><span class="line">        this.matrix &#x3D; new int[vlen][vlen];</span><br><span class="line">        for (int i &#x3D; 0; i &lt; vlen; i++) &#123;</span><br><span class="line">            for (int j &#x3D; 0; j &lt; vlen; j++) &#123;</span><br><span class="line">                this.matrix[i][j] &#x3D; matrix[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;统计边的条数</span><br><span class="line">        for (int i &#x3D; 0; i &lt; vlen; i++) &#123;</span><br><span class="line">            for (int j &#x3D; i + 1; j &lt; vlen; j++) &#123;</span><br><span class="line">                if (this.matrix[i][j] !&#x3D; INF) &#123;</span><br><span class="line">                    edgeNum++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void kruskal() &#123;</span><br><span class="line">        int index &#x3D; 0; &#x2F;&#x2F;表示最后结果数组的索引</span><br><span class="line">        int[] ends &#x3D; new int[edgeNum]; &#x2F;&#x2F;用于保存&quot;已有最小生成树&quot;中的每个顶点在最小生成树的终点</span><br><span class="line">        &#x2F;&#x2F;创建结果数组,保存最后的最小生出树</span><br><span class="line">        EData[] rets &#x3D; new EData[edgeNum];</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;获取图中所有边的集合,一共有12条边</span><br><span class="line">        EData[] edges &#x3D; getEdges();</span><br><span class="line">        System.out.println(&quot;图的边的集合&#x3D;&quot; + Arrays.toString(edges) + &quot;共&quot; + edges.length);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;按照边的权值大小进行排序(从小到达)</span><br><span class="line">        sortEdges(edges);</span><br><span class="line">        &#x2F;&#x2F;遍历 edges数组,将边添加到最小生成树中时判断是否形成了回路,如果没有就加入到结果数组中去,否则不能加入</span><br><span class="line">        for (int i &#x3D; 0; i &lt; edgeNum; i++) &#123;</span><br><span class="line">            &#x2F;&#x2F;获取得到第i条边的第一个顶点</span><br><span class="line">            int p1 &#x3D; getPosition(edges[i].start); &#x2F;&#x2F;E的p1是 4</span><br><span class="line">            &#x2F;&#x2F;获取到第i条边的第2个顶点</span><br><span class="line">            int p2 &#x3D; getPosition(edges[i].end); &#x2F;&#x2F; F的p2是5</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F;获取p1这个顶点在已有最小生成树中的终点</span><br><span class="line">            int m &#x3D; getEnd(ends, p1); &#x2F;&#x2F;m&#x3D;4</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F;获取p2这个顶点在已有最小生成树中的终点</span><br><span class="line">            int n &#x3D; getEnd(ends, p2); &#x2F;&#x2F;n&#x3D;5</span><br><span class="line">            if (m !&#x3D; n) &#123;</span><br><span class="line">                &#x2F;&#x2F;没有构成回路</span><br><span class="line">                ends[m] &#x3D; n; &#x2F;&#x2F;设置m在已有最小生成树中的终点&lt;E,F&gt;[0,0,0,0,5,0,0,0,0,0]</span><br><span class="line">                rets[index++] &#x3D; edges[i]; &#x2F;&#x2F;有一条边符合条件加入</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;统计并打印&quot;最小生成树&quot;</span><br><span class="line">        System.out.println(&quot;最小生成树&quot;);</span><br><span class="line">        for (int i &#x3D; 0; i &lt; index; i++) &#123;</span><br><span class="line">            System.out.println(rets[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 打印领接矩阵</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public void println() &#123;</span><br><span class="line">        System.out.println(&quot;领接矩阵为:&quot;);</span><br><span class="line">        for (int i &#x3D; 0; i &lt; vertexs.length; i++) &#123;</span><br><span class="line">            for (int j &#x3D; 0; j &lt; vertexs.length; j++) &#123;</span><br><span class="line">                System.out.printf(&quot;%12d&quot;, matrix[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(&quot;&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 功能:对边进行排序处理,冒泡排序</span><br><span class="line">     * 对边进行排序处理,冒泡排序</span><br><span class="line">     *</span><br><span class="line">     * @param edges 边的集合</span><br><span class="line">     *&#x2F;</span><br><span class="line">    private void sortEdges(EData[] edges) &#123;</span><br><span class="line">        for (int i &#x3D; 0; i &lt; edges.length - 1; i++) &#123;</span><br><span class="line">            for (int j &#x3D; 0; j &lt; edges.length - 1 - i; j++) &#123;</span><br><span class="line">                if (edges[j].weight &gt; edges[j + 1].weight) &#123;</span><br><span class="line">                    EData tmp &#x3D; edges[j];</span><br><span class="line">                    edges[j] &#x3D; edges[j + 1];</span><br><span class="line">                    edges[j + 1] &#x3D; tmp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * @param ch 顶点的值,比如&#39;A&#39;,&#39;B&#39;</span><br><span class="line">     * @return 返回ch顶点对应的下标, 如果找不到, 返回-1</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public int getPosition(char ch) &#123;</span><br><span class="line">        for (int i &#x3D; 0; i &lt; vertexs.length; i++) &#123;</span><br><span class="line">            if (vertexs[i] &#x3D;&#x3D; ch) &#123;</span><br><span class="line">                return i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;找不到</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 获取图中的边,放到EData[]数组中,后面我们需要遍历该数组</span><br><span class="line">     * 通过matrix领接矩阵来获取</span><br><span class="line">     * EData[] 形式[[&#39;A&#39;,&#39;B&#39;,12],[&#39;B&#39;,&#39;F&#39;,7],...]</span><br><span class="line">     *</span><br><span class="line">     * @return</span><br><span class="line">     *&#x2F;</span><br><span class="line">    private EData[] getEdges() &#123;</span><br><span class="line">        int index &#x3D; 0;</span><br><span class="line">        EData[] edges &#x3D; new EData[edgeNum];</span><br><span class="line">        for (int i &#x3D; 0; i &lt; vertexs.length; i++) &#123;</span><br><span class="line">            for (int j &#x3D; i + 1; j &lt; vertexs.length; j++) &#123;</span><br><span class="line">                if (matrix[i][j] !&#x3D; INF) &#123;</span><br><span class="line">                    edges[index++] &#x3D; new EData(vertexs[i], vertexs[j], matrix[i][j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return edges;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 功能:获取下标为i的顶点的终点,用于判断两个顶点的终点是否相同</span><br><span class="line">     *</span><br><span class="line">     * @param ends:数组记录了各个顶点对应的终点是那个，ends数组是在遍历过程中逐步形成的</span><br><span class="line">     * @param i                                         传入的顶点对应的下标</span><br><span class="line">     * @return 返回就是下标为i的这个顶点对应的终点的下标</span><br><span class="line">     *&#x2F;</span><br><span class="line">    private int getEnd(int[] ends, int i) &#123;</span><br><span class="line">        while (ends[i] !&#x3D; 0) &#123; &#x2F;&#x2F;i是5 [0,0,0,0,5,0,0,0,0,0]</span><br><span class="line">            i &#x3D; ends[i];</span><br><span class="line">        &#125;</span><br><span class="line">        return i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * Description: 创建一个类EData，它的对象实列就表示一条边</span><br><span class="line"> *</span><br><span class="line"> * @author Todcsw</span><br><span class="line"> * @date</span><br><span class="line"> *&#x2F;</span><br><span class="line">class EData &#123;</span><br><span class="line">    char start;&#x2F;&#x2F;边的一个点</span><br><span class="line">    char end; &#x2F;&#x2F;边的另外一个点</span><br><span class="line">    int weight; &#x2F;&#x2F;边的权值</span><br><span class="line">    &#x2F;&#x2F;构造器</span><br><span class="line"></span><br><span class="line">    public EData(char start, char end, int weight) &#123;</span><br><span class="line">        this.start &#x3D; start;</span><br><span class="line">        this.end &#x3D; end;</span><br><span class="line">        this.weight &#x3D; weight;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;重写toString，便于输出边</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return &quot;EData[&quot; +</span><br><span class="line">                &quot;&lt;&quot; + start +</span><br><span class="line">                &quot;, &quot; + end +</span><br><span class="line">                &quot;&gt;&#x3D; &quot; + weight +</span><br><span class="line">                &#39;]&#39;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;普里姆算法&quot;&gt;&lt;a href=&quot;#普里姆算法&quot; class=&quot;headerlink&quot; title=&quot;普里姆算法&quot;&gt;&lt;/a&gt;普里姆算法&lt;/h1&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;
      
    
    </summary>
    
    
      <category term="数据结构" scheme="https://todcsw.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="学习" scheme="https://todcsw.github.io/tags/%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="java" scheme="https://todcsw.github.io/tags/java/"/>
    
      <category term="数据结构" scheme="https://todcsw.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>java实现字符串匹配(暴力匹配和kmp算法)</title>
    <link href="https://todcsw.github.io/2020/05/05/dataStructure-java%E5%AE%9E%E7%8E%B0%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D-%E6%9A%B4%E5%8A%9B%E5%8C%B9%E9%85%8D%E5%92%8Ckmp%E7%AE%97%E6%B3%95/"/>
    <id>https://todcsw.github.io/2020/05/05/dataStructure-java%E5%AE%9E%E7%8E%B0%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D-%E6%9A%B4%E5%8A%9B%E5%8C%B9%E9%85%8D%E5%92%8Ckmp%E7%AE%97%E6%B3%95/</id>
    <published>2020-05-05T11:43:55.000Z</published>
    <updated>2020-05-08T08:26:34.620Z</updated>
    
    <content type="html"><![CDATA[<h1 id="暴力匹配"><a href="#暴力匹配" class="headerlink" title="暴力匹配"></a>暴力匹配</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package com.csw.algorithm.kmp;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * @Auther: 行路</span><br><span class="line"> * @Date: Created on 2020&#x2F;5&#x2F;5 16:19 星期二</span><br><span class="line"> * @Description: com.csw.algorithm.kmp</span><br><span class="line"> * @version: 1.0 暴力匹配</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class ViolenceMatch &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        &#x2F;&#x2F;测试暴力匹配算法</span><br><span class="line">        String str1&#x3D;&quot;硅硅谷 尚硅谷你尚硅 尚硅谷你尚硅谷你尚硅你好&quot;;</span><br><span class="line">        String str2&#x3D;&quot;尚硅谷你尚硅你&quot;;</span><br><span class="line">        int index&#x3D;violenceMatch(str1,str2);</span><br><span class="line">        System.out.println(index);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 暴力匹配算法</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public static int violenceMatch(String str1,String str2)&#123;</span><br><span class="line">        char[] s1&#x3D;str1.toCharArray();</span><br><span class="line">        char[] s2&#x3D;str2.toCharArray();</span><br><span class="line">        int s1Len&#x3D;s1.length;</span><br><span class="line">        int s2Len&#x3D;s2.length;</span><br><span class="line">        &#x2F;&#x2F; i索引,j索引</span><br><span class="line">        int i&#x3D;0;</span><br><span class="line">        int j&#x3D;0;</span><br><span class="line">        while (i&lt;s1Len&amp;&amp;j&lt;s2Len)&#123;</span><br><span class="line">            &#x2F;&#x2F;保证匹配时,不越界</span><br><span class="line">            if(s1[i]&#x3D;&#x3D;s2[j])&#123;</span><br><span class="line">                i++;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                &#x2F;&#x2F;没有匹配成功</span><br><span class="line">                i&#x3D;i-(j-1);</span><br><span class="line">                j&#x3D;0;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;判断是否匹配成功</span><br><span class="line">        if(j&#x3D;&#x3D;s2Len)&#123;</span><br><span class="line">            return i-j;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            return -1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="kmp算法"><a href="#kmp算法" class="headerlink" title="kmp算法"></a>kmp算法</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package com.csw.algorithm.kmp;</span><br><span class="line"></span><br><span class="line">import java.util.Arrays;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * @Auther: 行路</span><br><span class="line"> * @Date: Created on 2020&#x2F;5&#x2F;5 16:51 星期二</span><br><span class="line"> * @Description: com.csw.algorithm.kmp</span><br><span class="line"> * @version: 1.0  kmp算法</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class KMPAlgorithm &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        String str1 &#x3D; &quot;BBC ABCDAB ABCDABCDABDE&quot;;</span><br><span class="line">        String str2 &#x3D; &quot;ABCDABD&quot;;</span><br><span class="line">        int[] next&#x3D;KmpNext(&quot;ABCDABD&quot;);</span><br><span class="line">        System.out.println(Arrays.toString(next));</span><br><span class="line">        int index&#x3D;kmpSearch(str1,str2,next);</span><br><span class="line">        System.out.println(&quot;index&#x3D;&quot;+index);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * kmp搜索算法</span><br><span class="line">     * @param str1 源字符串</span><br><span class="line">     * @param str2 字串</span><br><span class="line">     * @param next 部分匹配表,是字串对应的部分匹配表</span><br><span class="line">     * @return -1是没有匹配到,否则返回第一个匹配的位置</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public static int kmpSearch(String str1,String str2,int[] next)&#123;</span><br><span class="line">        &#x2F;&#x2F;遍历</span><br><span class="line">        for(int i&#x3D;0,j&#x3D;0;i&lt;str1.length();i++)&#123;</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F;需要处理str1.charAt(i)!&#x3D;str2.charAt(j),去调整j的大小</span><br><span class="line">            &#x2F;&#x2F;Kmp算法核心</span><br><span class="line"></span><br><span class="line">            while (j&gt;0&amp;&amp;str1.charAt(i)!&#x3D;str2.charAt(j))&#123;</span><br><span class="line">                j&#x3D;next[j-1];</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if(str1.charAt(i)&#x3D;&#x3D;str2.charAt(j))&#123;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            if(j&#x3D;&#x3D;str2.length())&#123;</span><br><span class="line">                return i-j+1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;获取到一个字符串(字串)的部分匹配值</span><br><span class="line">    public static int[] KmpNext(String dest) &#123;</span><br><span class="line">        &#x2F;&#x2F;创建一个next保存部分匹配值</span><br><span class="line">        int[] next &#x3D; new int[dest.length()];</span><br><span class="line">        next[0] &#x3D; 0; &#x2F;&#x2F;如果字符串长度为1部分匹配值就是0</span><br><span class="line">        for (int i &#x3D; 1, j &#x3D; 0; i &lt; dest.length(); i++) &#123;</span><br><span class="line">            &#x2F;&#x2F;当dest.charAt(i)!&#x3D;dest.charAt(j)时,我们需要next[j-1]获取新的j</span><br><span class="line">            &#x2F;&#x2F;知道我们发现有这个dest.charAt(i)&#x3D;&#x3D;dest.charAt(j)满足时,才退出</span><br><span class="line">            while (j&gt;0&amp;&amp;dest.charAt(i)!&#x3D;dest.charAt(j))&#123;</span><br><span class="line">                j&#x3D;next[j-1];</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F;当dest.charAt(i)&#x3D;&#x3D;dest.charAt(j)满足时,部分匹配值就+1</span><br><span class="line">            if (dest.charAt(i) &#x3D;&#x3D; dest.charAt(j)) &#123;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            next[i] &#x3D; j;</span><br><span class="line">        &#125;</span><br><span class="line">        return next;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;暴力匹配&quot;&gt;&lt;a href=&quot;#暴力匹配&quot; class=&quot;headerlink&quot; title=&quot;暴力匹配&quot;&gt;&lt;/a&gt;暴力匹配&lt;/h1&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;
      
    
    </summary>
    
    
      <category term="数据结构" scheme="https://todcsw.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="学习" scheme="https://todcsw.github.io/tags/%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="java" scheme="https://todcsw.github.io/tags/java/"/>
    
      <category term="数据结构" scheme="https://todcsw.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>java实现01背包问题(动态规划)和集合覆盖问题(贪心算法)</title>
    <link href="https://todcsw.github.io/2020/05/04/dataStructure-java%E5%AE%9E%E7%8E%B001%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E5%92%8C%E9%9B%86%E5%90%88%E8%A6%86%E7%9B%96%E9%97%AE%E9%A2%98-%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/"/>
    <id>https://todcsw.github.io/2020/05/04/dataStructure-java%E5%AE%9E%E7%8E%B001%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E5%92%8C%E9%9B%86%E5%90%88%E8%A6%86%E7%9B%96%E9%97%AE%E9%A2%98-%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/</id>
    <published>2020-05-04T14:59:03.000Z</published>
    <updated>2020-05-08T08:29:00.792Z</updated>
    
    <content type="html"><![CDATA[<h1 id="01背包问题-动态规划"><a href="#01背包问题-动态规划" class="headerlink" title="01背包问题(动态规划)"></a>01背包问题(动态规划)</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package com.csw.algorithm.dynamic;</span><br><span class="line"></span><br><span class="line">import java.util.Arrays;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * @Auther: 行路</span><br><span class="line"> * @Date: Created on 2020&#x2F;5&#x2F;3 15:35 星期天</span><br><span class="line"> * @Description: com.csw.algorithm.dynamic</span><br><span class="line"> * @version: 1.0</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class KnapsackProblem &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int[] w &#x3D; &#123;1, 4, 3&#125;; &#x2F;&#x2F;物品的重量</span><br><span class="line">        int[] val &#x3D; &#123;1500, 3000, 2000&#125;; &#x2F;&#x2F;物品的价值</span><br><span class="line">        int m &#x3D; 4; &#x2F;&#x2F;背包的容量</span><br><span class="line">        int n &#x3D; val.length; &#x2F;&#x2F;物品的个数</span><br><span class="line">        &#x2F;&#x2F;创建二位数组</span><br><span class="line">        &#x2F;&#x2F;v[i][j]表示在前i个物品中能够装入容量为j的背包最大价值</span><br><span class="line">        int[][] v &#x3D; new int[n + 1][m + 1];</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;为了记录放入商品的情况,我们定义一个二维数组</span><br><span class="line">        int[][] path &#x3D; new int[n + 1][m + 1];</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;初始化第一行和第一列,在本程序中默认就是0</span><br><span class="line">        for (int i &#x3D; 0; i &lt; v.length; i++) &#123;</span><br><span class="line">            v[i][0] &#x3D; 0; &#x2F;&#x2F;将第一列设置为0</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i &#x3D; 0; i &lt; v[0].length; i++) &#123;</span><br><span class="line">            v[0][i] &#x3D; 0; &#x2F;&#x2F;将第一行设置为0</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;根据公式进行动态规划</span><br><span class="line">        for (int i &#x3D; 1; i &lt; v.length; i++) &#123;</span><br><span class="line">            &#x2F;&#x2F;不处理第一行</span><br><span class="line">            for (int j &#x3D; 1; j &lt; v[0].length; j++) &#123;</span><br><span class="line">                &#x2F;&#x2F;不处理第一列</span><br><span class="line">                if (w[i - 1] &gt; j) &#123; &#x2F;&#x2F;因为程序从1开始</span><br><span class="line">                    v[i][j] &#x3D; v[i - 1][j];</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    &#x2F;&#x2F;因为i是从1开始的,所以公式需要调整</span><br><span class="line">                    &#x2F;&#x2F;v[i][j]&#x3D;Math.max(v[i-1][j],val[i-1]+v[i-1][j-w[i-1]]);</span><br><span class="line">                    &#x2F;&#x2F;为了记录商品存放到背包的情况,我们不能直接使用上面的公式,需要使用if-else来体现公式</span><br><span class="line">                    if (v[i - 1][j] &lt; val[i - 1] + v[i - 1][j - w[i - 1]]) &#123;</span><br><span class="line">                        v[i][j] &#x3D; val[i - 1] + v[i - 1][j - w[i - 1]];</span><br><span class="line">                        &#x2F;&#x2F;把当前的情况记录到path</span><br><span class="line">                        path[i][j] &#x3D; 1;</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        v[i][j] &#x3D; v[i - 1][j];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;输出一下v</span><br><span class="line">&#x2F;&#x2F;        for (int i &#x3D; 0; i &lt; v.length; i++) &#123;</span><br><span class="line">&#x2F;&#x2F;            for (int j &#x3D; 0; j &lt; v[i].length; j++) &#123;</span><br><span class="line">&#x2F;&#x2F;                System.out.print(v[i][j] + &quot; &quot;);</span><br><span class="line">&#x2F;&#x2F;            &#125;</span><br><span class="line">&#x2F;&#x2F;            System.out.println(&quot;&quot;);</span><br><span class="line">&#x2F;&#x2F;        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;输出一下v</span><br><span class="line">        &#x2F;&#x2F;这样输出不对</span><br><span class="line">&#x2F;&#x2F;        for (int i &#x3D; 0; i &lt; v.length; i++) &#123;</span><br><span class="line">&#x2F;&#x2F;            for (int j &#x3D; 0; j &lt; v[i].length; j++) &#123;</span><br><span class="line">&#x2F;&#x2F;                &#x2F;&#x2F; System.out.print(path[i][j]+&quot; &quot;);</span><br><span class="line">&#x2F;&#x2F;                if (path[i][j] &#x3D;&#x3D; 1) &#123;</span><br><span class="line">&#x2F;&#x2F;                    System.out.printf(&quot;第%d个商品放入到背包\n&quot;, i);</span><br><span class="line">&#x2F;&#x2F;                &#125;</span><br><span class="line">&#x2F;&#x2F;            &#125;</span><br><span class="line">&#x2F;&#x2F;        &#125;</span><br><span class="line"></span><br><span class="line">        for(int[] a:v)&#123;</span><br><span class="line">            System.out.println(Arrays.toString(a));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        for(int[] a:path)&#123;</span><br><span class="line">            System.out.println(Arrays.toString(a));</span><br><span class="line">        &#125;</span><br><span class="line">        int i&#x3D;path.length-1;</span><br><span class="line">        int j&#x3D;path[0].length-1;</span><br><span class="line">        while (i&gt;0&amp;&amp;j&gt;0)&#123;</span><br><span class="line">            if(path[i][j]&#x3D;&#x3D;1)&#123;</span><br><span class="line">                System.out.printf(&quot;第%d个商品放入到背包\n&quot;,i);</span><br><span class="line">                j-&#x3D;w[i-1];</span><br><span class="line">            &#125;</span><br><span class="line">            i--;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="集合覆盖问题-贪心算法"><a href="#集合覆盖问题-贪心算法" class="headerlink" title="集合覆盖问题(贪心算法)"></a>集合覆盖问题(贪心算法)</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package com.csw.algorithm.greedy;</span><br><span class="line"></span><br><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.HashMap;</span><br><span class="line">import java.util.HashSet;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * @Auther: 行路</span><br><span class="line"> * @Date: Created on 2020&#x2F;5&#x2F;4 21:23 星期一</span><br><span class="line"> * @Description: com.csw.algorithm.greedy</span><br><span class="line"> * @version: 1.0 贪心算法</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class GreedyAlgorithm &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        &#x2F;&#x2F;创建广播电台,放入到Map</span><br><span class="line">        HashMap&lt;String, HashSet&lt;String&gt;&gt; broadcasts &#x3D; new HashMap&lt;&gt;();</span><br><span class="line">        &#x2F;&#x2F;将各个电台放入到broadcasts</span><br><span class="line">        HashSet&lt;String&gt; hashSet1&#x3D;new HashSet&lt;&gt;();</span><br><span class="line">        hashSet1.add(&quot;北京&quot;);</span><br><span class="line">        hashSet1.add(&quot;上海&quot;);</span><br><span class="line">        hashSet1.add(&quot;天津&quot;);</span><br><span class="line"></span><br><span class="line">        HashSet&lt;String&gt; hashSet2&#x3D;new HashSet&lt;&gt;();</span><br><span class="line">        hashSet2.add(&quot;广州&quot;);</span><br><span class="line">        hashSet2.add(&quot;北京&quot;);</span><br><span class="line">        hashSet2.add(&quot;深圳&quot;);</span><br><span class="line"></span><br><span class="line">        HashSet&lt;String&gt; hashSet3&#x3D;new HashSet&lt;&gt;();</span><br><span class="line">        hashSet3.add(&quot;成都&quot;);</span><br><span class="line">        hashSet3.add(&quot;上海&quot;);</span><br><span class="line">        hashSet3.add(&quot;杭州&quot;);</span><br><span class="line"></span><br><span class="line">        HashSet&lt;String&gt; hashSet4&#x3D;new HashSet&lt;&gt;();</span><br><span class="line">        hashSet4.add(&quot;上海&quot;);</span><br><span class="line">        hashSet4.add(&quot;天津&quot;);</span><br><span class="line"></span><br><span class="line">        HashSet&lt;String&gt; hashSet5&#x3D;new HashSet&lt;&gt;();</span><br><span class="line">        hashSet5.add(&quot;杭州&quot;);</span><br><span class="line">        hashSet5.add(&quot;大连&quot;);</span><br><span class="line"></span><br><span class="line">        broadcasts.put(&quot;k1&quot;,hashSet1);</span><br><span class="line">        broadcasts.put(&quot;k2&quot;,hashSet2);</span><br><span class="line">        broadcasts.put(&quot;k3&quot;,hashSet3);</span><br><span class="line">        broadcasts.put(&quot;k4&quot;,hashSet4);</span><br><span class="line">        broadcasts.put(&quot;k5&quot;,hashSet5);</span><br><span class="line"></span><br><span class="line">        HashSet&lt;String&gt; allAreas &#x3D; new HashSet&lt;&gt;();</span><br><span class="line">        allAreas.add(&quot;北京&quot;);</span><br><span class="line">        allAreas.add(&quot;上海&quot;);</span><br><span class="line">        allAreas.add(&quot;天津&quot;);</span><br><span class="line">        allAreas.add(&quot;广州&quot;);</span><br><span class="line">        allAreas.add(&quot;深圳&quot;);</span><br><span class="line">        allAreas.add(&quot;成都&quot;);</span><br><span class="line">        allAreas.add(&quot;杭州&quot;);</span><br><span class="line">        allAreas.add(&quot;大连&quot;);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;创建一个ArrayList,存放电台集合</span><br><span class="line">        ArrayList&lt;String&gt; selects &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;定义一个临时集合,在遍历过程中,存放遍历过程中的电台覆盖的地区和当前还没有覆盖的地区的交集</span><br><span class="line">        HashSet&lt;String&gt; tempSet &#x3D; new HashSet&lt;String&gt;();</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;定义一个maxKey,保存在一次遍历过程中,能够覆盖最大未覆盖的地区对应的电台的Key</span><br><span class="line">        &#x2F;&#x2F;如果maxKey 不为null,则会加入到selects</span><br><span class="line">        String maxKey&#x3D;null;</span><br><span class="line">        while (allAreas.size()!&#x3D;0)&#123;</span><br><span class="line">            &#x2F;&#x2F;没进行一次while,需要</span><br><span class="line">            maxKey&#x3D;null;</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F;如果allAreas不为0说明还没有覆盖所有地区</span><br><span class="line">            &#x2F;&#x2F;遍历 broadcasts,取出对应的key</span><br><span class="line">            for(String key:broadcasts.keySet())&#123;</span><br><span class="line">                &#x2F;&#x2F;没进行一次for</span><br><span class="line">                tempSet.clear();</span><br><span class="line">                &#x2F;&#x2F;当前这个Key能覆盖的地区</span><br><span class="line">                HashSet&lt;String&gt; areas &#x3D; broadcasts.get(key);</span><br><span class="line">                tempSet.addAll(areas);</span><br><span class="line">                &#x2F;&#x2F;求出tempSet和allAreas集合的交集,交集会赋给tempSet</span><br><span class="line">                tempSet.retainAll(allAreas);</span><br><span class="line">                &#x2F;&#x2F;如果当前集合包含未覆盖地区的数量比maxKey指向的集合未覆盖的地区还多</span><br><span class="line">                if(tempSet.size()&gt;0&amp;&amp;(maxKey&#x3D;&#x3D;null||tempSet.size()&gt;broadcasts.get(maxKey).size()))&#123;</span><br><span class="line">                    maxKey&#x3D;key;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F;maxKey!&#x3D;null,就应该将maxKey加入selects中</span><br><span class="line">            if(maxKey!&#x3D;null)&#123;</span><br><span class="line">                selects.add(maxKey);</span><br><span class="line">                &#x2F;&#x2F;将maxKey指向的广播电台覆盖的地区,从allAreas去掉</span><br><span class="line">                allAreas.removeAll(broadcasts.get(maxKey));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot;得到的选择结果集合&quot;+selects);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;01背包问题-动态规划&quot;&gt;&lt;a href=&quot;#01背包问题-动态规划&quot; class=&quot;headerlink&quot; title=&quot;01背包问题(动态规划)&quot;&gt;&lt;/a&gt;01背包问题(动态规划)&lt;/h1&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;ta
      
    
    </summary>
    
    
      <category term="数据结构" scheme="https://todcsw.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="学习" scheme="https://todcsw.github.io/tags/%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="java" scheme="https://todcsw.github.io/tags/java/"/>
    
      <category term="数据结构" scheme="https://todcsw.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>java实现二分查找非递归算法和汉诺塔算法</title>
    <link href="https://todcsw.github.io/2020/05/03/dataStructure-java%E5%AE%9E%E7%8E%B0%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E9%9D%9E%E9%80%92%E5%BD%92%E7%AE%97%E6%B3%95%E5%92%8C%E6%B1%89%E8%AF%BA%E5%A1%94%E7%AE%97%E6%B3%95/"/>
    <id>https://todcsw.github.io/2020/05/03/dataStructure-java%E5%AE%9E%E7%8E%B0%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E9%9D%9E%E9%80%92%E5%BD%92%E7%AE%97%E6%B3%95%E5%92%8C%E6%B1%89%E8%AF%BA%E5%A1%94%E7%AE%97%E6%B3%95/</id>
    <published>2020-05-03T02:12:33.000Z</published>
    <updated>2020-05-08T08:25:01.182Z</updated>
    
    <content type="html"><![CDATA[<h1 id="二分查找非递归算法"><a href="#二分查找非递归算法" class="headerlink" title="二分查找非递归算法"></a>二分查找非递归算法</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package com.csw.algorithm.binarysearchnorecursion;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * @Auther: 行路</span><br><span class="line"> * @Date: Created on 2020&#x2F;5&#x2F;2 13:36 星期六</span><br><span class="line"> * @Description: com.csw.algorithm.binarysearchnorecursion</span><br><span class="line"> * @version: 1.0 二分查找非递归算法</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class BinarySearch &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int[] arr&#x3D;&#123;1,3,8,10,11,67,100&#125;;</span><br><span class="line">        int i &#x3D; binarySearch(arr,11);</span><br><span class="line">        System.out.println(&quot;下标为:&quot;+i);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 二分查找的非递归实现</span><br><span class="line">     * @param arr 待查找的数组 升序排列</span><br><span class="line">     * @param target 需要查找的数</span><br><span class="line">     * @return 返回对应的下标，-1表示没有找到</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public static int binarySearch(int[] arr,int target)&#123;</span><br><span class="line">        int left&#x3D;0;</span><br><span class="line">        int right&#x3D;arr.length-1;</span><br><span class="line">        while (left&lt;&#x3D;right)&#123;</span><br><span class="line">            &#x2F;&#x2F;说明继续查找</span><br><span class="line">            int mid&#x3D;(left+right)&#x2F;2;</span><br><span class="line">            if(arr[mid]&#x3D;&#x3D;target)&#123;</span><br><span class="line">                return mid;</span><br><span class="line">            &#125;else if(arr[mid]&gt;target)&#123;</span><br><span class="line">                right&#x3D;mid-1;</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                left&#x3D;mid+1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="汉诺塔算法"><a href="#汉诺塔算法" class="headerlink" title="汉诺塔算法"></a>汉诺塔算法</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package com.csw.algorithm.dac;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * @Auther: 行路</span><br><span class="line"> * @Date: Created on 2020&#x2F;5&#x2F;3 13:53 星期天</span><br><span class="line"> * @Description: com.csw.algorithm.dac 分治算法(汉诺塔)</span><br><span class="line"> * @version: 1.0</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class HanoiTower &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        hanoiTower(64,&#39;A&#39;,&#39;B&#39;,&#39;C&#39;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;汉诺塔的移动方法</span><br><span class="line">    &#x2F;&#x2F;使用分治算法</span><br><span class="line">    public static void hanoiTower(int num,char a,char b,char c)&#123;</span><br><span class="line">        &#x2F;&#x2F;如果只有一个盘</span><br><span class="line">        if(num&#x3D;&#x3D;1)&#123;</span><br><span class="line">            System.out.println(&quot;第1个盘从&quot;+a+&quot;-&gt;&quot;+c);</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">             &#x2F;&#x2F;如果我们只有n&gt;&#x3D;2 情况,我们总是可以看作是两个盘1，最下边的一个盘2,上面的所有盘</span><br><span class="line">            &#x2F;&#x2F;1.先把最上面的所有盘A-B,移动过程会使用到c</span><br><span class="line">            hanoiTower(num-1,a,c,b);</span><br><span class="line">            &#x2F;&#x2F;2.把下面的盘a-c</span><br><span class="line">            System.out.println(&quot;第&quot;+num+&quot;个盘从&quot;+a+&quot;-&gt;&quot;+c);</span><br><span class="line">            &#x2F;&#x2F;3.把B塔所有盘从B-C,移动过程中使用a塔</span><br><span class="line">            hanoiTower(num-1,b,a,c);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;二分查找非递归算法&quot;&gt;&lt;a href=&quot;#二分查找非递归算法&quot; class=&quot;headerlink&quot; title=&quot;二分查找非递归算法&quot;&gt;&lt;/a&gt;二分查找非递归算法&lt;/h1&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;t
      
    
    </summary>
    
    
      <category term="数据结构" scheme="https://todcsw.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="学习" scheme="https://todcsw.github.io/tags/%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="java" scheme="https://todcsw.github.io/tags/java/"/>
    
      <category term="数据结构" scheme="https://todcsw.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>java实现图的深度和广度优先遍历</title>
    <link href="https://todcsw.github.io/2020/05/02/dataStructure-java%E5%AE%9E%E7%8E%B0%E5%9B%BE%E7%9A%84%E6%B7%B1%E5%BA%A6%E5%92%8C%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86/"/>
    <id>https://todcsw.github.io/2020/05/02/dataStructure-java%E5%AE%9E%E7%8E%B0%E5%9B%BE%E7%9A%84%E6%B7%B1%E5%BA%A6%E5%92%8C%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86/</id>
    <published>2020-05-02T05:22:43.000Z</published>
    <updated>2020-05-08T08:26:13.791Z</updated>
    
    <content type="html"><![CDATA[<h1 id="java实现图的深度和广度优先遍历"><a href="#java实现图的深度和广度优先遍历" class="headerlink" title="java实现图的深度和广度优先遍历"></a>java实现图的深度和广度优先遍历</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package com.csw.graph;</span><br><span class="line"></span><br><span class="line">import java.awt.font.NumericShaper;</span><br><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.Arrays;</span><br><span class="line">import java.util.LinkedList;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * a</span><br><span class="line"> *</span><br><span class="line"> * @Auther: 行路</span><br><span class="line"> * @Date: Created on 2020&#x2F;5&#x2F;2 12:03 星期六</span><br><span class="line"> * @Description: com.csw.graph 无向图(图的深度优先遍历)</span><br><span class="line"> * @version: 1.0</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class Graph &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;*存储顶点集合</span><br><span class="line">     *&#x2F;</span><br><span class="line">    private ArrayList&lt;String&gt; vertexList;</span><br><span class="line">    &#x2F;&#x2F;存储图对应的领接矩阵</span><br><span class="line">    private int[][] edges;</span><br><span class="line">    &#x2F;&#x2F;表示边的数目</span><br><span class="line">    private int numOfEdges;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;定义一个数组boolean[],记录某个结点是否被访问过</span><br><span class="line">    private boolean[] isVisited;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;测试一把</span><br><span class="line">        &#x2F;&#x2F;结点的个数</span><br><span class="line">        int n &#x3D; 5;</span><br><span class="line">        String[] Vertex &#x3D; &#123;&quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;, &quot;E&quot;&#125;;</span><br><span class="line">        &#x2F;&#x2F;创建图对象</span><br><span class="line">        Graph graph &#x3D; new Graph(n);</span><br><span class="line">        &#x2F;&#x2F;循环添加结点</span><br><span class="line">        for (String vertex : Vertex) &#123;</span><br><span class="line">            graph.insertVertex(vertex);</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;添加边</span><br><span class="line">        &#x2F;&#x2F;A-B,A-C,b-C, b-D,b-e</span><br><span class="line">        graph.insertEdge(0, 1, 1);</span><br><span class="line">        graph.insertEdge(0, 2, 1);</span><br><span class="line">        graph.insertEdge(1, 2, 1);</span><br><span class="line">        graph.insertEdge(1, 3, 1);</span><br><span class="line">        graph.insertEdge(1, 4, 1);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;显示</span><br><span class="line">        graph.showGraph();</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;测试dfs</span><br><span class="line">        System.out.println(&quot;深度遍历&quot;);</span><br><span class="line">        graph.dfs();</span><br><span class="line">        System.out.println(&quot;&quot;);</span><br><span class="line">        System.out.println(&quot;广度优先遍历&quot;);</span><br><span class="line">        graph.bfs();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;构造器</span><br><span class="line">    public Graph(int n) &#123;</span><br><span class="line">        &#x2F;&#x2F;初始化矩阵和vertexList</span><br><span class="line">        edges &#x3D; new int[n][n];</span><br><span class="line">        vertexList &#x3D; new ArrayList&lt;String&gt;(n);</span><br><span class="line">        numOfEdges &#x3D; 0;</span><br><span class="line">      &#x2F;&#x2F;  isVisited &#x3D; new boolean[n];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 得到第一个领接结点的下标 w</span><br><span class="line">     *</span><br><span class="line">     * @param index</span><br><span class="line">     * @return 如果存在就返回对应的下标, 否则返回对应-1</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public int getFirstNeighbor(int index) &#123;</span><br><span class="line">        for (int j &#x3D; 0; j &lt; vertexList.size(); j++) &#123;</span><br><span class="line">            if (edges[index][j] &gt; 0) &#123;</span><br><span class="line">                return j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;返回前一个领接结点的下标来获取下一个领接结点</span><br><span class="line">    public int getNextNeighbor(int v1, int v2) &#123;</span><br><span class="line">        for (int j &#x3D; v2 + 1; j &lt; vertexList.size(); j++) &#123;</span><br><span class="line">            if (edges[v1][j] &gt; 0) &#123;</span><br><span class="line">                return j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 深度优先遍历算法</span><br><span class="line">     *</span><br><span class="line">     * @param isVisited</span><br><span class="line">     * @param i         第一次就是0</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public void dfs(boolean[] isVisited, int i) &#123;</span><br><span class="line">        &#x2F;&#x2F;首先访问该结点输出</span><br><span class="line">        System.out.print(getValueByIndex(i) + &quot;-&gt;&quot;);</span><br><span class="line">        &#x2F;&#x2F;将结点设置为已经访问过</span><br><span class="line">        isVisited[i] &#x3D; true;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;查找该结点v的第一个领接结点</span><br><span class="line">        int w &#x3D; getFirstNeighbor(i);</span><br><span class="line">        while (w !&#x3D; -1) &#123;</span><br><span class="line">            if (!isVisited[w]) &#123;</span><br><span class="line">                dfs(isVisited, w);</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F;如果w结点已经被访问过</span><br><span class="line">            w &#x3D; getNextNeighbor(i, w);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;对dfs进行一个重载,遍历我们所有的结点,并进行dfs</span><br><span class="line"></span><br><span class="line">    public void dfs() &#123;</span><br><span class="line">        isVisited&#x3D;new boolean[vertexList.size()];</span><br><span class="line">        &#x2F;&#x2F;遍历所有的结点进行dfs[回溯]</span><br><span class="line">        for (int i &#x3D; 0; i &lt; getNumOfVertex(); i++) &#123;</span><br><span class="line">            if (!isVisited[i]) &#123;</span><br><span class="line">                dfs(isVisited, i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 对一个结点广度优先遍历的方法</span><br><span class="line">     *&#x2F;</span><br><span class="line">    private void bfs(boolean[] isVisited, int i) &#123;</span><br><span class="line">        int u;&#x2F;&#x2F;表示队列的头结点</span><br><span class="line">        int w; &#x2F;&#x2F;领接结点w</span><br><span class="line">        &#x2F;&#x2F;队列,记录结点访问的顺序</span><br><span class="line">        LinkedList queue &#x3D; new LinkedList();</span><br><span class="line">        &#x2F;&#x2F;访问结点,输出结点信息</span><br><span class="line">        System.out.print(getValueByIndex(i) + &quot;&#x3D;&gt;&quot;);</span><br><span class="line">        &#x2F;&#x2F;标记以被访问</span><br><span class="line">        isVisited[i] &#x3D; true;</span><br><span class="line">        &#x2F;&#x2F;将结点加入队列</span><br><span class="line">        queue.addLast(i);</span><br><span class="line">        while (!queue.isEmpty()) &#123;</span><br><span class="line">            &#x2F;&#x2F;取出队列的头结点下标</span><br><span class="line">            u &#x3D; (Integer) queue.removeFirst();</span><br><span class="line">            &#x2F;&#x2F;得到第一个领接点的小标w</span><br><span class="line">            w &#x3D; getFirstNeighbor(u);</span><br><span class="line">            while (w !&#x3D; -1) &#123;</span><br><span class="line">                &#x2F;&#x2F;是否访问过</span><br><span class="line">                if (!isVisited[w]) &#123;</span><br><span class="line">                    System.out.print(getValueByIndex(w) + &quot;&#x3D;&gt;&quot;);</span><br><span class="line">                    &#x2F;&#x2F;标记已经访问</span><br><span class="line">                    isVisited[w] &#x3D; true;</span><br><span class="line">                    &#x2F;&#x2F;入队</span><br><span class="line">                    queue.addLast(w);</span><br><span class="line">                &#125;</span><br><span class="line">                &#x2F;&#x2F;以u为前驱点,找w后面的下一个领结点</span><br><span class="line">                w &#x3D; getNextNeighbor(u, w); &#x2F;&#x2F;体现出广度优先</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 遍历所有的节点,都进行广度优先搜索</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public void bfs() &#123;</span><br><span class="line">        isVisited&#x3D;new boolean[vertexList.size()];</span><br><span class="line">        for (int i &#x3D; 0; i &lt; getNumOfVertex(); i++) &#123;</span><br><span class="line">            if (!isVisited[i]) &#123;</span><br><span class="line">                bfs(isVisited, i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;图中常用方法</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * @return 返回结点个数</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public int getNumOfVertex() &#123;</span><br><span class="line">        return vertexList.size();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 得到边的数目</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public int getNumOfEdges() &#123;</span><br><span class="line">        return numOfEdges;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;返回结点i(下标)对应的数据0-&gt;&quot;A&quot; 1 &quot;B&quot; 2-&gt;&quot;C&quot;</span><br><span class="line">    public String getValueByIndex(int i) &#123;</span><br><span class="line">        return vertexList.get(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;返回v1和v2的权值</span><br><span class="line">    public int getWeight(int v1, int v2) &#123;</span><br><span class="line">        return edges[v1][v2];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;显示图对应的矩阵</span><br><span class="line">    public void showGraph() &#123;</span><br><span class="line">        for (int[] link : edges) &#123;</span><br><span class="line">            System.out.println(Arrays.toString(link));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;插入结点</span><br><span class="line">    public void insertVertex(String vertex) &#123;</span><br><span class="line">        vertexList.add(vertex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 添加边</span><br><span class="line">     *</span><br><span class="line">     * @param v1     表示点的下标即使第几个顶点 &quot;A&quot;-&quot;B&quot;-&quot;C&quot;-&quot;D&quot;-&quot;E&quot;</span><br><span class="line">     * @param v2     表示第二个顶点对应的下标</span><br><span class="line">     * @param weight 表示</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public void insertEdge(int v1, int v2, int weight) &#123;</span><br><span class="line">        edges[v1][v2] &#x3D; weight;</span><br><span class="line">        edges[v2][v1] &#x3D; weight;</span><br><span class="line">        numOfEdges++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;java实现图的深度和广度优先遍历&quot;&gt;&lt;a href=&quot;#java实现图的深度和广度优先遍历&quot; class=&quot;headerlink&quot; title=&quot;java实现图的深度和广度优先遍历&quot;&gt;&lt;/a&gt;java实现图的深度和广度优先遍历&lt;/h1&gt;&lt;figure class
      
    
    </summary>
    
    
      <category term="数据结构" scheme="https://todcsw.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="学习" scheme="https://todcsw.github.io/tags/%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="java" scheme="https://todcsw.github.io/tags/java/"/>
    
      <category term="数据结构" scheme="https://todcsw.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>java实现平衡二叉树(avl树)</title>
    <link href="https://todcsw.github.io/2020/05/01/dataStructure-java%E5%AE%9E%E7%8E%B0%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91-avl%E6%A0%91/"/>
    <id>https://todcsw.github.io/2020/05/01/dataStructure-java%E5%AE%9E%E7%8E%B0%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91-avl%E6%A0%91/</id>
    <published>2020-05-01T08:16:46.000Z</published>
    <updated>2020-05-08T08:26:44.478Z</updated>
    
    <content type="html"><![CDATA[<h1 id="java实现平衡二叉树-avl树"><a href="#java实现平衡二叉树-avl树" class="headerlink" title="java实现平衡二叉树(avl树)"></a>java实现平衡二叉树(avl树)</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package com.csw.tree;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * @Auther: 行路</span><br><span class="line"> * @Date: Created on 2020&#x2F;5&#x2F;1 14:12 星期五</span><br><span class="line"> * @Description: com.csw.tree 平衡二叉树</span><br><span class="line"> * @version: 1.0</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class AVLTreeDemo &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">&#x2F;&#x2F;        int[] arr &#x3D; &#123;10, 12, 8, 9, 7, 6&#125;;</span><br><span class="line"></span><br><span class="line">        int[] arr &#x3D; &#123;10, 11, 7, 6, 8, 9&#125;;</span><br><span class="line">        AVLTree avlTree &#x3D; new AVLTree();</span><br><span class="line">        &#x2F;&#x2F;添加节点</span><br><span class="line">        for (int i &#x3D; 0; i &lt; arr.length; i++) &#123;</span><br><span class="line">            avlTree.add(new Node1(arr[i]));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;中序遍历</span><br><span class="line">        avlTree.infixOrder();</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;没有平衡之前&quot;);</span><br><span class="line">        System.out.println(&quot;树的高度&#x3D;&quot; + avlTree.getRoot().height());</span><br><span class="line">        System.out.println(&quot;树的右子树高度&#x3D;&quot; + avlTree.getRoot().leftHeight());</span><br><span class="line">        System.out.println(&quot;书的右子树的高度&#x3D;&quot; + avlTree.getRoot().rightHeight());</span><br><span class="line">        System.out.println(&quot;当前根结点&quot; + avlTree.getRoot());</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;根结点的左子结点&quot;+avlTree.getRoot().right.left);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;创建AVL树</span><br><span class="line">class AVLTree &#123;</span><br><span class="line">    private Node1 root;</span><br><span class="line"></span><br><span class="line">    public Node1 getRoot() &#123;</span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setRoot(Node1 root) &#123;</span><br><span class="line">        this.root &#x3D; root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;查找要删除的结点</span><br><span class="line">    public Node1 search(int value) &#123;</span><br><span class="line">        if (root &#x3D;&#x3D; null) &#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return root.search(value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;查找父结点</span><br><span class="line">    public Node1 searchParent(int value) &#123;</span><br><span class="line">        if (root &#x3D;&#x3D; null) &#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return root.searchParent(value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 方法:返回以Node1为根结点的二叉排序树的最小结点的值</span><br><span class="line">     * 2.删除Node1,为根结点的二叉排序树的最小结点</span><br><span class="line">     *</span><br><span class="line">     * @param Node1 传入的结点,当作一个二叉排序树的根结点</span><br><span class="line">     * @return 返回的以Node1为根结点的二叉排序树的最小结点的值</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public int delRightTreeMin(Node1 Node1) &#123;</span><br><span class="line">        Node1 target &#x3D; Node1;</span><br><span class="line">        &#x2F;&#x2F;循环的查找左结点，找到最小的结点</span><br><span class="line">        while (target.left !&#x3D; null) &#123;</span><br><span class="line">            target &#x3D; target.left;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;这时target就指向了最小结点</span><br><span class="line">        &#x2F;&#x2F;删除最小结点</span><br><span class="line">        delNode1(target.value);</span><br><span class="line">        return target.value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;删除结点</span><br><span class="line">    public void delNode1(int value) &#123;</span><br><span class="line">        if (root &#x3D;&#x3D; null) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            &#x2F;&#x2F;1.需要先去找到要删除的结点 targetNode1</span><br><span class="line">            Node1 targetNode1 &#x3D; search(value);</span><br><span class="line">            &#x2F;&#x2F;如果没有找到要删除的结点</span><br><span class="line">            if (targetNode1 &#x3D;&#x3D; null) &#123;</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F;如果我们发现当前这颗二叉排序树只有一个结点</span><br><span class="line">            if (root.left &#x3D;&#x3D; null &amp;&amp; root.right &#x3D;&#x3D; null) &#123;</span><br><span class="line">                root &#x3D; null;</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F;去查找targetNode1的父结点</span><br><span class="line">            Node1 parent &#x3D; searchParent(value);</span><br><span class="line">            &#x2F;&#x2F;如果要删除的结点是叶子结点</span><br><span class="line">            if (targetNode1.left &#x3D;&#x3D; null &amp;&amp; targetNode1.right &#x3D;&#x3D; null) &#123;</span><br><span class="line">                &#x2F;&#x2F;判断targetNode1是父结点的左子结点还是右子结点</span><br><span class="line">                if (parent.left !&#x3D; null &amp;&amp; parent.left.value &#x3D;&#x3D; value) &#123; &#x2F;&#x2F;左子结点</span><br><span class="line">                    parent.left &#x3D; null;</span><br><span class="line">                &#125; else if (parent.right !&#x3D; null &amp;&amp; parent.right.value &#x3D;&#x3D; value) &#123; &#x2F;&#x2F;右子结点</span><br><span class="line">                    parent.right &#x3D; null;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else if (targetNode1.left !&#x3D; null &amp;&amp; targetNode1.right !&#x3D; null) &#123;</span><br><span class="line">                &#x2F;&#x2F;删除有两颗子树的节点</span><br><span class="line">                int minVal &#x3D; delRightTreeMin(targetNode1.right);</span><br><span class="line">                targetNode1.value &#x3D; minVal;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                &#x2F;&#x2F;删除只有一棵子树的结点</span><br><span class="line">                &#x2F;&#x2F;如果要删除的结点有左子结点</span><br><span class="line">                if (targetNode1.left !&#x3D; null) &#123;</span><br><span class="line">                    if (parent !&#x3D; null) &#123;</span><br><span class="line">                        &#x2F;&#x2F;如果targetNode1是parent的左子结点</span><br><span class="line">                        if (parent.left.value &#x3D;&#x3D; value) &#123;</span><br><span class="line">                            parent.left &#x3D; targetNode1.left;</span><br><span class="line">                        &#125; else &#123;</span><br><span class="line">                            &#x2F;&#x2F;target是parent的右子结点</span><br><span class="line">                            parent.right &#x3D; targetNode1.left;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        root &#x3D; targetNode1.left;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; else &#123; &#x2F;&#x2F;如果要删除的结点有右子结点</span><br><span class="line">                    if (parent !&#x3D; null) &#123;</span><br><span class="line">                        if (parent.left.value &#x3D;&#x3D; value) &#123;</span><br><span class="line">                            parent.left &#x3D; targetNode1.right;</span><br><span class="line">                        &#125; else &#123;</span><br><span class="line">                            &#x2F;&#x2F;如果targetNode1是parent的右子结点</span><br><span class="line">                            parent.right &#x3D; targetNode1.right;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        root &#x3D; targetNode1.right;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;添加节点的方法</span><br><span class="line">    public void add(Node1 Node1) &#123;</span><br><span class="line">        if (root &#x3D;&#x3D; null) &#123;</span><br><span class="line">            root &#x3D; Node1;  &#x2F;&#x2F;如果root为空值,直接让root指向Node1节点</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            root.add(Node1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;中序遍历</span><br><span class="line">    public void infixOrder() &#123;</span><br><span class="line">        if (root !&#x3D; null) &#123;</span><br><span class="line">            root.infixOrder();</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            System.out.println(&quot;二叉排序树为空&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;创建Node1节点</span><br><span class="line">class Node1 &#123;</span><br><span class="line">    int value;</span><br><span class="line">    Node1 left;</span><br><span class="line">    Node1 right;</span><br><span class="line"></span><br><span class="line">    public Node1(int value) &#123;</span><br><span class="line">        this.value &#x3D; value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;返回左子树的高度</span><br><span class="line">    public int leftHeight() &#123;</span><br><span class="line">        if (left &#x3D;&#x3D; null) &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        return left.height();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;返回右子树的高度</span><br><span class="line">    public int rightHeight() &#123;</span><br><span class="line">        if (right &#x3D;&#x3D; null) &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        return right.height();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;返回当前节点的高度,以该结点为根节点的树的高度</span><br><span class="line">    public int height() &#123;</span><br><span class="line">        return Math.max(left &#x3D;&#x3D; null ? 0 : left.height(), right &#x3D;&#x3D; null ? 0 : right.height()) + 1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;左旋转方法</span><br><span class="line">    private void leftRotate() &#123;</span><br><span class="line">        &#x2F;&#x2F;创建新的结点,以当前结点的值</span><br><span class="line">        Node1 newNode &#x3D; new Node1(value);</span><br><span class="line">        &#x2F;&#x2F;把新的结点的左子树设置成当前结点的左子树</span><br><span class="line">        newNode.left &#x3D; left;</span><br><span class="line">        &#x2F;&#x2F;把更新的结点的右子树设置成带你过去结点的右子树</span><br><span class="line">        newNode.right &#x3D; right.left;</span><br><span class="line">        &#x2F;&#x2F;把当前结点的值替换成右子结点的值</span><br><span class="line">        value &#x3D; right.value;</span><br><span class="line">        &#x2F;&#x2F;把当前结点的右子树设置成右子树的右子树</span><br><span class="line">        right &#x3D; right.right;</span><br><span class="line">        &#x2F;&#x2F;把当前结点的左子树(左子结点)设置成新的结点</span><br><span class="line">        left &#x3D; newNode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;右旋转</span><br><span class="line">    private void rightRotate() &#123;</span><br><span class="line">        Node1 newNode &#x3D; new Node1(value);</span><br><span class="line">        newNode.right &#x3D; right;</span><br><span class="line">        newNode.left &#x3D; left.right;</span><br><span class="line">        value &#x3D; left.value;</span><br><span class="line">        left &#x3D; left.left;</span><br><span class="line">        right &#x3D; newNode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 查找要删除的结点</span><br><span class="line">     *</span><br><span class="line">     * @param value 希望删除结点的值</span><br><span class="line">     * @return 如果找到返回该结点的值.否则返回Null</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public Node1 search(int value) &#123;</span><br><span class="line">        if (value &#x3D;&#x3D; this.value) &#123;</span><br><span class="line">            &#x2F;&#x2F;找到就是该点</span><br><span class="line">            return this;</span><br><span class="line">        &#125; else if (value &lt; this.value) &#123;</span><br><span class="line">            &#x2F;&#x2F;如果查找的值小于当前结点,向左子树递归查找</span><br><span class="line">            if (this.left &#x3D;&#x3D; null) &#123;</span><br><span class="line">                return null;</span><br><span class="line">            &#125;</span><br><span class="line">            return this.left.search(value);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            &#x2F;&#x2F;如果查找的值不小于当前结点,向右子树递归查找</span><br><span class="line">            if (this.right &#x3D;&#x3D; null) &#123;</span><br><span class="line">                return null;</span><br><span class="line">            &#125;</span><br><span class="line">            return this.right.search(value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 查找要删除结点的父结点</span><br><span class="line">     *</span><br><span class="line">     * @param value 要找的结点的值</span><br><span class="line">     * @return 返回的时要删除结点的父结点, 如果没有就返回null</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public Node1 searchParent(int value) &#123;</span><br><span class="line">        &#x2F;&#x2F;如果当前结点就是要删除结点的父结点,就返回</span><br><span class="line">        if ((this.left !&#x3D; null &amp;&amp; this.left.value &#x3D;&#x3D; value) || (this.right !&#x3D; null &amp;&amp; this.right.value &#x3D;&#x3D; value)) &#123;</span><br><span class="line">            return this;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            &#x2F;&#x2F;如果查找的值小于当前结点的值,并且当前结点的左子结点不为空</span><br><span class="line">            if (value &lt; this.value &amp;&amp; this.left !&#x3D; null) &#123;</span><br><span class="line">                return this.left.searchParent(value);</span><br><span class="line">            &#125; else if (value &gt;&#x3D; this.value &amp;&amp; this.right !&#x3D; null) &#123;</span><br><span class="line">                return this.right.searchParent(value);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                return null; &#x2F;&#x2F;没有找到父结点</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return &quot;Node1&#123;&quot; +</span><br><span class="line">                &quot;value&#x3D;&quot; + value +</span><br><span class="line">                &#39;&#125;&#39;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 添加结点方法</span><br><span class="line">     * 递归的形式添加结点,需要满足二叉排序树</span><br><span class="line">     *</span><br><span class="line">     * @param Node1</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public void add(Node1 Node1) &#123;</span><br><span class="line">        if (Node1 &#x3D;&#x3D; null) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;判断传入的节点的值,和当前根节点的值关系</span><br><span class="line">        if (Node1.value &lt; this.value) &#123;</span><br><span class="line">            &#x2F;&#x2F;当前节点的左子节点为null</span><br><span class="line">            if (this.left &#x3D;&#x3D; null) &#123;</span><br><span class="line">                this.left &#x3D; Node1;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                &#x2F;&#x2F;递归的向左子树添加</span><br><span class="line">                this.left.add(Node1);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123; &#x2F;&#x2F;添加的节点的值大于当前节点的值</span><br><span class="line">            if (this.right &#x3D;&#x3D; null) &#123;</span><br><span class="line">                this.right &#x3D; Node1;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                this.right.add(Node1);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;当添加完一个结点后,如果右子树的高度比左子树的高度&gt;1 发生左旋转</span><br><span class="line">        if (rightHeight() - leftHeight() &gt; 1) &#123;</span><br><span class="line">            &#x2F;&#x2F;如果它的右子树的左子树的高度大于它的右子树的右子树高度</span><br><span class="line">            if (right !&#x3D; null &amp;&amp; right.leftHeight() &gt; right.rightHeight()) &#123;</span><br><span class="line">                &#x2F;&#x2F;先对右子结点进行右旋转</span><br><span class="line">                right.rightRotate();</span><br><span class="line">                &#x2F;&#x2F;然后在对当前结点进行左旋转</span><br><span class="line">                leftRotate();</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                &#x2F;&#x2F;直接进行左旋转</span><br><span class="line">                leftRotate();</span><br><span class="line">            &#125;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;当添加完一个结点后,如果左子树的高度-右子树的高度&gt;1 ,右旋转</span><br><span class="line">        if (leftHeight() - rightHeight() &gt; 1) &#123;</span><br><span class="line">            if (left !&#x3D; null &amp;&amp; left.rightHeight() &gt; left.leftHeight()) &#123;</span><br><span class="line">                &#x2F;&#x2F;先对当前结点的左结点 左子树 （右旋转）</span><br><span class="line">                left.leftRotate();</span><br><span class="line">                rightRotate();</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                &#x2F;&#x2F;直接进行右旋转</span><br><span class="line">                rightRotate();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;中序遍历</span><br><span class="line">    public void infixOrder() &#123;</span><br><span class="line">        if (this.left !&#x3D; null) &#123;</span><br><span class="line">            this.left.infixOrder();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(this);</span><br><span class="line">        if (this.right !&#x3D; null) &#123;</span><br><span class="line">            this.right.infixOrder();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;java实现平衡二叉树-avl树&quot;&gt;&lt;a href=&quot;#java实现平衡二叉树-avl树&quot; class=&quot;headerlink&quot; title=&quot;java实现平衡二叉树(avl树)&quot;&gt;&lt;/a&gt;java实现平衡二叉树(avl树)&lt;/h1&gt;&lt;figure class=&quot;
      
    
    </summary>
    
    
      <category term="数据结构" scheme="https://todcsw.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="学习" scheme="https://todcsw.github.io/tags/%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="java" scheme="https://todcsw.github.io/tags/java/"/>
    
      <category term="数据结构" scheme="https://todcsw.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>java实现二叉排序树</title>
    <link href="https://todcsw.github.io/2020/04/30/dataStructure-java%E5%AE%9E%E7%8E%B0%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91/"/>
    <id>https://todcsw.github.io/2020/04/30/dataStructure-java%E5%AE%9E%E7%8E%B0%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91/</id>
    <published>2020-04-30T04:32:25.000Z</published>
    <updated>2020-05-08T08:25:11.830Z</updated>
    
    <content type="html"><![CDATA[<h1 id="java实现二叉排序树"><a href="#java实现二叉排序树" class="headerlink" title="java实现二叉排序树"></a>java实现二叉排序树</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package com.csw.tree;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * @Auther: 行路</span><br><span class="line"> * @Date: Created on 2020&#x2F;4&#x2F;30 10:56 星期四</span><br><span class="line"> * @Description: com.csw.tree 二叉排序树</span><br><span class="line"> * @version: 1.0</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class BinarySortTreeDemo &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int[] arr &#x3D; &#123;7, 3, 10, 12, 5, 1, 9, 2&#125;;</span><br><span class="line">        BinarySortTree binarySortTree &#x3D; new BinarySortTree();</span><br><span class="line">        &#x2F;&#x2F;循环的添加节点到二叉排序树</span><br><span class="line">        for (int i &#x3D; 0; i &lt; arr.length; i++) &#123;</span><br><span class="line">            binarySortTree.add(new Node(arr[i]));</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;中序遍历二叉树</span><br><span class="line">        System.out.println(&quot;中序遍历二叉树结果&quot;);</span><br><span class="line">        binarySortTree.infixOrder();</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;测试删除叶子结点&quot;);</span><br><span class="line"></span><br><span class="line">        binarySortTree.delNode(10);</span><br><span class="line"></span><br><span class="line">        binarySortTree.infixOrder();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;创建二叉排序树</span><br><span class="line">class BinarySortTree &#123;</span><br><span class="line">    private Node root;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;查找要删除的结点</span><br><span class="line">    public Node search(int value) &#123;</span><br><span class="line">        if (root &#x3D;&#x3D; null) &#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return root.search(value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;查找父结点</span><br><span class="line">    public Node searchParent(int value) &#123;</span><br><span class="line">        if (root &#x3D;&#x3D; null) &#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return root.searchParent(value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 方法:返回以node为根结点的二叉排序树的最小结点的值</span><br><span class="line">     * 2.删除node,为根结点的二叉排序树的最小结点</span><br><span class="line">     *</span><br><span class="line">     * @param node 传入的结点,当作一个二叉排序树的根结点</span><br><span class="line">     * @return 返回的以node为根结点的二叉排序树的最小结点的值</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public int delRightTreeMin(Node node) &#123;</span><br><span class="line">        Node target &#x3D; node;</span><br><span class="line">        &#x2F;&#x2F;循环的查找左结点，找到最小的结点</span><br><span class="line">        while (target.left !&#x3D; null) &#123;</span><br><span class="line">            target &#x3D; target.left;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;这时target就指向了最小结点</span><br><span class="line">        &#x2F;&#x2F;删除最小结点</span><br><span class="line">        delNode(target.value);</span><br><span class="line">        return target.value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;删除结点</span><br><span class="line">    public void delNode(int value) &#123;</span><br><span class="line">        if (root &#x3D;&#x3D; null) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            &#x2F;&#x2F;1.需要先去找到要删除的结点 targetNode</span><br><span class="line">            Node targetNode &#x3D; search(value);</span><br><span class="line">            &#x2F;&#x2F;如果没有找到要删除的结点</span><br><span class="line">            if (targetNode &#x3D;&#x3D; null) &#123;</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F;如果我们发现当前这颗二叉排序树只有一个结点</span><br><span class="line">            if (root.left &#x3D;&#x3D; null &amp;&amp; root.right &#x3D;&#x3D; null) &#123;</span><br><span class="line">                root &#x3D; null;</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F;去查找targetNode的父结点</span><br><span class="line">            Node parent &#x3D; searchParent(value);</span><br><span class="line">            &#x2F;&#x2F;如果要删除的结点是叶子结点</span><br><span class="line">            if (targetNode.left &#x3D;&#x3D; null &amp;&amp; targetNode.right &#x3D;&#x3D; null) &#123;</span><br><span class="line">                &#x2F;&#x2F;判断targetNode是父结点的左子结点还是右子结点</span><br><span class="line">                if (parent.left !&#x3D; null &amp;&amp; parent.left.value &#x3D;&#x3D; value) &#123; &#x2F;&#x2F;左子结点</span><br><span class="line">                    parent.left &#x3D; null;</span><br><span class="line">                &#125; else if (parent.right !&#x3D; null &amp;&amp; parent.right.value &#x3D;&#x3D; value) &#123; &#x2F;&#x2F;右子结点</span><br><span class="line">                    parent.right &#x3D; null;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else if (targetNode.left !&#x3D; null &amp;&amp; targetNode.right !&#x3D; null) &#123;</span><br><span class="line">                &#x2F;&#x2F;删除有两颗子树的节点</span><br><span class="line">                int minVal &#x3D; delRightTreeMin(targetNode.right);</span><br><span class="line">                targetNode.value &#x3D; minVal;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                &#x2F;&#x2F;删除只有一棵子树的结点</span><br><span class="line">                &#x2F;&#x2F;如果要删除的结点有左子结点</span><br><span class="line">                if (targetNode.left !&#x3D; null) &#123;</span><br><span class="line">                    if (parent !&#x3D; null) &#123;</span><br><span class="line">                        &#x2F;&#x2F;如果targetNode是parent的左子结点</span><br><span class="line">                        if (parent.left.value &#x3D;&#x3D; value) &#123;</span><br><span class="line">                            parent.left &#x3D; targetNode.left;</span><br><span class="line">                        &#125; else &#123;</span><br><span class="line">                            &#x2F;&#x2F;target是parent的右子结点</span><br><span class="line">                            parent.right &#x3D; targetNode.left;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        root &#x3D; targetNode.left;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; else &#123; &#x2F;&#x2F;如果要删除的结点有右子结点</span><br><span class="line">                    if (parent !&#x3D; null) &#123;</span><br><span class="line">                        if (parent.left.value &#x3D;&#x3D; value) &#123;</span><br><span class="line">                            parent.left &#x3D; targetNode.right;</span><br><span class="line">                        &#125; else &#123;</span><br><span class="line">                            &#x2F;&#x2F;如果targetNode是parent的右子结点</span><br><span class="line">                            parent.right &#x3D; targetNode.right;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        root &#x3D; targetNode.right;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;添加节点的方法</span><br><span class="line">    public void add(Node node) &#123;</span><br><span class="line">        if (root &#x3D;&#x3D; null) &#123;</span><br><span class="line">            root &#x3D; node;  &#x2F;&#x2F;如果root为空值,直接让root指向node节点</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            root.add(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;中序遍历</span><br><span class="line">    public void infixOrder() &#123;</span><br><span class="line">        if (root !&#x3D; null) &#123;</span><br><span class="line">            root.infixOrder();</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            System.out.println(&quot;二叉排序树为空&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;创建node节点</span><br><span class="line">class Node &#123;</span><br><span class="line">    int value;</span><br><span class="line">    Node left;</span><br><span class="line">    Node right;</span><br><span class="line"></span><br><span class="line">    public Node(int value) &#123;</span><br><span class="line">        this.value &#x3D; value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 查找要删除的结点</span><br><span class="line">     *</span><br><span class="line">     * @param value 希望删除结点的值</span><br><span class="line">     * @return 如果找到返回该结点的值.否则返回Null</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public Node search(int value) &#123;</span><br><span class="line">        if (value &#x3D;&#x3D; this.value) &#123;</span><br><span class="line">            &#x2F;&#x2F;找到就是该点</span><br><span class="line">            return this;</span><br><span class="line">        &#125; else if (value &lt; this.value) &#123;</span><br><span class="line">            &#x2F;&#x2F;如果查找的值小于当前结点,向左子树递归查找</span><br><span class="line">            if (this.left &#x3D;&#x3D; null) &#123;</span><br><span class="line">                return null;</span><br><span class="line">            &#125;</span><br><span class="line">            return this.left.search(value);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            &#x2F;&#x2F;如果查找的值不小于当前结点,向右子树递归查找</span><br><span class="line">            if (this.right &#x3D;&#x3D; null) &#123;</span><br><span class="line">                return null;</span><br><span class="line">            &#125;</span><br><span class="line">            return this.right.search(value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 查找要删除结点的父结点</span><br><span class="line">     *</span><br><span class="line">     * @param value 要找的结点的值</span><br><span class="line">     * @return 返回的时要删除结点的父结点, 如果没有就返回null</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public Node searchParent(int value) &#123;</span><br><span class="line">        &#x2F;&#x2F;如果当前结点就是要删除结点的父结点,就返回</span><br><span class="line">        if ((this.left !&#x3D; null &amp;&amp; this.left.value &#x3D;&#x3D; value) || (this.right !&#x3D; null &amp;&amp; this.right.value &#x3D;&#x3D; value)) &#123;</span><br><span class="line">            return this;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            &#x2F;&#x2F;如果查找的值小于当前结点的值,并且当前结点的左子结点不为空</span><br><span class="line">            if (value &lt; this.value &amp;&amp; this.left !&#x3D; null) &#123;</span><br><span class="line">                return this.left.searchParent(value);</span><br><span class="line">            &#125; else if (value &gt;&#x3D; this.value &amp;&amp; this.right !&#x3D; null) &#123;</span><br><span class="line">                return this.right.searchParent(value);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                return null; &#x2F;&#x2F;没有找到父结点</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return &quot;Node&#123;&quot; +</span><br><span class="line">                &quot;value&#x3D;&quot; + value +</span><br><span class="line">                &#39;&#125;&#39;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 添加结点方法</span><br><span class="line">     * 递归的形式添加结点,需要满足二叉排序树</span><br><span class="line">     *</span><br><span class="line">     * @param node</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public void add(Node node) &#123;</span><br><span class="line">        if (node &#x3D;&#x3D; null) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;判断传入的节点的值,和当前根节点的值关系</span><br><span class="line">        if (node.value &lt; this.value) &#123;</span><br><span class="line">            &#x2F;&#x2F;当前节点的左子节点为null</span><br><span class="line">            if (this.left &#x3D;&#x3D; null) &#123;</span><br><span class="line">                this.left &#x3D; node;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                &#x2F;&#x2F;递归的向左子树添加</span><br><span class="line">                this.left.add(node);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123; &#x2F;&#x2F;添加的节点的值大于当前节点的值</span><br><span class="line">            if (this.right &#x3D;&#x3D; null) &#123;</span><br><span class="line">                this.right &#x3D; node;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                this.right.add(node);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;中序遍历</span><br><span class="line">    public void infixOrder() &#123;</span><br><span class="line">        if (this.left !&#x3D; null) &#123;</span><br><span class="line">            this.left.infixOrder();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(this);</span><br><span class="line">        if (this.right !&#x3D; null) &#123;</span><br><span class="line">            this.right.infixOrder();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;java实现二叉排序树&quot;&gt;&lt;a href=&quot;#java实现二叉排序树&quot; class=&quot;headerlink&quot; title=&quot;java实现二叉排序树&quot;&gt;&lt;/a&gt;java实现二叉排序树&lt;/h1&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;tabl
      
    
    </summary>
    
    
      <category term="数据结构" scheme="https://todcsw.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="学习" scheme="https://todcsw.github.io/tags/%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="java" scheme="https://todcsw.github.io/tags/java/"/>
    
      <category term="数据结构" scheme="https://todcsw.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>java实现赫夫曼编码的压缩和解压</title>
    <link href="https://todcsw.github.io/2020/04/29/dataStructure-java%E5%AE%9E%E7%8E%B0%E8%B5%AB%E5%A4%AB%E6%9B%BC%E7%BC%96%E7%A0%81%E7%9A%84%E5%8E%8B%E7%BC%A9%E5%92%8C%E8%A7%A3%E5%8E%8B/"/>
    <id>https://todcsw.github.io/2020/04/29/dataStructure-java%E5%AE%9E%E7%8E%B0%E8%B5%AB%E5%A4%AB%E6%9B%BC%E7%BC%96%E7%A0%81%E7%9A%84%E5%8E%8B%E7%BC%A9%E5%92%8C%E8%A7%A3%E5%8E%8B/</id>
    <published>2020-04-29T13:43:23.000Z</published>
    <updated>2020-05-08T08:28:19.356Z</updated>
    
    <content type="html"><![CDATA[<h1 id="赫夫曼编码的压缩和解压"><a href="#赫夫曼编码的压缩和解压" class="headerlink" title="赫夫曼编码的压缩和解压"></a>赫夫曼编码的压缩和解压</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package com.csw.huffmantree;</span><br><span class="line"></span><br><span class="line">import java.io.*;</span><br><span class="line">import java.util.*;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * @Auther: 行路</span><br><span class="line"> * @Date: Created on 2020&#x2F;4&#x2F;29 20:11 星期三</span><br><span class="line"> * @Description: com.csw.huffmantree 赫夫曼编码的压缩和解压</span><br><span class="line"> * @version: 1.0</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class HuffmanCode &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        String content &#x3D; &quot;i like like like java do you like a java&quot;;</span><br><span class="line">        byte[] contentBytes &#x3D; content.getBytes();</span><br><span class="line">        System.out.println(contentBytes.length);</span><br><span class="line"></span><br><span class="line">        byte[] huffmanCodeBytes &#x3D; huffmanZip(contentBytes);</span><br><span class="line">        System.out.println(&quot;压缩后的结果:&quot; + Arrays.toString(huffmanCodeBytes) + &quot;长度&#x3D;&quot; + huffmanCodeBytes.length);</span><br><span class="line"></span><br><span class="line">        byte[] bytes &#x3D; decode(huffmanCodes, huffmanCodeBytes);</span><br><span class="line">        System.out.println(&quot;原来的字符串&#x3D;&quot; + new String(bytes));</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;测试压缩文件的代码</span><br><span class="line">        zipFile(&quot;d:&#x2F;&#x2F;src.bmp&quot;, &quot;d:&#x2F;&#x2F;src.hhh&quot;);</span><br><span class="line">        &#x2F;&#x2F;测试解压文件</span><br><span class="line">        unZipFile(&quot;d:&#x2F;&#x2F;dst.zip&quot;,&quot;d:&#x2F;&#x2F;src2.bmp&quot;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#x2F;*分步过程</span><br><span class="line">        List&lt;Node1&gt; nodes &#x3D; getNodes(contentBytes);</span><br><span class="line">        System.out.println(nodes);</span><br><span class="line">        System.out.println(&quot;测试创建的二叉树~~~~~哈夫曼树&quot;);</span><br><span class="line">        Node1 root &#x3D; createHuffmanTree(nodes);</span><br><span class="line">        System.out.println(&quot;前序遍历&quot;);</span><br><span class="line">        root.preOrder();</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;测试生成了对应的赫夫曼编码</span><br><span class="line">        getCodes(root);</span><br><span class="line">        System.out.println(&quot;生成的赫夫曼编码表&quot; + huffmanCodes);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;测试</span><br><span class="line">        byte[] huffmanCodeBytes &#x3D; zip(contentBytes, huffmanCodes);</span><br><span class="line">        System.out.println(&quot;huffmanCodeBytes&#x3D;&quot;+Arrays.toString(huffmanCodeBytes));</span><br><span class="line">        *&#x2F;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 编写一个方法,完成对压缩文件的解压</span><br><span class="line">     *</span><br><span class="line">     * @param zipFile 准备解压的文件</span><br><span class="line">     * @param dstFile 将文件解压到那个路径</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public static void unZipFile(String zipFile, String dstFile) &#123;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;定义文件输入流</span><br><span class="line">        InputStream is &#x3D; null;</span><br><span class="line">        &#x2F;&#x2F;定义一个对象输入流</span><br><span class="line">        ObjectInputStream ois &#x3D; null;</span><br><span class="line">        &#x2F;&#x2F;定义文件输出流</span><br><span class="line">        OutputStream os &#x3D; null;</span><br><span class="line">        try &#123;</span><br><span class="line">            &#x2F;&#x2F;创建文件输入流</span><br><span class="line">            is &#x3D; new FileInputStream(zipFile);</span><br><span class="line">            &#x2F;&#x2F;创建一个和is关联的对象输入流</span><br><span class="line">            ois &#x3D; new ObjectInputStream(is);</span><br><span class="line">            &#x2F;&#x2F;读取byte数组 huffmanBytes</span><br><span class="line">            byte[] huffmanBytes &#x3D; (byte[]) ois.readObject();</span><br><span class="line">            &#x2F;&#x2F;读取赫夫曼编码表</span><br><span class="line">            Map&lt;Byte, String&gt; huffmanCodes &#x3D; (Map&lt;Byte, String&gt;) ois.readObject();</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F;解码</span><br><span class="line">            byte[] bytes &#x3D; decode(huffmanCodes, huffmanBytes);</span><br><span class="line">            &#x2F;&#x2F;将bytes数组写入目标文件</span><br><span class="line">            os &#x3D; new FileOutputStream(dstFile);</span><br><span class="line">            &#x2F;&#x2F;写数据到文件中</span><br><span class="line">            os.write(bytes);</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                os.close();</span><br><span class="line">                ois.close();</span><br><span class="line">                is.close();</span><br><span class="line">            &#125; catch (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 编写方法,将一个文件进行压缩</span><br><span class="line">     *</span><br><span class="line">     * @param srcFile 你写入希望压缩文件的全路径</span><br><span class="line">     * @param dstFile 压缩文件放入那个目录</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public static void zipFile(String srcFile, String dstFile) &#123;</span><br><span class="line">        &#x2F;&#x2F;创建输入输出流</span><br><span class="line">        FileInputStream is &#x3D; null;</span><br><span class="line">        FileOutputStream os &#x3D; null;</span><br><span class="line">        ObjectOutputStream oos &#x3D; null;</span><br><span class="line">        &#x2F;&#x2F;创建文件的输入流</span><br><span class="line">        try &#123;</span><br><span class="line">            is &#x3D; new FileInputStream(srcFile);</span><br><span class="line">            &#x2F;&#x2F;创建一个和原文件大小一样的数组</span><br><span class="line">            byte[] b &#x3D; new byte[is.available()];</span><br><span class="line">            &#x2F;&#x2F;读取文件</span><br><span class="line">            is.read(b);</span><br><span class="line">            &#x2F;&#x2F;读取文件对应赫夫曼编码表</span><br><span class="line">            &#x2F;&#x2F;直接对源文件进行压缩</span><br><span class="line">            byte[] huffmanBytes &#x3D; huffmanZip(b);</span><br><span class="line">            os &#x3D; new FileOutputStream(dstFile);</span><br><span class="line">            &#x2F;&#x2F;创建一个和文件输出流相关联的objectOutputStream</span><br><span class="line">            oos &#x3D; new ObjectOutputStream(os);</span><br><span class="line">            &#x2F;&#x2F;把赫夫曼编码后的字节数组写入压缩文件</span><br><span class="line">            oos.writeObject(huffmanBytes);</span><br><span class="line">            &#x2F;&#x2F;以对象流的方式写进赫夫曼编码,为了我们恢复源文件时使用，</span><br><span class="line">            &#x2F;&#x2F;注意赫夫曼编码写入压缩文件</span><br><span class="line">            oos.writeObject(huffmanCodes);</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                is.close();</span><br><span class="line">                oos.close();</span><br><span class="line">                os.close();</span><br><span class="line">            &#125; catch (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;完成数据的解压 思路</span><br><span class="line">    &#x2F;&#x2F;1.将huffmanCodeBytes[-88, -65, -56, -65, -56, -65, -55, 77, -57, 6, -24, -14, -117, -4, -60, -90, 28]</span><br><span class="line">    &#x2F;&#x2F;重写先转成赫夫曼对应的二进制的字符串“1010100010111...”</span><br><span class="line">    &#x2F;&#x2F;2.赫夫曼编码对应的二进制的字符串“1010100010111...”&#x3D;》对照赫夫曼编码&#x3D;》 “i like like like java do you like ”</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 编写方法,完成对压缩数据的编码</span><br><span class="line">     *</span><br><span class="line">     * @param huffmanCodes 赫夫曼编码表</span><br><span class="line">     * @param huffmanBytes 赫夫曼编码得到的字节数组</span><br><span class="line">     * @return 就是原来的字符串对应的数组</span><br><span class="line">     *&#x2F;</span><br><span class="line">    private static byte[] decode(Map&lt;Byte, String&gt; huffmanCodes, byte[] huffmanBytes) &#123;</span><br><span class="line">        &#x2F;&#x2F;先得到huffmanBytes,对应的二进制字符串 形式1010100000</span><br><span class="line">        StringBuilder stringBuilder &#x3D; new StringBuilder();</span><br><span class="line">        &#x2F;&#x2F;将byte数组转成二进制字符串</span><br><span class="line">        for (int i &#x3D; 0; i &lt; huffmanBytes.length; i++) &#123;</span><br><span class="line">            byte b &#x3D; huffmanBytes[i];</span><br><span class="line">            &#x2F;&#x2F;判断是不是最后一个字节</span><br><span class="line">            boolean flag &#x3D; (i &#x3D;&#x3D; huffmanBytes.length - 1);</span><br><span class="line">            stringBuilder.append(byteToBitString(flag, b));</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;把字符串按照指定的赫夫曼编码就行解码</span><br><span class="line">        &#x2F;&#x2F;把赫夫曼编码进行交换,因为反向查询</span><br><span class="line">        Map&lt;String, Byte&gt; map &#x3D; new HashMap&lt;&gt;();</span><br><span class="line">        for (Map.Entry&lt;Byte, String&gt; entry : huffmanCodes.entrySet()) &#123;</span><br><span class="line">            map.put(entry.getValue(), entry.getKey());</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;创建集合存放byte</span><br><span class="line">        List&lt;Byte&gt; list &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">        &#x2F;&#x2F;可以理解位索引</span><br><span class="line">        for (int i &#x3D; 0; i &lt; stringBuilder.length(); ) &#123;</span><br><span class="line">            int count &#x3D; 1; &#x2F;&#x2F;小的计数器</span><br><span class="line">            boolean flag &#x3D; true;</span><br><span class="line">            Byte b &#x3D; null;</span><br><span class="line">            while (flag) &#123;</span><br><span class="line">                &#x2F;&#x2F;递增的取出</span><br><span class="line">                String key &#x3D; stringBuilder.substring(i, i + count); &#x2F;&#x2F;i不动,让count移动,指定匹配道的字符</span><br><span class="line">                b &#x3D; map.get(key);</span><br><span class="line">                if (b &#x3D;&#x3D; null) &#123;</span><br><span class="line">                    &#x2F;&#x2F;说明没有匹配道</span><br><span class="line">                    count++;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    flag &#x3D; false;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            list.add(b);</span><br><span class="line">            i +&#x3D; count; &#x2F;&#x2F;i直接移动到count</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;当for循环结束后,这个list存放了所有字符</span><br><span class="line">        &#x2F;&#x2F;把list中的数据放入到byte[] 并返回</span><br><span class="line">        byte[] b &#x3D; new byte[list.size()];</span><br><span class="line">        for (int i &#x3D; 0; i &lt; b.length; i++) &#123;</span><br><span class="line">            b[i] &#x3D; list.get(i);</span><br><span class="line">        &#125;</span><br><span class="line">        return b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 将一个byte转成二进制的字符串</span><br><span class="line">     *</span><br><span class="line">     * @param b</span><br><span class="line">     * @param flag 表示表示是否需要补高位</span><br><span class="line">     * @return 返回该byte对应的 二进制字符串(补码)</span><br><span class="line">     *&#x2F;</span><br><span class="line">    private static String byteToBitString(boolean flag, byte b) &#123;</span><br><span class="line">        &#x2F;&#x2F;使用变量保存b</span><br><span class="line">        int temp &#x3D; b; &#x2F;&#x2F;将b转成Int</span><br><span class="line">        &#x2F;&#x2F;如果是整数我们还需要补位</span><br><span class="line">        if (flag) &#123;</span><br><span class="line">            temp |&#x3D; 256; &#x2F;&#x2F;temp按位与 10000 0000 |0000 0001&#x3D;&gt;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        String str &#x3D; Integer.toBinaryString(temp); &#x2F;&#x2F;返回的是temp对应二进制的补码</span><br><span class="line">        if (flag) &#123;</span><br><span class="line">            return str.substring(str.length() - 8);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return str;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 使用一个方法,将前面的方法封装起来,便于我们的调用</span><br><span class="line">     *</span><br><span class="line">     * @param bytes 原始的字符串对应的字符串,便于我们调用</span><br><span class="line">     * @return 是经过赫夫曼编码处理后的字节数组</span><br><span class="line">     *&#x2F;</span><br><span class="line">    private static byte[] huffmanZip(byte[] bytes) &#123;</span><br><span class="line">        List&lt;Node1&gt; nodes &#x3D; getNodes(bytes);</span><br><span class="line">        &#x2F;&#x2F;根据nodes创建的赫夫曼树</span><br><span class="line">        Node1 huffmanTreeRoot &#x3D; createHuffmanTree(nodes);</span><br><span class="line">        &#x2F;&#x2F;生成对应的赫夫曼编码(根据赫夫曼树)</span><br><span class="line">        Map&lt;Byte, String&gt; huffmanCodes &#x3D; getCodes(huffmanTreeRoot);</span><br><span class="line">        &#x2F;&#x2F;根据生成的赫夫曼编码,压缩得到压缩后的赫夫曼编码字节数组</span><br><span class="line">        byte[] huffmanCodeBytes &#x3D; zip(bytes, huffmanCodes);</span><br><span class="line">        return huffmanCodeBytes;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 编写一个方法,将字符串对应的byte[]数组,通过生成的赫夫曼编码表返回一个赫夫曼编码压缩后的byte[]</span><br><span class="line">     *</span><br><span class="line">     * @param bytes        原始的字符串对应的byte[]</span><br><span class="line">     * @param huffmanCodes 生成赫夫曼编码map</span><br><span class="line">     * @return 返回赫夫曼编码处理后的byte[]</span><br><span class="line">     * 举例:String content&#x3D;&quot;i like like like java do you like a java&quot;; -&gt;byte[] contentBytes&#x3D;&gt; content.getBytes</span><br><span class="line">     * 返回的是字符串对应的byte数组 &#x3D;&gt;即8个对应一个byte放到byte数组中</span><br><span class="line">     * 10101000(补码)&#x3D;&gt; 10101000-1&#x3D;&gt;10100111(反码)&#x3D;&gt;11011000(原码)&#x3D;-88</span><br><span class="line">     *&#x2F;</span><br><span class="line">    private static byte[] zip(byte[] bytes, Map&lt;Byte, String&gt; huffmanCodes) &#123;</span><br><span class="line">        &#x2F;&#x2F;1.利用huffmanCodes将bytes转成赫夫曼编码对应的字符串</span><br><span class="line">        StringBuilder stringBuilder &#x3D; new StringBuilder();</span><br><span class="line">        &#x2F;&#x2F;遍历bytes数组</span><br><span class="line">        for (byte b : bytes) &#123;</span><br><span class="line">            stringBuilder.append(huffmanCodes.get(b));</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;将&quot;&quot;转成byte[]</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;统计返回byte[] huffmanCodeBytes长度</span><br><span class="line">        &#x2F;&#x2F;一句话</span><br><span class="line">        &#x2F;&#x2F;int len&#x3D;(stringBuilder.length()+7)&#x2F;8;</span><br><span class="line">        int len;</span><br><span class="line">        if (stringBuilder.length() % 8 &#x3D;&#x3D; 0) &#123;</span><br><span class="line">            len &#x3D; stringBuilder.length() &#x2F; 8;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            len &#x3D; stringBuilder.length() &#x2F; 8 + 1;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;创建存储压缩后的byte数组</span><br><span class="line">        byte[] huffmanCodeBytes &#x3D; new byte[len];</span><br><span class="line">        int index &#x3D; 0; &#x2F;&#x2F;记录是第几个byte</span><br><span class="line">        for (int i &#x3D; 0; i &lt; stringBuilder.length(); i +&#x3D; 8) &#123;</span><br><span class="line">            &#x2F;&#x2F;因为是每8位对应一个byte，所以步长+8</span><br><span class="line">            String strByte;</span><br><span class="line">            if (i + 8 &gt; stringBuilder.length()) &#123;</span><br><span class="line">                &#x2F;&#x2F;不够8位</span><br><span class="line">                strByte &#x3D; stringBuilder.substring(i);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                strByte &#x3D; stringBuilder.substring(i, i + 8);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F;将strByte转成一个byte，放入到huffmanCodeBytes</span><br><span class="line">            huffmanCodeBytes[index] &#x3D; (byte) Integer.parseInt(strByte, 2);</span><br><span class="line">            index++;</span><br><span class="line">        &#125;</span><br><span class="line">        return huffmanCodeBytes;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;生成赫夫曼树对应的赫夫曼编码</span><br><span class="line">    &#x2F;&#x2F;思路:将赫夫曼编码表存在map&lt;Byte,String&gt;形式</span><br><span class="line">    &#x2F;&#x2F;32-&gt;01 97-&gt;100 100-&gt;11000等等</span><br><span class="line">    static Map&lt;Byte, String&gt; huffmanCodes &#x3D; new HashMap&lt;&gt;();</span><br><span class="line">    &#x2F;&#x2F;2.在生成赫夫曼编码表时需要取拼接路径,定义一个StringBuilder存储某个叶子结点的路径</span><br><span class="line">    static StringBuilder stringBuilder &#x3D; new StringBuilder();</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;为了调用方便,重载getCodes</span><br><span class="line">    private static Map&lt;Byte, String&gt; getCodes(Node1 root) &#123;</span><br><span class="line">        if (root &#x3D;&#x3D; null) &#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;处理root的左子树</span><br><span class="line">        getCodes(root.left, &quot;0&quot;, stringBuilder);</span><br><span class="line">        &#x2F;&#x2F;处理root的右子树</span><br><span class="line">        getCodes(root.right, &quot;1&quot;, stringBuilder);</span><br><span class="line">        return huffmanCodes;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 功能:将传入的Node结点的所有叶子结点的赫夫曼编码得到,并放入到</span><br><span class="line">     *</span><br><span class="line">     * @param node          传入结点,</span><br><span class="line">     * @param code          路径:左子结点是0 右子结点1</span><br><span class="line">     * @param stringBuilder 用于拼接路径</span><br><span class="line">     *&#x2F;</span><br><span class="line">    private static void getCodes(Node1 node, String code, StringBuilder stringBuilder) &#123;</span><br><span class="line">        StringBuilder stringBuilder2 &#x3D; new StringBuilder(stringBuilder);</span><br><span class="line">        &#x2F;&#x2F;将code加入到stringBuilder2</span><br><span class="line">        stringBuilder2.append(code);</span><br><span class="line">        if (node !&#x3D; null) &#123;</span><br><span class="line">            &#x2F;&#x2F;如果node&#x3D;&#x3D;null不处理</span><br><span class="line">            &#x2F;&#x2F;判断当前node是叶子结点还是非叶子结点</span><br><span class="line">            if (node.data &#x3D;&#x3D; null) &#123;</span><br><span class="line">                &#x2F;&#x2F;非叶子结点</span><br><span class="line">                &#x2F;&#x2F;递归处理,向左,</span><br><span class="line">                getCodes(node.left, &quot;0&quot;, stringBuilder2);</span><br><span class="line">                &#x2F;&#x2F;向右递归</span><br><span class="line">                getCodes(node.right, &quot;1&quot;, stringBuilder2);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                &#x2F;&#x2F;说明是个叶子结点</span><br><span class="line">                &#x2F;&#x2F;表明找到了某个叶子结点的最后</span><br><span class="line">                huffmanCodes.put(node.data, stringBuilder2.toString());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;前序遍历的一个方法</span><br><span class="line">    private static void preOrder(Node1 root) &#123;</span><br><span class="line">        if (root !&#x3D; null) &#123;</span><br><span class="line">            root.preOrder();</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            System.out.println(&quot;赫夫曼树为空&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * @param bytes 接收一个字节数组</span><br><span class="line">     * @return 返回的是一个list形式,</span><br><span class="line">     *&#x2F;</span><br><span class="line">    private static List&lt;Node1&gt; getNodes(byte[] bytes) &#123;</span><br><span class="line">        &#x2F;&#x2F;创建一个ArrayList</span><br><span class="line">        ArrayList&lt;Node1&gt; nodes &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">        &#x2F;&#x2F;遍历bytes,统计每一个byte出现的次数-&gt;map[key,value]</span><br><span class="line">        Map&lt;Byte, Integer&gt; counts &#x3D; new HashMap&lt;&gt;();</span><br><span class="line">        for (byte b : bytes) &#123;</span><br><span class="line">            Integer count &#x3D; counts.get(b);</span><br><span class="line">            if (count &#x3D;&#x3D; null) &#123;</span><br><span class="line">                counts.put(b, 1);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                counts.put(b, count + 1);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;把每一个键值对转换成一个Node对象,并加入到nodes集合中</span><br><span class="line">        &#x2F;&#x2F;遍历map</span><br><span class="line">        for (Map.Entry&lt;Byte, Integer&gt; entry : counts.entrySet()) &#123;</span><br><span class="line">            nodes.add(new Node1(entry.getKey(), entry.getValue()));</span><br><span class="line">        &#125;</span><br><span class="line">        return nodes;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;可以通过List创建对应的赫夫曼树</span><br><span class="line">    private static Node1 createHuffmanTree(List&lt;Node1&gt; nodes) &#123;</span><br><span class="line">        while (nodes.size() &gt; 1) &#123;</span><br><span class="line">            &#x2F;&#x2F;排序,从小到大</span><br><span class="line">            Collections.sort(nodes);</span><br><span class="line">            &#x2F;&#x2F;取出第一颗最小的二叉树</span><br><span class="line">            Node1 leftNode &#x3D; nodes.get(0);</span><br><span class="line">            &#x2F;&#x2F;取出第二棵最小的二叉树</span><br><span class="line">            Node1 rightNode &#x3D; nodes.get(1);</span><br><span class="line">            &#x2F;&#x2F;创建一棵新的二叉树，它的根结点,没有data只有权值</span><br><span class="line">            Node1 parent &#x3D; new Node1(null, leftNode.weight + rightNode.weight);</span><br><span class="line">            parent.left &#x3D; leftNode;</span><br><span class="line">            parent.right &#x3D; rightNode;</span><br><span class="line">            &#x2F;&#x2F;将已经处理的两颗二叉树从nodes删除</span><br><span class="line">            nodes.remove(leftNode);</span><br><span class="line">            nodes.remove(rightNode);</span><br><span class="line">            &#x2F;&#x2F;将新的二叉树,加入到nodes</span><br><span class="line">            nodes.add(parent);</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;返回的结点,最后的结点就是哈夫曼树的根结点</span><br><span class="line">        return nodes.get(0);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;创建Node,带数据和权值</span><br><span class="line">class Node1 implements Comparable&lt;Node1&gt; &#123;</span><br><span class="line">    Byte data; &#x2F;&#x2F;存放数据本身,比如&#39;a&#39;&#x3D;&gt;97 &#39;&#39;&#x3D;&gt;32</span><br><span class="line">    int weight; &#x2F;&#x2F;权值,表示字符的出现次数</span><br><span class="line">    Node1 left; &#x2F;&#x2F;</span><br><span class="line">    Node1 right;</span><br><span class="line"></span><br><span class="line">    public Node1(Byte data, int weight) &#123;</span><br><span class="line">        this.data &#x3D; data;</span><br><span class="line">        this.weight &#x3D; weight;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public int compareTo(Node1 o) &#123;</span><br><span class="line">        return this.weight - o.weight;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return &quot;Node1[&quot; +</span><br><span class="line">                &quot;data&#x3D;&quot; + data + &quot; weight&#x3D;&quot; + weight +</span><br><span class="line">                &#39;]&#39;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;前序遍历</span><br><span class="line">    public void preOrder() &#123;</span><br><span class="line">        System.out.println(this);</span><br><span class="line">        if (this.left !&#x3D; null) &#123;</span><br><span class="line">            this.left.preOrder();</span><br><span class="line">        &#125;</span><br><span class="line">        if (this.right !&#x3D; null) &#123;</span><br><span class="line">            this.right.preOrder();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;赫夫曼编码的压缩和解压&quot;&gt;&lt;a href=&quot;#赫夫曼编码的压缩和解压&quot; class=&quot;headerlink&quot; title=&quot;赫夫曼编码的压缩和解压&quot;&gt;&lt;/a&gt;赫夫曼编码的压缩和解压&lt;/h1&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;tabl
      
    
    </summary>
    
    
      <category term="数据结构" scheme="https://todcsw.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="学习" scheme="https://todcsw.github.io/tags/%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="java" scheme="https://todcsw.github.io/tags/java/"/>
    
      <category term="数据结构" scheme="https://todcsw.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>java实现赫夫曼树</title>
    <link href="https://todcsw.github.io/2020/04/28/dataStructure-java%E5%AE%9E%E7%8E%B0%E8%B5%AB%E5%A4%AB%E6%9B%BC%E6%A0%91/"/>
    <id>https://todcsw.github.io/2020/04/28/dataStructure-java%E5%AE%9E%E7%8E%B0%E8%B5%AB%E5%A4%AB%E6%9B%BC%E6%A0%91/</id>
    <published>2020-04-28T08:45:43.000Z</published>
    <updated>2020-05-08T08:28:08.132Z</updated>
    
    <content type="html"><![CDATA[<h1 id="赫夫曼树"><a href="#赫夫曼树" class="headerlink" title="赫夫曼树"></a>赫夫曼树</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package com.csw.huffmantree;</span><br><span class="line"></span><br><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.Collection;</span><br><span class="line">import java.util.Collections;</span><br><span class="line">import java.util.List;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * @Auther: 行路</span><br><span class="line"> * @Date: Created on 2020&#x2F;4&#x2F;28 13:51 星期二</span><br><span class="line"> * @Description: com.csw.huffmantree 赫夫曼树</span><br><span class="line"> * @version: 1.0</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class HuffmanTree &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int[] arr &#x3D; &#123;13, 7, 8, 3, 29, 6, 1&#125;;</span><br><span class="line">        Node node &#x3D; createHuffmanTree(arr);</span><br><span class="line">        preOrder(node);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;编写一个前序遍历的方法</span><br><span class="line">    public static void preOrder(Node root)&#123;</span><br><span class="line">        if(root!&#x3D;null)&#123;</span><br><span class="line">            root.preOrder();</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            System.out.println(&quot;树是空树&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     *  创建赫夫曼树</span><br><span class="line">     * @param arr 需要创建哈夫曼树的数组</span><br><span class="line">     * @return 创建后的赫夫曼树的root结点</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public static Node createHuffmanTree(int[] arr) &#123;</span><br><span class="line">        &#x2F;&#x2F;第一步为了操作方便</span><br><span class="line">        &#x2F;&#x2F;1遍历arr数组</span><br><span class="line">        &#x2F;&#x2F;2.将arr的每个元素构成一个Node</span><br><span class="line">        &#x2F;&#x2F;3.将Node放入到ArrayList中</span><br><span class="line">        List&lt;Node&gt; nodes &#x3D; new ArrayList&lt;Node&gt;();</span><br><span class="line">        for (int value : arr) &#123;</span><br><span class="line">            nodes.add(new Node(value));</span><br><span class="line">        &#125;</span><br><span class="line">        while (nodes.size() &gt; 1) &#123;</span><br><span class="line">            &#x2F;&#x2F;排序从小到大</span><br><span class="line">            Collections.sort(nodes);</span><br><span class="line">            System.out.println(&quot;nodes&#x3D;&quot;+nodes);</span><br><span class="line">            &#x2F;&#x2F;取出权值最小的结点(二叉树)</span><br><span class="line">            Node leftNode &#x3D; nodes.get(0);</span><br><span class="line">            &#x2F;&#x2F;取出第二小</span><br><span class="line">            Node rightNode &#x3D; nodes.get(1);</span><br><span class="line">            &#x2F;&#x2F;构建新的二叉树</span><br><span class="line">            Node parent &#x3D; new Node(leftNode.value + rightNode.value);</span><br><span class="line">            parent.left &#x3D; leftNode;</span><br><span class="line">            parent.right &#x3D; rightNode;</span><br><span class="line">            &#x2F;&#x2F;从ArrayList删除处理过的二叉树</span><br><span class="line">            nodes.remove(leftNode);</span><br><span class="line">            nodes.remove(rightNode);</span><br><span class="line">            &#x2F;&#x2F;将parent加入到nodes</span><br><span class="line">            nodes.add(parent);</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;返回哈夫曼树树的root结点</span><br><span class="line">        return nodes.get(0);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * Description: 为了让node对象持续排序Collection集合排序</span><br><span class="line"> * 让Node实现comparable接口</span><br><span class="line"> * 创建结点类</span><br><span class="line"> *</span><br><span class="line"> * @author Todcsw</span><br><span class="line"> * @date</span><br><span class="line"> *&#x2F;</span><br><span class="line">class Node implements Comparable&lt;Node&gt; &#123;</span><br><span class="line">    int value;  &#x2F;&#x2F;结点权值</span><br><span class="line">    Node left;  &#x2F;&#x2F;指向左子结点</span><br><span class="line">    Node right; &#x2F;&#x2F;指向右子结点</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;写一个前序遍历</span><br><span class="line">    public void preOrder()&#123;</span><br><span class="line">        System.out.println(this);</span><br><span class="line">        if(this.left!&#x3D;null)&#123;</span><br><span class="line">            this.left.preOrder();</span><br><span class="line">        &#125;</span><br><span class="line">        if(this.right!&#x3D;null)&#123;</span><br><span class="line">            this.right.preOrder();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Node(int value) &#123;</span><br><span class="line">        this.value &#x3D; value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return &quot;Node[&quot; +</span><br><span class="line">                &quot;value&#x3D;&quot; + value +</span><br><span class="line">                &#39;]&#39;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public int compareTo(Node o) &#123;</span><br><span class="line">        &#x2F;&#x2F;表示从小到大</span><br><span class="line">        return this.value - o.value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;赫夫曼树&quot;&gt;&lt;a href=&quot;#赫夫曼树&quot; class=&quot;headerlink&quot; title=&quot;赫夫曼树&quot;&gt;&lt;/a&gt;赫夫曼树&lt;/h1&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;
      
    
    </summary>
    
    
      <category term="数据结构" scheme="https://todcsw.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="学习" scheme="https://todcsw.github.io/tags/%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="java" scheme="https://todcsw.github.io/tags/java/"/>
    
      <category term="数据结构" scheme="https://todcsw.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>java实现线索化二叉树及遍历</title>
    <link href="https://todcsw.github.io/2020/04/27/dataStructure-java%E5%AE%9E%E7%8E%B0%E7%BA%BF%E7%B4%A2%E5%8C%96%E4%BA%8C%E5%8F%89%E6%A0%91%E5%8F%8A%E9%81%8D%E5%8E%86/"/>
    <id>https://todcsw.github.io/2020/04/27/dataStructure-java%E5%AE%9E%E7%8E%B0%E7%BA%BF%E7%B4%A2%E5%8C%96%E4%BA%8C%E5%8F%89%E6%A0%91%E5%8F%8A%E9%81%8D%E5%8E%86/</id>
    <published>2020-04-27T07:59:23.000Z</published>
    <updated>2020-05-08T08:27:51.739Z</updated>
    
    <content type="html"><![CDATA[<h1 id="java实现线索化二叉树及遍历"><a href="#java实现线索化二叉树及遍历" class="headerlink" title="java实现线索化二叉树及遍历"></a>java实现线索化二叉树及遍历</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package com.csw.tree;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * @Auther: 行路</span><br><span class="line"> * @Date: Created on 2020&#x2F;4&#x2F;27 14:19 星期一</span><br><span class="line"> * @Description: com.csw.tree 线索二叉树(遍历线索二叉树)</span><br><span class="line"> * @version: 1.0</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class ThreadedBinaryTreeDemo &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        &#x2F;&#x2F;测试中序线索二叉树的功能</span><br><span class="line">        HeroNode1 root &#x3D; new HeroNode1(1, &quot;tom&quot;);</span><br><span class="line">        HeroNode1 node2 &#x3D; new HeroNode1(3, &quot;jack&quot;);</span><br><span class="line">        HeroNode1 node3 &#x3D; new HeroNode1(6, &quot;smith&quot;);</span><br><span class="line">        HeroNode1 node4 &#x3D; new HeroNode1(8, &quot;mary&quot;);</span><br><span class="line">        HeroNode1 node5 &#x3D; new HeroNode1(10, &quot;king&quot;);</span><br><span class="line">        HeroNode1 node6 &#x3D; new HeroNode1(14, &quot;dim&quot;);</span><br><span class="line">        &#x2F;&#x2F;后续会递归创建,目前手动创建</span><br><span class="line">        root.setLeft(node2);</span><br><span class="line">        root.setRight(node3);</span><br><span class="line">        node2.setLeft(node4);</span><br><span class="line">        node2.setRight(node5);</span><br><span class="line">        node3.setLeft(node6);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;测试中序线索化</span><br><span class="line">        ThreadedBinaryTree threadedBinaryTree &#x3D; new ThreadedBinaryTree();</span><br><span class="line">        threadedBinaryTree.setRoot(root);</span><br><span class="line">        threadedBinaryTree.threadedNodes();</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;测试:以10结点测试 左3右1</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;前驱结点:&quot; + node5.getLeft() + &quot;\n后继结点:&quot; + node5.getRight());</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;使用线索化的方式遍历线索化二叉树&quot;);</span><br><span class="line">        threadedBinaryTree.threadedList();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * Description: 定义BinaryTree1二叉树</span><br><span class="line"> * 定义ThreadedBinaryTree实现了线索化功能的二叉树</span><br><span class="line"> *</span><br><span class="line"> * @author Todcsw</span><br><span class="line"> * @date</span><br><span class="line"> *&#x2F;</span><br><span class="line">class ThreadedBinaryTree &#123;</span><br><span class="line">    private HeroNode1 root;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;为了实现线索化,需要创建要给指向当前结点的前驱结点的指针</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;递归进行线索化,pre总是保留前一个结点</span><br><span class="line">    private HeroNode1 pre &#x3D; null;</span><br><span class="line"></span><br><span class="line">    public void setRoot(HeroNode1 root) &#123;</span><br><span class="line">        this.root &#x3D; root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void threadedNodes() &#123;</span><br><span class="line">        this.threadNodes(root);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;遍历线索化二叉树的方法</span><br><span class="line">    public void threadedList() &#123;</span><br><span class="line">        &#x2F;&#x2F;定义变量,存储当前遍历的结点,从root开始</span><br><span class="line">        HeroNode1 node &#x3D; root;</span><br><span class="line">        while (node !&#x3D; null) &#123;</span><br><span class="line">            &#x2F;&#x2F;循环的找到leftType&#x3D;&#x3D;1结点,第一个找到的是8结点</span><br><span class="line">            &#x2F;&#x2F;后面随着遍历而变化,因为leftType&#x3D;&#x3D;1时,说明该结点时按照线索化</span><br><span class="line">            &#x2F;&#x2F;处理后的有效结点</span><br><span class="line">            while (node.getLeftType() &#x3D;&#x3D; 0) &#123;</span><br><span class="line">                node &#x3D; node.getLeft();</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F;打印当前这个结点</span><br><span class="line">            System.out.println(node);</span><br><span class="line">            &#x2F;&#x2F;如果当前结点的右指针指向的是后继结点,就一直输出</span><br><span class="line">            while (node.getRightType()&#x3D;&#x3D;1)&#123;</span><br><span class="line">                node&#x3D;node.getRight();</span><br><span class="line">                System.out.println(node);</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F;替换这个遍历的结点</span><br><span class="line">            node&#x3D;node.getRight();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;编写对二叉树进行中序线索化的方法、</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * @param node 就是当前需要线索化的结点</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public void threadNodes(HeroNode1 node) &#123;</span><br><span class="line">        &#x2F;&#x2F;如果node&#x3D;null，不能线索化</span><br><span class="line">        if (node &#x3D;&#x3D; null) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;先线索化左子树</span><br><span class="line">        threadNodes(node.getLeft());</span><br><span class="line">        &#x2F;&#x2F;线索化当前结点,处理当前结点的前驱结点</span><br><span class="line">        &#x2F;&#x2F;以8号结点 .left&#x3D;null,8结点的.leftType&#x3D;1</span><br><span class="line">        if (node.getLeft() &#x3D;&#x3D; null) &#123;</span><br><span class="line">            &#x2F;&#x2F;让当前结点的左子针指向前驱结点</span><br><span class="line">            node.setLeft(pre);</span><br><span class="line">            &#x2F;&#x2F;修改当前结点的左指针类型,指向前驱结点</span><br><span class="line">            node.setLeftType(1);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;处理后继结点</span><br><span class="line">        if (pre !&#x3D; null &amp;&amp; pre.getRight() &#x3D;&#x3D; null) &#123;</span><br><span class="line">            &#x2F;&#x2F;让前驱结点的右指针指向当前这个结点</span><br><span class="line">            pre.setRight(node);</span><br><span class="line">            &#x2F;&#x2F;修改前驱结点的右指针类型</span><br><span class="line">            pre.setRightType(1);</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;!!!每处理一个结点后,让当前结点是下一个结点的前驱结点</span><br><span class="line">        pre &#x3D; node;</span><br><span class="line">        &#x2F;&#x2F;在线索化右子树</span><br><span class="line">        threadNodes(node.getRight());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 前序遍历</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public void preOrder() &#123;</span><br><span class="line">        if (this.root !&#x3D; null) &#123;</span><br><span class="line">            this.root.preOrder();</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            System.out.println(&quot;二叉树为空无法遍历&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 中序遍历</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public void infixOrder() &#123;</span><br><span class="line">        if (this.root !&#x3D; null) &#123;</span><br><span class="line">            this.root.infixOrder();</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            System.out.println(&quot;二叉树为空无法遍历&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 后序遍历</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public void postOrder() &#123;</span><br><span class="line">        if (this.root !&#x3D; null) &#123;</span><br><span class="line">            this.root.postOrder();</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            System.out.println(&quot;二叉树为空无法遍历&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 递归删除</span><br><span class="line">     *</span><br><span class="line">     * @param no</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public void delNode(int no) &#123;</span><br><span class="line">        if (root !&#x3D; null) &#123;</span><br><span class="line">            &#x2F;&#x2F;判断root是不是要删除的</span><br><span class="line">            if (root.getNo() &#x3D;&#x3D; no) &#123;</span><br><span class="line">                root &#x3D; null;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                &#x2F;&#x2F;递归删除</span><br><span class="line">                root.delNode(no);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            System.out.println(&quot;空树不能删除&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 前序查找</span><br><span class="line">     *</span><br><span class="line">     * @param no</span><br><span class="line">     * @return</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public HeroNode1 preOrderSearch(int no) &#123;</span><br><span class="line">        if (root !&#x3D; null) &#123;</span><br><span class="line">            return root.preOrderSearch(no);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 中序查找</span><br><span class="line">     *</span><br><span class="line">     * @param no</span><br><span class="line">     * @return</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public HeroNode1 infixOrderSearch(int no) &#123;</span><br><span class="line">        if (root !&#x3D; null) &#123;</span><br><span class="line">            return root.infixOrderSearch(no);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 后序查找</span><br><span class="line">     *</span><br><span class="line">     * @param no</span><br><span class="line">     * @return</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public HeroNode1 postOrderSearch(int no) &#123;</span><br><span class="line">        if (root !&#x3D; null) &#123;</span><br><span class="line">            return root.postOrderSearch(no);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * Description: 创建HeroNode11节点</span><br><span class="line"> *</span><br><span class="line"> * @author Todcsw</span><br><span class="line"> * @date</span><br><span class="line"> *&#x2F;</span><br><span class="line">class HeroNode1 &#123;</span><br><span class="line">    private int no;</span><br><span class="line">    private String name;</span><br><span class="line">    private HeroNode1 left; &#x2F;&#x2F;默认为Null</span><br><span class="line">    private HeroNode1 right; &#x2F;&#x2F;默认null</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;说明leftType&#x3D;&#x3D;0表示指向的是左子树,如果是1则表示指向前驱结点</span><br><span class="line">    &#x2F;&#x2F;2.说明rightType&#x3D;&#x3D;0表示指向的右子树,如果是1则表示指向后继结点</span><br><span class="line">    private int leftType;</span><br><span class="line">    private int rightType;</span><br><span class="line"></span><br><span class="line">    public int getLeftType() &#123;</span><br><span class="line">        return leftType;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setLeftType(int leftType) &#123;</span><br><span class="line">        this.leftType &#x3D; leftType;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int getRightType() &#123;</span><br><span class="line">        return rightType;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setRightType(int rightType) &#123;</span><br><span class="line">        this.rightType &#x3D; rightType;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public HeroNode1(int no, String name) &#123;</span><br><span class="line">        this.no &#x3D; no;</span><br><span class="line">        this.name &#x3D; name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int getNo() &#123;</span><br><span class="line">        return no;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setNo(int no) &#123;</span><br><span class="line">        this.no &#x3D; no;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getName() &#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setName(String name) &#123;</span><br><span class="line">        this.name &#x3D; name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public HeroNode1 getLeft() &#123;</span><br><span class="line">        return left;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setLeft(HeroNode1 left) &#123;</span><br><span class="line">        this.left &#x3D; left;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public HeroNode1 getRight() &#123;</span><br><span class="line">        return right;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setRight(HeroNode1 right) &#123;</span><br><span class="line">        this.right &#x3D; right;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return &quot;HeroNode11&#123;&quot; +</span><br><span class="line">                &quot;no&#x3D;&quot; + no +</span><br><span class="line">                &quot;, name&#x3D;&#39;&quot; + name + &#39;\&#39;&#39; +</span><br><span class="line">                &#39;&#125;&#39;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 递归删除节点</span><br><span class="line">     * 如果删除的节点是叶子节点,则删除该节点</span><br><span class="line">     * 如果删除的节点是非叶子节点,则删除该子树</span><br><span class="line">     * 1.因为我们的二叉树是单向的,所以我们是判断当前节点的子节点是否需要删除的节点,而不能去判断,当前这个结点是不是需要删除的结点</span><br><span class="line">     * 2.如果当前结点的左子结点不为空,并且左子结点就是要删除的结点,就将this.left&#x3D;null;并且就返回(结束递归删除)</span><br><span class="line">     * 3.如果当前结点的右子结点不为空,并且右子结点就是要删除的结点,就将this.right&#x3D;null;并且就返回(结束递归删除)</span><br><span class="line">     * 4.如果第2和3步没有删除结点,那么晚我们需要向左子树就行递归删除</span><br><span class="line">     * 5.如果第4步也没有删除结点,则应当向右子树进行递归删除</span><br><span class="line">     *</span><br><span class="line">     * @param no</span><br><span class="line">     *&#x2F;</span><br><span class="line"></span><br><span class="line">    public void delNode(int no) &#123;</span><br><span class="line"></span><br><span class="line">        if (this.left !&#x3D; null &amp;&amp; this.left.no &#x3D;&#x3D; no) &#123;</span><br><span class="line">            this.left &#x3D; null;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        if (this.right !&#x3D; null &amp;&amp; this.right.no &#x3D;&#x3D; no) &#123;</span><br><span class="line">            this.right &#x3D; null;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        if (this.left !&#x3D; null) &#123;</span><br><span class="line">            this.left.delNode(no);</span><br><span class="line">        &#125;</span><br><span class="line">        if (this.right !&#x3D; null) &#123;</span><br><span class="line">            this.right.delNode(no);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 编写前序遍历的方法</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public void preOrder() &#123;</span><br><span class="line">        System.out.println(this); &#x2F;&#x2F;先输出父节点</span><br><span class="line">        &#x2F;&#x2F;递归向左子树遍历</span><br><span class="line">        if (this.left !&#x3D; null) &#123;</span><br><span class="line">            this.left.preOrder();</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;递归向右子树前序遍历</span><br><span class="line">        if (this.right !&#x3D; null) &#123;</span><br><span class="line">            this.right.preOrder();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 编写中序遍历的方法</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public void infixOrder() &#123;</span><br><span class="line">        &#x2F;&#x2F;递归向左子树中序遍历</span><br><span class="line">        if (this.left !&#x3D; null) &#123;</span><br><span class="line">            this.left.infixOrder();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(this);</span><br><span class="line">        if (this.right !&#x3D; null) &#123;</span><br><span class="line">            this.right.infixOrder();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 编写后序遍历的方法</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public void postOrder() &#123;</span><br><span class="line">        &#x2F;&#x2F;递归向左子树中序遍历</span><br><span class="line">        if (this.left !&#x3D; null) &#123;</span><br><span class="line">            this.left.postOrder();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (this.right !&#x3D; null) &#123;</span><br><span class="line">            this.right.postOrder();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(this);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 前序遍历查找</span><br><span class="line">     *</span><br><span class="line">     * @param no 查找no</span><br><span class="line">     * @return 如果找到就返回该node，如果没有找到就返回Null</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public HeroNode1 preOrderSearch(int no) &#123;</span><br><span class="line">        System.out.println(&quot;进入前序遍历&quot;);</span><br><span class="line">        &#x2F;&#x2F;比较当前节点是不是</span><br><span class="line">        if (this.no &#x3D;&#x3D; no) &#123;</span><br><span class="line">            return this;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;则判断当前节点的左子节点是否为空,如果不为空,则递归前序查找</span><br><span class="line">        HeroNode1 resNode &#x3D; null;</span><br><span class="line">        if (this.left !&#x3D; null) &#123;</span><br><span class="line">            resNode &#x3D; this.left.preOrderSearch(no);</span><br><span class="line">        &#125;</span><br><span class="line">        if (resNode !&#x3D; null) &#123;</span><br><span class="line">            &#x2F;&#x2F;说明左子树找到了</span><br><span class="line">            return resNode;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;1左递归前序查找,找到节点,则返回,否则继续判断</span><br><span class="line">        &#x2F;&#x2F;2当前的结点的右子节点是否为空,如果不空,则继续向右递归前序查找</span><br><span class="line">        if (this.right !&#x3D; null) &#123;</span><br><span class="line">            resNode &#x3D; this.right.preOrderSearch(no);</span><br><span class="line">        &#125;</span><br><span class="line">        return resNode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 中序遍历查找</span><br><span class="line">     *</span><br><span class="line">     * @param no</span><br><span class="line">     * @return</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public HeroNode1 infixOrderSearch(int no) &#123;</span><br><span class="line">        &#x2F;&#x2F;判断当前节点的左子节点是否为空,如果不为空,则递归中序查找</span><br><span class="line">        HeroNode1 resNode &#x3D; null;</span><br><span class="line">        if (this.left !&#x3D; null) &#123;</span><br><span class="line">            resNode &#x3D; this.left.infixOrderSearch(no);</span><br><span class="line">        &#125;</span><br><span class="line">        if (resNode !&#x3D; null) &#123;</span><br><span class="line">            return resNode;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot;进入中序遍历&quot;);</span><br><span class="line">        if (this.no &#x3D;&#x3D; no) &#123;</span><br><span class="line">            return this;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;向右进行中序查找</span><br><span class="line">        if (this.right !&#x3D; null) &#123;</span><br><span class="line">            resNode &#x3D; this.right.infixOrderSearch(no);</span><br><span class="line">        &#125;</span><br><span class="line">        return resNode;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 后续遍历查找</span><br><span class="line">     *</span><br><span class="line">     * @param no</span><br><span class="line">     * @return</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public HeroNode1 postOrderSearch(int no) &#123;</span><br><span class="line"></span><br><span class="line">        HeroNode1 resNode &#x3D; null;</span><br><span class="line">        if (this.left !&#x3D; null) &#123;</span><br><span class="line">            resNode &#x3D; this.left.postOrderSearch(no);</span><br><span class="line">        &#125;</span><br><span class="line">        if (resNode !&#x3D; null) &#123;</span><br><span class="line">            return resNode;</span><br><span class="line">        &#125;</span><br><span class="line">        if (this.right !&#x3D; null) &#123;</span><br><span class="line">            resNode &#x3D; this.right.postOrderSearch(no);</span><br><span class="line">        &#125;</span><br><span class="line">        if (resNode !&#x3D; null) &#123;</span><br><span class="line">            return resNode;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot;进入后序遍历&quot;);</span><br><span class="line">        if (this.no &#x3D;&#x3D; no) &#123;</span><br><span class="line">            return this;</span><br><span class="line">        &#125;</span><br><span class="line">        return resNode;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;java实现线索化二叉树及遍历&quot;&gt;&lt;a href=&quot;#java实现线索化二叉树及遍历&quot; class=&quot;headerlink&quot; title=&quot;java实现线索化二叉树及遍历&quot;&gt;&lt;/a&gt;java实现线索化二叉树及遍历&lt;/h1&gt;&lt;figure class=&quot;highli
      
    
    </summary>
    
    
      <category term="数据结构" scheme="https://todcsw.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="学习" scheme="https://todcsw.github.io/tags/%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="java" scheme="https://todcsw.github.io/tags/java/"/>
    
      <category term="数据结构" scheme="https://todcsw.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>java实现二叉树的前序中序后序遍历和查找及删除</title>
    <link href="https://todcsw.github.io/2020/04/26/dataStructure-java%E5%AE%9E%E7%8E%B0%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E5%BA%8F%E4%B8%AD%E5%BA%8F%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E5%92%8C%E6%9F%A5%E6%89%BE%E5%8F%8A%E5%88%A0%E9%99%A4/"/>
    <id>https://todcsw.github.io/2020/04/26/dataStructure-java%E5%AE%9E%E7%8E%B0%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E5%BA%8F%E4%B8%AD%E5%BA%8F%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E5%92%8C%E6%9F%A5%E6%89%BE%E5%8F%8A%E5%88%A0%E9%99%A4/</id>
    <published>2020-04-26T07:59:23.000Z</published>
    <updated>2020-05-08T08:25:23.166Z</updated>
    
    <content type="html"><![CDATA[<h1 id="java实现二叉树的前序中序后序遍历和查找及删除"><a href="#java实现二叉树的前序中序后序遍历和查找及删除" class="headerlink" title="java实现二叉树的前序中序后序遍历和查找及删除"></a>java实现二叉树的前序中序后序遍历和查找及删除</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package com.csw.tree;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * @Auther: 行路</span><br><span class="line"> * @Date: Created on 2020&#x2F;4&#x2F;26 13:00 星期日</span><br><span class="line"> * @Description: com.csw.tree 二叉树的前序中序后序遍历和查找及删除</span><br><span class="line"> * @version: 1.0</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class BinaryTreeDemo &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        &#x2F;&#x2F;先需要创建一颗二叉树</span><br><span class="line">        BinaryTree binaryTree &#x3D; new BinaryTree();</span><br><span class="line">        &#x2F;&#x2F;创建需要的节点</span><br><span class="line">        HeroNode root&#x3D;new HeroNode(1,&quot;宋江&quot;);</span><br><span class="line">        HeroNode node2&#x3D;new HeroNode(2,&quot;吴用&quot;);</span><br><span class="line">        HeroNode node3&#x3D;new HeroNode(3,&quot;卢俊义&quot;);</span><br><span class="line">        HeroNode node4&#x3D;new HeroNode(4,&quot;林冲&quot;);</span><br><span class="line">        HeroNode node5&#x3D;new HeroNode(5,&quot;关胜&quot;);</span><br><span class="line">        &#x2F;&#x2F;说明,我们先手动创建二叉树,后面会递归方式创建二叉树</span><br><span class="line">        root.setLeft(node2);</span><br><span class="line">        root.setRight(node3);</span><br><span class="line">        node3.setRight(node4);</span><br><span class="line">        node3.setLeft(node5);</span><br><span class="line">        binaryTree.setRoot(root);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;测试</span><br><span class="line">        System.out.println(&quot;前序遍历&quot;); &#x2F;&#x2F;</span><br><span class="line">        binaryTree.preOrder();</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;中序遍历&quot;); &#x2F;&#x2F;</span><br><span class="line">        binaryTree.infixOrder();</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;后序遍历&quot;); &#x2F;&#x2F;</span><br><span class="line">        binaryTree.postOrder();</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;前序查找~~~&quot;);</span><br><span class="line">        HeroNode resNode&#x3D;binaryTree.postOrderSearch(5);</span><br><span class="line">        if(resNode!&#x3D;null)&#123;</span><br><span class="line">            System.out.println(&quot;找到了信息为:&quot;+resNode.getNo()+resNode.getName());</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            System.out.println(&quot;找不到&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;测试删除结点&quot;);</span><br><span class="line">        binaryTree.preOrder();</span><br><span class="line">        binaryTree.delNode(5);</span><br><span class="line">        System.out.println(&quot;删除后的结点&quot;);</span><br><span class="line">        binaryTree.preOrder();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * Description: 定义BinaryTree二叉树</span><br><span class="line"> *</span><br><span class="line"> * @author Todcsw</span><br><span class="line"> * @date</span><br><span class="line"> *&#x2F;</span><br><span class="line">class BinaryTree &#123;</span><br><span class="line">    private HeroNode root;</span><br><span class="line"></span><br><span class="line">    public void setRoot(HeroNode root) &#123;</span><br><span class="line">        this.root &#x3D; root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 前序遍历</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public void preOrder() &#123;</span><br><span class="line">        if (this.root !&#x3D; null) &#123;</span><br><span class="line">            this.root.preOrder();</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            System.out.println(&quot;二叉树为空无法遍历&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 中序遍历</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public void infixOrder() &#123;</span><br><span class="line">        if (this.root !&#x3D; null) &#123;</span><br><span class="line">            this.root.infixOrder();</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            System.out.println(&quot;二叉树为空无法遍历&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 后序遍历</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public void postOrder() &#123;</span><br><span class="line">        if (this.root !&#x3D; null) &#123;</span><br><span class="line">            this.root.postOrder();</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            System.out.println(&quot;二叉树为空无法遍历&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 递归删除</span><br><span class="line">     * @param no</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public void delNode(int no)&#123;</span><br><span class="line">        if(root!&#x3D;null)&#123;</span><br><span class="line">            &#x2F;&#x2F;判断root是不是要删除的</span><br><span class="line">            if(root.getNo()&#x3D;&#x3D;no)&#123;</span><br><span class="line">                root&#x3D;null;</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                &#x2F;&#x2F;递归删除</span><br><span class="line">                root.delNode(no);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            System.out.println(&quot;空树不能删除&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 前序查找</span><br><span class="line">     * @param no</span><br><span class="line">     * @return</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public HeroNode preOrderSearch(int no)&#123;</span><br><span class="line">        if(root!&#x3D;null)&#123;</span><br><span class="line">            return root.preOrderSearch(no);</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 中序查找</span><br><span class="line">     * @param no</span><br><span class="line">     * @return</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public HeroNode infixOrderSearch(int no)&#123;</span><br><span class="line">        if(root!&#x3D;null)&#123;</span><br><span class="line">            return root.infixOrderSearch(no);</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 后序查找</span><br><span class="line">     * @param no</span><br><span class="line">     * @return</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public HeroNode postOrderSearch(int no)&#123;</span><br><span class="line">        if(root!&#x3D;null)&#123;</span><br><span class="line">            return root.postOrderSearch(no);</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * Description: 创建HeroNode节点</span><br><span class="line"> *</span><br><span class="line"> * @author Todcsw</span><br><span class="line"> * @date</span><br><span class="line"> *&#x2F;</span><br><span class="line">class HeroNode &#123;</span><br><span class="line">    private int no;</span><br><span class="line">    private String name;</span><br><span class="line">    private HeroNode left; &#x2F;&#x2F;默认为Null</span><br><span class="line">    private HeroNode right; &#x2F;&#x2F;默认null</span><br><span class="line"></span><br><span class="line">    public HeroNode(int no, String name) &#123;</span><br><span class="line">        this.no &#x3D; no;</span><br><span class="line">        this.name &#x3D; name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int getNo() &#123;</span><br><span class="line">        return no;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setNo(int no) &#123;</span><br><span class="line">        this.no &#x3D; no;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getName() &#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setName(String name) &#123;</span><br><span class="line">        this.name &#x3D; name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public HeroNode getLeft() &#123;</span><br><span class="line">        return left;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setLeft(HeroNode left) &#123;</span><br><span class="line">        this.left &#x3D; left;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public HeroNode getRight() &#123;</span><br><span class="line">        return right;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setRight(HeroNode right) &#123;</span><br><span class="line">        this.right &#x3D; right;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return &quot;HeroNode&#123;&quot; +</span><br><span class="line">                &quot;no&#x3D;&quot; + no +</span><br><span class="line">                &quot;, name&#x3D;&#39;&quot; + name + &#39;\&#39;&#39; +</span><br><span class="line">                &#39;&#125;&#39;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     *递归删除节点</span><br><span class="line">     *如果删除的节点是叶子节点,则删除该节点</span><br><span class="line">     *如果删除的节点是非叶子节点,则删除该子树</span><br><span class="line">     * 1.因为我们的二叉树是单向的,所以我们是判断当前节点的子节点是否需要删除的节点,而不能去判断,当前这个结点是不是需要删除的结点</span><br><span class="line">     * 2.如果当前结点的左子结点不为空,并且左子结点就是要删除的结点,就将this.left&#x3D;null;并且就返回(结束递归删除)</span><br><span class="line">     * 3.如果当前结点的右子结点不为空,并且右子结点就是要删除的结点,就将this.right&#x3D;null;并且就返回(结束递归删除)</span><br><span class="line">     * 4.如果第2和3步没有删除结点,那么晚我们需要向左子树就行递归删除</span><br><span class="line">     * 5.如果第4步也没有删除结点,则应当向右子树进行递归删除</span><br><span class="line">     * @param no</span><br><span class="line">     *&#x2F;</span><br><span class="line"></span><br><span class="line">    public void delNode(int no)&#123;</span><br><span class="line"></span><br><span class="line">        if(this.left!&#x3D;null&amp;&amp;this.left.no&#x3D;&#x3D;no)&#123;</span><br><span class="line">            this.left&#x3D;null;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        if(this.right!&#x3D;null&amp;&amp;this.right.no&#x3D;&#x3D;no)&#123;</span><br><span class="line">            this.right&#x3D;null;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        if(this.left!&#x3D;null)&#123;</span><br><span class="line">            this.left.delNode(no);</span><br><span class="line">        &#125;</span><br><span class="line">        if(this.right!&#x3D;null)&#123;</span><br><span class="line">            this.right.delNode(no);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 编写前序遍历的方法</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public void preOrder() &#123;</span><br><span class="line">        System.out.println(this); &#x2F;&#x2F;先输出父节点</span><br><span class="line">        &#x2F;&#x2F;递归向左子树遍历</span><br><span class="line">        if (this.left !&#x3D; null) &#123;</span><br><span class="line">            this.left.preOrder();</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;递归向右子树前序遍历</span><br><span class="line">        if (this.right !&#x3D; null) &#123;</span><br><span class="line">            this.right.preOrder();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 编写中序遍历的方法</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public void infixOrder() &#123;</span><br><span class="line">        &#x2F;&#x2F;递归向左子树中序遍历</span><br><span class="line">        if (this.left !&#x3D; null) &#123;</span><br><span class="line">            this.left.infixOrder();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(this);</span><br><span class="line">        if (this.right !&#x3D; null) &#123;</span><br><span class="line">            this.right.infixOrder();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 编写后序遍历的方法</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public void postOrder() &#123;</span><br><span class="line">        &#x2F;&#x2F;递归向左子树中序遍历</span><br><span class="line">        if (this.left !&#x3D; null) &#123;</span><br><span class="line">            this.left.postOrder();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (this.right !&#x3D; null) &#123;</span><br><span class="line">            this.right.postOrder();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(this);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 前序遍历查找</span><br><span class="line">     * @param no 查找no</span><br><span class="line">     * @return 如果找到就返回该node，如果没有找到就返回Null</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public HeroNode preOrderSearch(int no)&#123;</span><br><span class="line">        System.out.println(&quot;进入前序遍历&quot;);</span><br><span class="line">        &#x2F;&#x2F;比较当前节点是不是</span><br><span class="line">        if(this.no&#x3D;&#x3D;no)&#123;</span><br><span class="line">            return this;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;则判断当前节点的左子节点是否为空,如果不为空,则递归前序查找</span><br><span class="line">        HeroNode resNode&#x3D;null;</span><br><span class="line">        if(this.left!&#x3D;null)&#123;</span><br><span class="line">            resNode&#x3D;this.left.preOrderSearch(no);</span><br><span class="line">        &#125;</span><br><span class="line">        if(resNode!&#x3D;null)&#123;</span><br><span class="line">            &#x2F;&#x2F;说明左子树找到了</span><br><span class="line">            return resNode;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;1左递归前序查找,找到节点,则返回,否则继续判断</span><br><span class="line">        &#x2F;&#x2F;2当前的结点的右子节点是否为空,如果不空,则继续向右递归前序查找</span><br><span class="line">        if(this.right!&#x3D;null)&#123;</span><br><span class="line">            resNode&#x3D;this.right.preOrderSearch(no);</span><br><span class="line">        &#125;</span><br><span class="line">        return resNode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 中序遍历查找</span><br><span class="line">     * @param no</span><br><span class="line">     * @return</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public HeroNode infixOrderSearch(int no)&#123;</span><br><span class="line">        &#x2F;&#x2F;判断当前节点的左子节点是否为空,如果不为空,则递归中序查找</span><br><span class="line">        HeroNode resNode&#x3D;null;</span><br><span class="line">        if(this.left!&#x3D;null)&#123;</span><br><span class="line">            resNode&#x3D;this.left.infixOrderSearch(no);</span><br><span class="line">        &#125;</span><br><span class="line">        if(resNode!&#x3D;null)&#123;</span><br><span class="line">            return resNode;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot;进入中序遍历&quot;);</span><br><span class="line">        if(this.no&#x3D;&#x3D;no)&#123;</span><br><span class="line">            return this;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;向右进行中序查找</span><br><span class="line">        if(this.right!&#x3D;null)&#123;</span><br><span class="line">            resNode&#x3D;this.right.infixOrderSearch(no);</span><br><span class="line">        &#125;</span><br><span class="line">        return resNode;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 后续遍历查找</span><br><span class="line">     * @param no</span><br><span class="line">     * @return</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public HeroNode postOrderSearch(int no)&#123;</span><br><span class="line"></span><br><span class="line">        HeroNode resNode&#x3D;null;</span><br><span class="line">        if(this.left!&#x3D;null)&#123;</span><br><span class="line">            resNode&#x3D;this.left.postOrderSearch(no);</span><br><span class="line">        &#125;</span><br><span class="line">        if(resNode!&#x3D;null)&#123;</span><br><span class="line">            return resNode;</span><br><span class="line">        &#125;</span><br><span class="line">        if(this.right!&#x3D;null)&#123;</span><br><span class="line">            resNode&#x3D;this.right.postOrderSearch(no);</span><br><span class="line">        &#125;</span><br><span class="line">        if(resNode!&#x3D;null)&#123;</span><br><span class="line">            return resNode;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot;进入后序遍历&quot;);</span><br><span class="line">        if(this.no&#x3D;&#x3D;no)&#123;</span><br><span class="line">            return this;</span><br><span class="line">        &#125;</span><br><span class="line">        return resNode;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;java实现二叉树的前序中序后序遍历和查找及删除&quot;&gt;&lt;a href=&quot;#java实现二叉树的前序中序后序遍历和查找及删除&quot; class=&quot;headerlink&quot; title=&quot;java实现二叉树的前序中序后序遍历和查找及删除&quot;&gt;&lt;/a&gt;java实现二叉树的前序中序
      
    
    </summary>
    
    
      <category term="数据结构" scheme="https://todcsw.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="学习" scheme="https://todcsw.github.io/tags/%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="java" scheme="https://todcsw.github.io/tags/java/"/>
    
      <category term="数据结构" scheme="https://todcsw.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>java实现哈希表</title>
    <link href="https://todcsw.github.io/2020/04/25/dataStructure-java%E5%AE%9E%E7%8E%B0%E5%93%88%E5%B8%8C%E8%A1%A8/"/>
    <id>https://todcsw.github.io/2020/04/25/dataStructure-java%E5%AE%9E%E7%8E%B0%E5%93%88%E5%B8%8C%E8%A1%A8/</id>
    <published>2020-04-25T15:29:59.000Z</published>
    <updated>2020-05-08T08:26:02.941Z</updated>
    
    <content type="html"><![CDATA[<h1 id="java实现哈希表"><a href="#java实现哈希表" class="headerlink" title="java实现哈希表"></a>java实现哈希表</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package com.csw.hashtab;</span><br><span class="line"></span><br><span class="line">import java.util.Scanner;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * @Auther: 行路</span><br><span class="line"> * @Date: Created on 2020&#x2F;4&#x2F;25 20:21 星期六</span><br><span class="line"> * @Description: com.csw.hashtab 哈希表</span><br><span class="line"> * @version: 1.0</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class HashTabDemo &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        &#x2F;&#x2F;创建哈希表</span><br><span class="line">        HashTab hashTab&#x3D;new HashTab(7);</span><br><span class="line">        &#x2F;&#x2F;写一个简单的菜单</span><br><span class="line">        String key&#x3D;&quot;&quot;;</span><br><span class="line">        Scanner scanner&#x3D;new Scanner(System.in);</span><br><span class="line">        while (true)&#123;</span><br><span class="line">            System.out.println(&quot;add:添加雇员&quot;);</span><br><span class="line">            System.out.println(&quot;list:显示雇员&quot;);</span><br><span class="line">            System.out.println(&quot;find:查找雇员&quot;);</span><br><span class="line">            System.out.println(&quot;exit:退出系统&quot;);</span><br><span class="line">            key&#x3D;scanner.next();</span><br><span class="line">            switch (key)&#123;</span><br><span class="line">                case &quot;add&quot;:</span><br><span class="line">                    System.out.println(&quot;输入id&quot;);</span><br><span class="line">                    int id&#x3D;scanner.nextInt();</span><br><span class="line">                    System.out.println(&quot;输入名字&quot;);</span><br><span class="line">                    String name&#x3D;scanner.next();</span><br><span class="line">                    &#x2F;&#x2F;创建雇员</span><br><span class="line">                    Emp emp&#x3D;new Emp(id,name);</span><br><span class="line">                    hashTab.add(emp);</span><br><span class="line">                    break;</span><br><span class="line">                case &quot;list&quot;:</span><br><span class="line">                    hashTab.list();</span><br><span class="line">                    break;</span><br><span class="line">                case &quot;find&quot;:</span><br><span class="line">                    System.out.println(&quot;请输入要查找的id&quot;);</span><br><span class="line">                    id&#x3D;scanner.nextInt();</span><br><span class="line">                    hashTab.findEmpById(id);</span><br><span class="line">                    break;</span><br><span class="line">                case &quot;exit&quot;:</span><br><span class="line">                    scanner.close();</span><br><span class="line">                    System.exit(0);</span><br><span class="line">                default:</span><br><span class="line">                    break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;创建HashTab,管理多条链表</span><br><span class="line">class HashTab&#123;</span><br><span class="line">    private EmpLinkedList[] empLinkedListArray;</span><br><span class="line">    private int size; &#x2F;&#x2F;表示共有多少条</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;构造器</span><br><span class="line">    public HashTab(int size)&#123;</span><br><span class="line">        this.size&#x3D;size;</span><br><span class="line">        &#x2F;&#x2F;初始化empLinkedListArray</span><br><span class="line">        empLinkedListArray&#x3D;new EmpLinkedList[size];</span><br><span class="line">        &#x2F;&#x2F;不能忘,分别初始化每个链表</span><br><span class="line">        for(int i&#x3D;0;i&lt;size;i++)&#123;</span><br><span class="line">            empLinkedListArray[i]&#x3D;new EmpLinkedList();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;添加雇员</span><br><span class="line">    public void add(Emp emp)&#123;</span><br><span class="line">        &#x2F;&#x2F;根据员工的id,得到该员工应当添加到那条链表</span><br><span class="line">        int empLinkedListNo&#x3D;hashFun(emp.id);</span><br><span class="line">        &#x2F;&#x2F;将emp添加到链表中</span><br><span class="line">        empLinkedListArray[empLinkedListNo].add(emp);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;遍历所有表,哈希表hashtab</span><br><span class="line">    public void list()&#123;</span><br><span class="line">        for (int i&#x3D;0;i&lt;size;i++)&#123;</span><br><span class="line">            empLinkedListArray[i].list(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;编写散列函数,使用一个简单取模法</span><br><span class="line">    public int hashFun(int id)&#123;</span><br><span class="line">        return id%size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;根据输入的Id,查找这个雇员</span><br><span class="line">    public void findEmpById(int id)&#123;</span><br><span class="line">        &#x2F;&#x2F;使用散列函数确定到那条链表</span><br><span class="line">        int empLinkedListNo&#x3D;hashFun(id);</span><br><span class="line">        Emp emp&#x3D;empLinkedListArray[empLinkedListNo].findEmpById(id);</span><br><span class="line">        if(emp!&#x3D;null)&#123;</span><br><span class="line">            &#x2F;&#x2F;找到</span><br><span class="line">            System.out.printf(&quot;在第%d条链表中找到雇员id&#x3D;%d\n&quot;,(empLinkedListNo+1),id);</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            System.out.println(&quot;在哈希表中没有找到该雇员~&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;表示一个雇员</span><br><span class="line">class Emp&#123;</span><br><span class="line">    public int id;</span><br><span class="line">    public String name;</span><br><span class="line">    public Emp next;</span><br><span class="line"></span><br><span class="line">    public Emp(int id, String name) &#123;</span><br><span class="line">        this.id &#x3D; id;</span><br><span class="line">        this.name &#x3D; name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;创建EmpLinkedList,表示链表</span><br><span class="line">class EmpLinkedList&#123;</span><br><span class="line">    &#x2F;&#x2F;头指针,执行第一个Emp,因此我们这个链表的head是直接指向第一个Emp</span><br><span class="line">    private Emp head;  &#x2F;&#x2F;默认null</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;添加雇员到链表</span><br><span class="line">    &#x2F;&#x2F;1.假定,当添加雇员时 ,id是自增的,即id的分配总是从小到大</span><br><span class="line">    &#x2F;&#x2F;因此我们将该雇员直接加入到本链表即可</span><br><span class="line">    public void add(Emp emp)&#123;</span><br><span class="line">        &#x2F;&#x2F;如果添加的是第一个雇员</span><br><span class="line">        if(head&#x3D;&#x3D;null)&#123;</span><br><span class="line">            head&#x3D;emp;</span><br><span class="line">            return ;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;如果不是第一个雇员,则使用辅助指针,帮助定位到最后</span><br><span class="line">        Emp curEmp&#x3D;head;</span><br><span class="line">        while (true) &#123;</span><br><span class="line">            if (curEmp.next &#x3D;&#x3D; null) &#123;</span><br><span class="line">                &#x2F;&#x2F;说明已经到最后了</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            curEmp &#x3D; curEmp.next; &#x2F;&#x2F;后移</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;当退出时直接将 emp加入链表</span><br><span class="line">        curEmp.next&#x3D;emp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;遍历链表的雇员信息</span><br><span class="line">    public void list(int no)&#123;</span><br><span class="line">        if(head&#x3D;&#x3D;null)&#123;</span><br><span class="line">            &#x2F;&#x2F;说明链表为空</span><br><span class="line">            System.out.println(&quot;第&quot;+(no+1)+&quot;条链表为空&quot;);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.print(&quot;第&quot;+(no+1)+&quot;条链表的信息为:&quot;);</span><br><span class="line">        Emp curEmp&#x3D;head;</span><br><span class="line">        while (true)&#123;</span><br><span class="line">            System.out.printf(&quot;-&gt;id&#x3D;%d name&#x3D;%s\t&quot;,curEmp.id,curEmp.name);</span><br><span class="line">            if(curEmp.next&#x3D;&#x3D;null)&#123;</span><br><span class="line">                &#x2F;&#x2F;说明curEmp已经是最后节点了</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            curEmp&#x3D;curEmp.next;  &#x2F;&#x2F;后移遍历</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;根据id查找雇员</span><br><span class="line">    &#x2F;&#x2F;如果查找到,就返回Emp,如果没有找到,就返回null</span><br><span class="line">    public Emp findEmpById(int id)&#123;</span><br><span class="line">        &#x2F;&#x2F;判断链表是否为空</span><br><span class="line">        if(head&#x3D;&#x3D;null)&#123;</span><br><span class="line">            System.out.println(&quot;链表未找到&quot;);</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;辅助指针</span><br><span class="line">        Emp curEmp&#x3D;head;</span><br><span class="line">        while (true)&#123;</span><br><span class="line">            if(curEmp.id&#x3D;&#x3D;id)&#123;</span><br><span class="line">                &#x2F;&#x2F;找到,这时curEMp就指向要查找的雇员</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F;退出</span><br><span class="line">            if(curEmp.next&#x3D;&#x3D;null)&#123;</span><br><span class="line">                &#x2F;&#x2F;说明遍历当前链表没有找到雇员</span><br><span class="line">                curEmp&#x3D;null;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            curEmp&#x3D;curEmp.next;</span><br><span class="line">        &#125;</span><br><span class="line">        return curEmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;java实现哈希表&quot;&gt;&lt;a href=&quot;#java实现哈希表&quot; class=&quot;headerlink&quot; title=&quot;java实现哈希表&quot;&gt;&lt;/a&gt;java实现哈希表&lt;/h1&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;t
      
    
    </summary>
    
    
      <category term="数据结构" scheme="https://todcsw.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="学习" scheme="https://todcsw.github.io/tags/%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="java" scheme="https://todcsw.github.io/tags/java/"/>
    
      <category term="数据结构" scheme="https://todcsw.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>java实现插值查找和斐波那契查找算法</title>
    <link href="https://todcsw.github.io/2020/04/24/dataStructure-java%E5%AE%9E%E7%8E%B0%E6%8F%92%E5%80%BC%E6%9F%A5%E6%89%BE%E5%92%8C%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95/"/>
    <id>https://todcsw.github.io/2020/04/24/dataStructure-java%E5%AE%9E%E7%8E%B0%E6%8F%92%E5%80%BC%E6%9F%A5%E6%89%BE%E5%92%8C%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95/</id>
    <published>2020-04-24T12:32:32.000Z</published>
    <updated>2020-05-08T08:27:17.528Z</updated>
    
    <content type="html"><![CDATA[<h1 id="java实现插值查找和斐波那契查找算法"><a href="#java实现插值查找和斐波那契查找算法" class="headerlink" title="java实现插值查找和斐波那契查找算法"></a>java实现插值查找和斐波那契查找算法</h1><h2 id="插值查找"><a href="#插值查找" class="headerlink" title="插值查找"></a>插值查找</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package com.csw.search;</span><br><span class="line"></span><br><span class="line">import java.util.Arrays;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * @Auther: 行路</span><br><span class="line"> * @Date: Created on 2020&#x2F;4&#x2F;24 16:47 星期五</span><br><span class="line"> * @Description: com.csw.search 插值查找</span><br><span class="line"> * @version: 1.0</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class InsertValueSearch &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int[] arr&#x3D;new int[100];</span><br><span class="line">        for(int i&#x3D;0;i&lt;100;i++)&#123;</span><br><span class="line">            arr[i]&#x3D;i+1;</span><br><span class="line">        &#125;</span><br><span class="line">        int i &#x3D; insertValueSearch(arr, 0, arr.length - 1, 33);</span><br><span class="line">        System.out.println(&quot;查找次数:&quot;+count+&quot;，查找到的下标为:&quot;+i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 插值查找算法</span><br><span class="line">     * 要求数组是有序的</span><br><span class="line">     * @param arr</span><br><span class="line">     * @param left</span><br><span class="line">     * @param right</span><br><span class="line">     * @param findVal</span><br><span class="line">     * @return &#x2F;&#x2F;如果找到,就返回对应的值,如果没有找到,返回-1</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public static int count&#x3D;0;</span><br><span class="line">    public static int insertValueSearch(int[] arr,int left,int right,int findVal)&#123;</span><br><span class="line">        ++count;</span><br><span class="line">        &#x2F;&#x2F;注意这两个条件必须有,否则会得到mid可能越界</span><br><span class="line">        if(left&gt;right||findVal&lt;arr[0]||findVal&gt;arr[arr.length-1])&#123;</span><br><span class="line">            return -1;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;求出mid 自适应的值</span><br><span class="line">        int mid&#x3D;left+(right-left)*(findVal-arr[left])&#x2F;(arr[right]-arr[left]);</span><br><span class="line">        int midVal&#x3D;arr[mid];</span><br><span class="line">        if(findVal&gt;midVal)&#123;</span><br><span class="line">            return insertValueSearch(arr,mid+1,right,findVal);                    &#x2F;&#x2F;说明向右递归查找</span><br><span class="line">        &#125;else if(findVal&lt;midVal)&#123;</span><br><span class="line">            return insertValueSearch(arr,left,mid-1,findVal);</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            return mid;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="斐波那契查找"><a href="#斐波那契查找" class="headerlink" title="斐波那契查找"></a>斐波那契查找</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package com.csw.search;</span><br><span class="line"></span><br><span class="line">import java.util.Arrays;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * @Auther: 行路</span><br><span class="line"> * @Date: Created on 2020&#x2F;4&#x2F;23 23:19 星期二</span><br><span class="line"> * @Description: com.csw.search 斐波那契查找算法</span><br><span class="line"> * @version: 1.0</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class FibonacciSearch &#123;</span><br><span class="line">    public static int maxSize &#x3D; 20;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int[] arr &#x3D; &#123;1, 8, 10, 89, 1000, 1234&#125;;</span><br><span class="line">        System.out.println(fibSearch(arr,1234));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;mid&#x3D;low+F(k-1)+1,后面需要使用斐波那契数列,因此我们需要先获取到一个斐波那契数列</span><br><span class="line">    &#x2F;&#x2F;非递归的方式得到斐波那契数列</span><br><span class="line">    public static int[] fib() &#123;</span><br><span class="line">        int[] f &#x3D; new int[maxSize];</span><br><span class="line">        f[0] &#x3D; 1;</span><br><span class="line">        f[1] &#x3D; 1;</span><br><span class="line">        for (int i &#x3D; 2; i &lt; maxSize; i++) &#123;</span><br><span class="line">            f[i] &#x3D; f[i - 1] + f[i - 2];</span><br><span class="line">        &#125;</span><br><span class="line">        return f;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 使用非递归</span><br><span class="line">     * 编写斐波那契查找算法</span><br><span class="line">     *</span><br><span class="line">     * @param a   数组</span><br><span class="line">     * @param key 我们需要查找的关键码</span><br><span class="line">     * @return 返回对应的小标, 如果没有-1</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public static int fibSearch(int[] a, int key) &#123;</span><br><span class="line">        int low &#x3D; 0;</span><br><span class="line">        int high &#x3D; a.length - 1;</span><br><span class="line">        int k &#x3D; 0;  &#x2F;&#x2F;表示斐波那契分割数值对应下标</span><br><span class="line">        int mid &#x3D; 0;  &#x2F;&#x2F;存放mid值</span><br><span class="line">        int[] f &#x3D; fib();  &#x2F;&#x2F;获取斐波那契数列</span><br><span class="line">        &#x2F;&#x2F;获取到斐波那契分割值的小标</span><br><span class="line">        while (high &gt; f[k] - 1) &#123;</span><br><span class="line">            k++;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;因为f[k]值大于a的长度,因此许Arrays类,构造一个新的数组,并指向a[]</span><br><span class="line">        int[] temp &#x3D; Arrays.copyOf(a, f[k]);</span><br><span class="line">        &#x2F;&#x2F;实际上需要使用a数组最后的数填充temp</span><br><span class="line">        for (int i &#x3D; high + 1; i &lt; temp.length; i++) &#123;</span><br><span class="line">            temp[i] &#x3D; a[high];</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;使用while循环来循环处理,找到我们的数key</span><br><span class="line">        while (low &lt;&#x3D; high) &#123;</span><br><span class="line">            &#x2F;&#x2F;只要这个添加满足,就可以一直找</span><br><span class="line">            mid &#x3D; low + f[k - 1] - 1;</span><br><span class="line">            if(key&lt;temp[mid])&#123;</span><br><span class="line">                &#x2F;&#x2F;说明我们应该向数组的前面查找</span><br><span class="line">                high&#x3D;mid-1;</span><br><span class="line">                &#x2F;&#x2F;1.全部元素&#x3D;前面的元素+后边的元素</span><br><span class="line">                &#x2F;&#x2F;2.f[k]&#x3D;f[k-1]+h[k-2]</span><br><span class="line">                &#x2F;&#x2F;因为前面有f[k-1]个元素,所以可以继续拆分f[k-1]&#x3D;f[k-2]+f[k-3]</span><br><span class="line">                &#x2F;&#x2F;即f[k-1]的前面继续查找k--;</span><br><span class="line">                &#x2F;&#x2F;即下次循环mid&#x3D;f[k-1-1]-1;</span><br><span class="line">                k--;</span><br><span class="line">            &#125;else if(key&gt;temp[mid])&#123; &#x2F;&#x2F;说明向数组 的后面查找</span><br><span class="line">                low&#x3D;mid+1;</span><br><span class="line">                &#x2F;&#x2F;为什么是k-&#x3D;2,1.全部元素&#x3D;前面的元素+后边的元素</span><br><span class="line">                &#x2F;&#x2F;因为后面我们有f[k-2]个元素所以我们可以继续拆分</span><br><span class="line">                &#x2F;&#x2F;mid&#x3D;f[k-1-2]-1</span><br><span class="line">                k-&#x3D;2;</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                &#x2F;&#x2F;需要确定返回的是那个下标</span><br><span class="line">                if(mid&lt;&#x3D;high)&#123;</span><br><span class="line">                    return mid;</span><br><span class="line">                &#125;else&#123;</span><br><span class="line">                    return high;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;java实现插值查找和斐波那契查找算法&quot;&gt;&lt;a href=&quot;#java实现插值查找和斐波那契查找算法&quot; class=&quot;headerlink&quot; title=&quot;java实现插值查找和斐波那契查找算法&quot;&gt;&lt;/a&gt;java实现插值查找和斐波那契查找算法&lt;/h1&gt;&lt;h2 i
      
    
    </summary>
    
    
      <category term="数据结构" scheme="https://todcsw.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="学习" scheme="https://todcsw.github.io/tags/%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="java" scheme="https://todcsw.github.io/tags/java/"/>
    
      <category term="数据结构" scheme="https://todcsw.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>java实现顺序查找和二分查找</title>
    <link href="https://todcsw.github.io/2020/04/23/dataStructure-java%E5%AE%9E%E7%8E%B0%E9%A1%BA%E5%BA%8F%E6%9F%A5%E6%89%BE%E5%92%8C%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"/>
    <id>https://todcsw.github.io/2020/04/23/dataStructure-java%E5%AE%9E%E7%8E%B0%E9%A1%BA%E5%BA%8F%E6%9F%A5%E6%89%BE%E5%92%8C%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/</id>
    <published>2020-04-23T02:12:31.000Z</published>
    <updated>2020-05-08T08:28:38.605Z</updated>
    
    <content type="html"><![CDATA[<h1 id="java实现顺序查找和二分查找"><a href="#java实现顺序查找和二分查找" class="headerlink" title="java实现顺序查找和二分查找"></a>java实现顺序查找和二分查找</h1><h2 id="顺序查找"><a href="#顺序查找" class="headerlink" title="顺序查找"></a>顺序查找</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package com.csw.search;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * @Auther: 行路</span><br><span class="line"> * @Date: Created on 2020&#x2F;4&#x2F;23 8:57 星期三</span><br><span class="line"> * @Description: com.csw.search 顺序查找</span><br><span class="line"> * @version: 1.0</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class SeqSearch &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int[] arr&#x3D;&#123;1,9,11,-1,34,89&#125;;  &#x2F;&#x2F;没有顺序的数组</span><br><span class="line">        int index&#x3D;seqSearch(arr,11);</span><br><span class="line">        if(index&#x3D;&#x3D;-1)&#123;</span><br><span class="line">            System.out.println(&quot;没有找到&quot;);</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            System.out.println(&quot;找到,下标为&#x3D;&quot;+index);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 这里我们实现的线性查找是找到一个满足条件的值,就返回</span><br><span class="line">     * @param arr</span><br><span class="line">     * @param value</span><br><span class="line">     * @return</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public static int seqSearch(int[] arr,int value)&#123;</span><br><span class="line">        &#x2F;&#x2F;线性查找是逐一比对,发现有相同的值就返回下标</span><br><span class="line">        for(int i&#x3D;0;i&lt;arr.length;i++)&#123;</span><br><span class="line">            if(arr[i]&#x3D;&#x3D;value)&#123;</span><br><span class="line">                return i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package com.csw.search;</span><br><span class="line"></span><br><span class="line">import java.util.ArrayList;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * @Auther: 行路</span><br><span class="line"> * @Date: Created on 2020&#x2F;4&#x2F;23 9:09 星期三</span><br><span class="line"> * @Description: com.csw.search 二分查找</span><br><span class="line"> * @version: 1.0</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class BinarySearch &#123;</span><br><span class="line">    &#x2F;&#x2F;二分查找的前提是该数组必须是有序的</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int[] arr &#x3D; &#123;1, 8,10, 89, 1000, 1000,1000, 1234&#125;;</span><br><span class="line">        int resIndex &#x3D; binarySearch(arr, 0, arr.length - 1, 1000);</span><br><span class="line">        System.out.println(&quot;查找次数为:&quot;+count+&quot;,查找的下标为:&quot;+resIndex);</span><br><span class="line">        ArrayList&lt;Integer&gt; list &#x3D; binarySearch2(arr, 0, arr.length - 1, 1000);</span><br><span class="line">        System.out.println(list);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;二分查找</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * @param arr     数组</span><br><span class="line">     * @param left    左边的索引</span><br><span class="line">     * @param right   右边的索引</span><br><span class="line">     * @param findVal 要查找的值</span><br><span class="line">     * @return 如果找到返回下标, 如果没有找到, 就返回-1</span><br><span class="line">     *&#x2F;</span><br><span class="line"></span><br><span class="line">    public static int count&#x3D;0;</span><br><span class="line">    public static int binarySearch(int[] arr, int left, int right, int findVal) &#123;</span><br><span class="line">        &#x2F;&#x2F;当left&gt;right时,说明递归整个数组,但是没有找到</span><br><span class="line">        ++count;</span><br><span class="line">        if (left &gt; right) &#123;</span><br><span class="line">            return -1;</span><br><span class="line">        &#125;</span><br><span class="line">        int mid &#x3D; (left + right) &#x2F; 2;</span><br><span class="line">        int midVal &#x3D; arr[mid];</span><br><span class="line">        if (findVal &gt; midVal) &#123;</span><br><span class="line">            return binarySearch(arr, mid + 1, right, findVal); &#x2F;&#x2F;向右递归</span><br><span class="line">        &#125; else if (findVal &lt; midVal) &#123;</span><br><span class="line">            return binarySearch(arr, left, mid - 1, findVal);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return mid;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 课后思考题:当有多个相同的数值时,如何将所有的数组都查到,比如很多个1000</span><br><span class="line">     * 思路分析</span><br><span class="line">     * 1.找到mid值时,不马上返回</span><br><span class="line">     * 2.向mid索引值左边扫描,将所有满足1000的元素的下标,加入到集合ArrayList</span><br><span class="line">     * 3.向mid索引值的右边扫描,将所有满足1000,的元素下标,加入到ArrayList</span><br><span class="line">     *</span><br><span class="line">     * @param arr</span><br><span class="line">     * @param left</span><br><span class="line">     * @param right</span><br><span class="line">     * @param findVal</span><br><span class="line">     * @return</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public static ArrayList&lt;Integer&gt; binarySearch2(int[] arr, int left, int right, int findVal) &#123;</span><br><span class="line">        &#x2F;&#x2F;当left&gt;right时,说明递归整个数组,但是没有找到</span><br><span class="line">        if (left &gt; right) &#123;</span><br><span class="line">            return new ArrayList&lt;Integer&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">        int mid &#x3D; (left + right) &#x2F; 2;</span><br><span class="line">        int midVal &#x3D; arr[mid];</span><br><span class="line">        if (findVal &gt; midVal) &#123;</span><br><span class="line">            return binarySearch2(arr, mid + 1, right, findVal); &#x2F;&#x2F;向右递归</span><br><span class="line">        &#125; else if (findVal &lt; midVal) &#123;</span><br><span class="line">            return binarySearch2(arr, left, mid - 1, findVal);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            &#x2F;&#x2F;</span><br><span class="line">            ArrayList&lt;Integer&gt; resIndexList &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">            &#x2F;&#x2F;左边</span><br><span class="line">            int temp &#x3D; mid - 1;</span><br><span class="line">            while (true) &#123;</span><br><span class="line">                if (temp &lt; 0 || arr[temp] !&#x3D; findVal)&#123;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">                resIndexList.add(temp);</span><br><span class="line">                temp-&#x3D;1;  &#x2F;&#x2F;temp左移</span><br><span class="line">            &#125;</span><br><span class="line">            resIndexList.add(mid); &#x2F;&#x2F;中间</span><br><span class="line">            &#x2F;&#x2F;右边</span><br><span class="line">            temp&#x3D;mid+1;</span><br><span class="line">            while (true) &#123;</span><br><span class="line">                if (temp &gt;arr.length-1 || arr[temp] !&#x3D; findVal)&#123;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">                resIndexList.add(temp);</span><br><span class="line">                temp+&#x3D;1;  &#x2F;&#x2F;temp左移</span><br><span class="line">            &#125;</span><br><span class="line">            return resIndexList;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;java实现顺序查找和二分查找&quot;&gt;&lt;a href=&quot;#java实现顺序查找和二分查找&quot; class=&quot;headerlink&quot; title=&quot;java实现顺序查找和二分查找&quot;&gt;&lt;/a&gt;java实现顺序查找和二分查找&lt;/h1&gt;&lt;h2 id=&quot;顺序查找&quot;&gt;&lt;a href
      
    
    </summary>
    
    
      <category term="数据结构" scheme="https://todcsw.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="学习" scheme="https://todcsw.github.io/tags/%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="java" scheme="https://todcsw.github.io/tags/java/"/>
    
      <category term="数据结构" scheme="https://todcsw.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
</feed>
