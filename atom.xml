<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>行路のblog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://todcsw.github.io/"/>
  <updated>2020-05-01T08:17:56.619Z</updated>
  <id>https://todcsw.github.io/</id>
  
  <author>
    <name>Todcsw</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>java实现平衡二叉树(avl树)</title>
    <link href="https://todcsw.github.io/2020/05/01/java%E5%AE%9E%E7%8E%B0%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91-avl%E6%A0%91/"/>
    <id>https://todcsw.github.io/2020/05/01/java%E5%AE%9E%E7%8E%B0%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91-avl%E6%A0%91/</id>
    <published>2020-05-01T08:16:46.000Z</published>
    <updated>2020-05-01T08:17:56.619Z</updated>
    
    <content type="html"><![CDATA[<h1 id="java实现平衡二叉树-avl树"><a href="#java实现平衡二叉树-avl树" class="headerlink" title="java实现平衡二叉树(avl树)"></a>java实现平衡二叉树(avl树)</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package com.csw.tree;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * @Auther: 行路</span><br><span class="line"> * @Date: Created on 2020&#x2F;5&#x2F;1 14:12 星期五</span><br><span class="line"> * @Description: com.csw.tree 平衡二叉树</span><br><span class="line"> * @version: 1.0</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class AVLTreeDemo &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">&#x2F;&#x2F;        int[] arr &#x3D; &#123;10, 12, 8, 9, 7, 6&#125;;</span><br><span class="line"></span><br><span class="line">        int[] arr &#x3D; &#123;10, 11, 7, 6, 8, 9&#125;;</span><br><span class="line">        AVLTree avlTree &#x3D; new AVLTree();</span><br><span class="line">        &#x2F;&#x2F;添加节点</span><br><span class="line">        for (int i &#x3D; 0; i &lt; arr.length; i++) &#123;</span><br><span class="line">            avlTree.add(new Node1(arr[i]));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;中序遍历</span><br><span class="line">        avlTree.infixOrder();</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;没有平衡之前&quot;);</span><br><span class="line">        System.out.println(&quot;树的高度&#x3D;&quot; + avlTree.getRoot().height());</span><br><span class="line">        System.out.println(&quot;树的右子树高度&#x3D;&quot; + avlTree.getRoot().leftHeight());</span><br><span class="line">        System.out.println(&quot;书的右子树的高度&#x3D;&quot; + avlTree.getRoot().rightHeight());</span><br><span class="line">        System.out.println(&quot;当前根结点&quot; + avlTree.getRoot());</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;根结点的左子结点&quot;+avlTree.getRoot().right.left);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;创建AVL树</span><br><span class="line">class AVLTree &#123;</span><br><span class="line">    private Node1 root;</span><br><span class="line"></span><br><span class="line">    public Node1 getRoot() &#123;</span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setRoot(Node1 root) &#123;</span><br><span class="line">        this.root &#x3D; root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;查找要删除的结点</span><br><span class="line">    public Node1 search(int value) &#123;</span><br><span class="line">        if (root &#x3D;&#x3D; null) &#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return root.search(value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;查找父结点</span><br><span class="line">    public Node1 searchParent(int value) &#123;</span><br><span class="line">        if (root &#x3D;&#x3D; null) &#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return root.searchParent(value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 方法:返回以Node1为根结点的二叉排序树的最小结点的值</span><br><span class="line">     * 2.删除Node1,为根结点的二叉排序树的最小结点</span><br><span class="line">     *</span><br><span class="line">     * @param Node1 传入的结点,当作一个二叉排序树的根结点</span><br><span class="line">     * @return 返回的以Node1为根结点的二叉排序树的最小结点的值</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public int delRightTreeMin(Node1 Node1) &#123;</span><br><span class="line">        Node1 target &#x3D; Node1;</span><br><span class="line">        &#x2F;&#x2F;循环的查找左结点，找到最小的结点</span><br><span class="line">        while (target.left !&#x3D; null) &#123;</span><br><span class="line">            target &#x3D; target.left;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;这时target就指向了最小结点</span><br><span class="line">        &#x2F;&#x2F;删除最小结点</span><br><span class="line">        delNode1(target.value);</span><br><span class="line">        return target.value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;删除结点</span><br><span class="line">    public void delNode1(int value) &#123;</span><br><span class="line">        if (root &#x3D;&#x3D; null) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            &#x2F;&#x2F;1.需要先去找到要删除的结点 targetNode1</span><br><span class="line">            Node1 targetNode1 &#x3D; search(value);</span><br><span class="line">            &#x2F;&#x2F;如果没有找到要删除的结点</span><br><span class="line">            if (targetNode1 &#x3D;&#x3D; null) &#123;</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F;如果我们发现当前这颗二叉排序树只有一个结点</span><br><span class="line">            if (root.left &#x3D;&#x3D; null &amp;&amp; root.right &#x3D;&#x3D; null) &#123;</span><br><span class="line">                root &#x3D; null;</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F;去查找targetNode1的父结点</span><br><span class="line">            Node1 parent &#x3D; searchParent(value);</span><br><span class="line">            &#x2F;&#x2F;如果要删除的结点是叶子结点</span><br><span class="line">            if (targetNode1.left &#x3D;&#x3D; null &amp;&amp; targetNode1.right &#x3D;&#x3D; null) &#123;</span><br><span class="line">                &#x2F;&#x2F;判断targetNode1是父结点的左子结点还是右子结点</span><br><span class="line">                if (parent.left !&#x3D; null &amp;&amp; parent.left.value &#x3D;&#x3D; value) &#123; &#x2F;&#x2F;左子结点</span><br><span class="line">                    parent.left &#x3D; null;</span><br><span class="line">                &#125; else if (parent.right !&#x3D; null &amp;&amp; parent.right.value &#x3D;&#x3D; value) &#123; &#x2F;&#x2F;右子结点</span><br><span class="line">                    parent.right &#x3D; null;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else if (targetNode1.left !&#x3D; null &amp;&amp; targetNode1.right !&#x3D; null) &#123;</span><br><span class="line">                &#x2F;&#x2F;删除有两颗子树的节点</span><br><span class="line">                int minVal &#x3D; delRightTreeMin(targetNode1.right);</span><br><span class="line">                targetNode1.value &#x3D; minVal;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                &#x2F;&#x2F;删除只有一棵子树的结点</span><br><span class="line">                &#x2F;&#x2F;如果要删除的结点有左子结点</span><br><span class="line">                if (targetNode1.left !&#x3D; null) &#123;</span><br><span class="line">                    if (parent !&#x3D; null) &#123;</span><br><span class="line">                        &#x2F;&#x2F;如果targetNode1是parent的左子结点</span><br><span class="line">                        if (parent.left.value &#x3D;&#x3D; value) &#123;</span><br><span class="line">                            parent.left &#x3D; targetNode1.left;</span><br><span class="line">                        &#125; else &#123;</span><br><span class="line">                            &#x2F;&#x2F;target是parent的右子结点</span><br><span class="line">                            parent.right &#x3D; targetNode1.left;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        root &#x3D; targetNode1.left;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; else &#123; &#x2F;&#x2F;如果要删除的结点有右子结点</span><br><span class="line">                    if (parent !&#x3D; null) &#123;</span><br><span class="line">                        if (parent.left.value &#x3D;&#x3D; value) &#123;</span><br><span class="line">                            parent.left &#x3D; targetNode1.right;</span><br><span class="line">                        &#125; else &#123;</span><br><span class="line">                            &#x2F;&#x2F;如果targetNode1是parent的右子结点</span><br><span class="line">                            parent.right &#x3D; targetNode1.right;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        root &#x3D; targetNode1.right;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;添加节点的方法</span><br><span class="line">    public void add(Node1 Node1) &#123;</span><br><span class="line">        if (root &#x3D;&#x3D; null) &#123;</span><br><span class="line">            root &#x3D; Node1;  &#x2F;&#x2F;如果root为空值,直接让root指向Node1节点</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            root.add(Node1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;中序遍历</span><br><span class="line">    public void infixOrder() &#123;</span><br><span class="line">        if (root !&#x3D; null) &#123;</span><br><span class="line">            root.infixOrder();</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            System.out.println(&quot;二叉排序树为空&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;创建Node1节点</span><br><span class="line">class Node1 &#123;</span><br><span class="line">    int value;</span><br><span class="line">    Node1 left;</span><br><span class="line">    Node1 right;</span><br><span class="line"></span><br><span class="line">    public Node1(int value) &#123;</span><br><span class="line">        this.value &#x3D; value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;返回左子树的高度</span><br><span class="line">    public int leftHeight() &#123;</span><br><span class="line">        if (left &#x3D;&#x3D; null) &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        return left.height();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;返回右子树的高度</span><br><span class="line">    public int rightHeight() &#123;</span><br><span class="line">        if (right &#x3D;&#x3D; null) &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        return right.height();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;返回当前节点的高度,以该结点为根节点的树的高度</span><br><span class="line">    public int height() &#123;</span><br><span class="line">        return Math.max(left &#x3D;&#x3D; null ? 0 : left.height(), right &#x3D;&#x3D; null ? 0 : right.height()) + 1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;左旋转方法</span><br><span class="line">    private void leftRotate() &#123;</span><br><span class="line">        &#x2F;&#x2F;创建新的结点,以当前结点的值</span><br><span class="line">        Node1 newNode &#x3D; new Node1(value);</span><br><span class="line">        &#x2F;&#x2F;把新的结点的左子树设置成当前结点的左子树</span><br><span class="line">        newNode.left &#x3D; left;</span><br><span class="line">        &#x2F;&#x2F;把更新的结点的右子树设置成带你过去结点的右子树</span><br><span class="line">        newNode.right &#x3D; right.left;</span><br><span class="line">        &#x2F;&#x2F;把当前结点的值替换成右子结点的值</span><br><span class="line">        value &#x3D; right.value;</span><br><span class="line">        &#x2F;&#x2F;把当前结点的右子树设置成右子树的右子树</span><br><span class="line">        right &#x3D; right.right;</span><br><span class="line">        &#x2F;&#x2F;把当前结点的左子树(左子结点)设置成新的结点</span><br><span class="line">        left &#x3D; newNode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;右旋转</span><br><span class="line">    private void rightRotate() &#123;</span><br><span class="line">        Node1 newNode &#x3D; new Node1(value);</span><br><span class="line">        newNode.right &#x3D; right;</span><br><span class="line">        newNode.left &#x3D; left.right;</span><br><span class="line">        value &#x3D; left.value;</span><br><span class="line">        left &#x3D; left.left;</span><br><span class="line">        right &#x3D; newNode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 查找要删除的结点</span><br><span class="line">     *</span><br><span class="line">     * @param value 希望删除结点的值</span><br><span class="line">     * @return 如果找到返回该结点的值.否则返回Null</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public Node1 search(int value) &#123;</span><br><span class="line">        if (value &#x3D;&#x3D; this.value) &#123;</span><br><span class="line">            &#x2F;&#x2F;找到就是该点</span><br><span class="line">            return this;</span><br><span class="line">        &#125; else if (value &lt; this.value) &#123;</span><br><span class="line">            &#x2F;&#x2F;如果查找的值小于当前结点,向左子树递归查找</span><br><span class="line">            if (this.left &#x3D;&#x3D; null) &#123;</span><br><span class="line">                return null;</span><br><span class="line">            &#125;</span><br><span class="line">            return this.left.search(value);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            &#x2F;&#x2F;如果查找的值不小于当前结点,向右子树递归查找</span><br><span class="line">            if (this.right &#x3D;&#x3D; null) &#123;</span><br><span class="line">                return null;</span><br><span class="line">            &#125;</span><br><span class="line">            return this.right.search(value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 查找要删除结点的父结点</span><br><span class="line">     *</span><br><span class="line">     * @param value 要找的结点的值</span><br><span class="line">     * @return 返回的时要删除结点的父结点, 如果没有就返回null</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public Node1 searchParent(int value) &#123;</span><br><span class="line">        &#x2F;&#x2F;如果当前结点就是要删除结点的父结点,就返回</span><br><span class="line">        if ((this.left !&#x3D; null &amp;&amp; this.left.value &#x3D;&#x3D; value) || (this.right !&#x3D; null &amp;&amp; this.right.value &#x3D;&#x3D; value)) &#123;</span><br><span class="line">            return this;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            &#x2F;&#x2F;如果查找的值小于当前结点的值,并且当前结点的左子结点不为空</span><br><span class="line">            if (value &lt; this.value &amp;&amp; this.left !&#x3D; null) &#123;</span><br><span class="line">                return this.left.searchParent(value);</span><br><span class="line">            &#125; else if (value &gt;&#x3D; this.value &amp;&amp; this.right !&#x3D; null) &#123;</span><br><span class="line">                return this.right.searchParent(value);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                return null; &#x2F;&#x2F;没有找到父结点</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return &quot;Node1&#123;&quot; +</span><br><span class="line">                &quot;value&#x3D;&quot; + value +</span><br><span class="line">                &#39;&#125;&#39;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 添加结点方法</span><br><span class="line">     * 递归的形式添加结点,需要满足二叉排序树</span><br><span class="line">     *</span><br><span class="line">     * @param Node1</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public void add(Node1 Node1) &#123;</span><br><span class="line">        if (Node1 &#x3D;&#x3D; null) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;判断传入的节点的值,和当前根节点的值关系</span><br><span class="line">        if (Node1.value &lt; this.value) &#123;</span><br><span class="line">            &#x2F;&#x2F;当前节点的左子节点为null</span><br><span class="line">            if (this.left &#x3D;&#x3D; null) &#123;</span><br><span class="line">                this.left &#x3D; Node1;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                &#x2F;&#x2F;递归的向左子树添加</span><br><span class="line">                this.left.add(Node1);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123; &#x2F;&#x2F;添加的节点的值大于当前节点的值</span><br><span class="line">            if (this.right &#x3D;&#x3D; null) &#123;</span><br><span class="line">                this.right &#x3D; Node1;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                this.right.add(Node1);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;当添加完一个结点后,如果右子树的高度比左子树的高度&gt;1 发生左旋转</span><br><span class="line">        if (rightHeight() - leftHeight() &gt; 1) &#123;</span><br><span class="line">            &#x2F;&#x2F;如果它的右子树的左子树的高度大于它的右子树的右子树高度</span><br><span class="line">            if (right !&#x3D; null &amp;&amp; right.leftHeight() &gt; right.rightHeight()) &#123;</span><br><span class="line">                &#x2F;&#x2F;先对右子结点进行右旋转</span><br><span class="line">                right.rightRotate();</span><br><span class="line">                &#x2F;&#x2F;然后在对当前结点进行左旋转</span><br><span class="line">                leftRotate();</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                &#x2F;&#x2F;直接进行左旋转</span><br><span class="line">                leftRotate();</span><br><span class="line">            &#125;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;当添加完一个结点后,如果左子树的高度-右子树的高度&gt;1 ,右旋转</span><br><span class="line">        if (leftHeight() - rightHeight() &gt; 1) &#123;</span><br><span class="line">            if (left !&#x3D; null &amp;&amp; left.rightHeight() &gt; left.leftHeight()) &#123;</span><br><span class="line">                &#x2F;&#x2F;先对当前结点的左结点 左子树 （右旋转）</span><br><span class="line">                left.leftRotate();</span><br><span class="line">                rightRotate();</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                &#x2F;&#x2F;直接进行右旋转</span><br><span class="line">                rightRotate();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;中序遍历</span><br><span class="line">    public void infixOrder() &#123;</span><br><span class="line">        if (this.left !&#x3D; null) &#123;</span><br><span class="line">            this.left.infixOrder();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(this);</span><br><span class="line">        if (this.right !&#x3D; null) &#123;</span><br><span class="line">            this.right.infixOrder();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;java实现平衡二叉树-avl树&quot;&gt;&lt;a href=&quot;#java实现平衡二叉树-avl树&quot; class=&quot;headerlink&quot; title=&quot;java实现平衡二叉树(avl树)&quot;&gt;&lt;/a&gt;java实现平衡二叉树(avl树)&lt;/h1&gt;&lt;figure class=&quot;
      
    
    </summary>
    
    
      <category term="数据结构" scheme="https://todcsw.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="学习" scheme="https://todcsw.github.io/tags/%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="java" scheme="https://todcsw.github.io/tags/java/"/>
    
      <category term="数据结构" scheme="https://todcsw.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>java实现二叉排序树</title>
    <link href="https://todcsw.github.io/2020/04/30/java%E5%AE%9E%E7%8E%B0%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91/"/>
    <id>https://todcsw.github.io/2020/04/30/java%E5%AE%9E%E7%8E%B0%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91/</id>
    <published>2020-04-30T04:32:25.000Z</published>
    <updated>2020-05-01T08:17:55.385Z</updated>
    
    <content type="html"><![CDATA[<h1 id="java实现二叉排序树"><a href="#java实现二叉排序树" class="headerlink" title="java实现二叉排序树"></a>java实现二叉排序树</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package com.csw.tree;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * @Auther: 行路</span><br><span class="line"> * @Date: Created on 2020&#x2F;4&#x2F;30 10:56 星期四</span><br><span class="line"> * @Description: com.csw.tree 二叉排序树</span><br><span class="line"> * @version: 1.0</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class BinarySortTreeDemo &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int[] arr &#x3D; &#123;7, 3, 10, 12, 5, 1, 9, 2&#125;;</span><br><span class="line">        BinarySortTree binarySortTree &#x3D; new BinarySortTree();</span><br><span class="line">        &#x2F;&#x2F;循环的添加节点到二叉排序树</span><br><span class="line">        for (int i &#x3D; 0; i &lt; arr.length; i++) &#123;</span><br><span class="line">            binarySortTree.add(new Node(arr[i]));</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;中序遍历二叉树</span><br><span class="line">        System.out.println(&quot;中序遍历二叉树结果&quot;);</span><br><span class="line">        binarySortTree.infixOrder();</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;测试删除叶子结点&quot;);</span><br><span class="line"></span><br><span class="line">        binarySortTree.delNode(10);</span><br><span class="line"></span><br><span class="line">        binarySortTree.infixOrder();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;创建二叉排序树</span><br><span class="line">class BinarySortTree &#123;</span><br><span class="line">    private Node root;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;查找要删除的结点</span><br><span class="line">    public Node search(int value) &#123;</span><br><span class="line">        if (root &#x3D;&#x3D; null) &#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return root.search(value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;查找父结点</span><br><span class="line">    public Node searchParent(int value) &#123;</span><br><span class="line">        if (root &#x3D;&#x3D; null) &#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return root.searchParent(value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 方法:返回以node为根结点的二叉排序树的最小结点的值</span><br><span class="line">     * 2.删除node,为根结点的二叉排序树的最小结点</span><br><span class="line">     *</span><br><span class="line">     * @param node 传入的结点,当作一个二叉排序树的根结点</span><br><span class="line">     * @return 返回的以node为根结点的二叉排序树的最小结点的值</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public int delRightTreeMin(Node node) &#123;</span><br><span class="line">        Node target &#x3D; node;</span><br><span class="line">        &#x2F;&#x2F;循环的查找左结点，找到最小的结点</span><br><span class="line">        while (target.left !&#x3D; null) &#123;</span><br><span class="line">            target &#x3D; target.left;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;这时target就指向了最小结点</span><br><span class="line">        &#x2F;&#x2F;删除最小结点</span><br><span class="line">        delNode(target.value);</span><br><span class="line">        return target.value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;删除结点</span><br><span class="line">    public void delNode(int value) &#123;</span><br><span class="line">        if (root &#x3D;&#x3D; null) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            &#x2F;&#x2F;1.需要先去找到要删除的结点 targetNode</span><br><span class="line">            Node targetNode &#x3D; search(value);</span><br><span class="line">            &#x2F;&#x2F;如果没有找到要删除的结点</span><br><span class="line">            if (targetNode &#x3D;&#x3D; null) &#123;</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F;如果我们发现当前这颗二叉排序树只有一个结点</span><br><span class="line">            if (root.left &#x3D;&#x3D; null &amp;&amp; root.right &#x3D;&#x3D; null) &#123;</span><br><span class="line">                root &#x3D; null;</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F;去查找targetNode的父结点</span><br><span class="line">            Node parent &#x3D; searchParent(value);</span><br><span class="line">            &#x2F;&#x2F;如果要删除的结点是叶子结点</span><br><span class="line">            if (targetNode.left &#x3D;&#x3D; null &amp;&amp; targetNode.right &#x3D;&#x3D; null) &#123;</span><br><span class="line">                &#x2F;&#x2F;判断targetNode是父结点的左子结点还是右子结点</span><br><span class="line">                if (parent.left !&#x3D; null &amp;&amp; parent.left.value &#x3D;&#x3D; value) &#123; &#x2F;&#x2F;左子结点</span><br><span class="line">                    parent.left &#x3D; null;</span><br><span class="line">                &#125; else if (parent.right !&#x3D; null &amp;&amp; parent.right.value &#x3D;&#x3D; value) &#123; &#x2F;&#x2F;右子结点</span><br><span class="line">                    parent.right &#x3D; null;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else if (targetNode.left !&#x3D; null &amp;&amp; targetNode.right !&#x3D; null) &#123;</span><br><span class="line">                &#x2F;&#x2F;删除有两颗子树的节点</span><br><span class="line">                int minVal &#x3D; delRightTreeMin(targetNode.right);</span><br><span class="line">                targetNode.value &#x3D; minVal;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                &#x2F;&#x2F;删除只有一棵子树的结点</span><br><span class="line">                &#x2F;&#x2F;如果要删除的结点有左子结点</span><br><span class="line">                if (targetNode.left !&#x3D; null) &#123;</span><br><span class="line">                    if (parent !&#x3D; null) &#123;</span><br><span class="line">                        &#x2F;&#x2F;如果targetNode是parent的左子结点</span><br><span class="line">                        if (parent.left.value &#x3D;&#x3D; value) &#123;</span><br><span class="line">                            parent.left &#x3D; targetNode.left;</span><br><span class="line">                        &#125; else &#123;</span><br><span class="line">                            &#x2F;&#x2F;target是parent的右子结点</span><br><span class="line">                            parent.right &#x3D; targetNode.left;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        root &#x3D; targetNode.left;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; else &#123; &#x2F;&#x2F;如果要删除的结点有右子结点</span><br><span class="line">                    if (parent !&#x3D; null) &#123;</span><br><span class="line">                        if (parent.left.value &#x3D;&#x3D; value) &#123;</span><br><span class="line">                            parent.left &#x3D; targetNode.right;</span><br><span class="line">                        &#125; else &#123;</span><br><span class="line">                            &#x2F;&#x2F;如果targetNode是parent的右子结点</span><br><span class="line">                            parent.right &#x3D; targetNode.right;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        root &#x3D; targetNode.right;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;添加节点的方法</span><br><span class="line">    public void add(Node node) &#123;</span><br><span class="line">        if (root &#x3D;&#x3D; null) &#123;</span><br><span class="line">            root &#x3D; node;  &#x2F;&#x2F;如果root为空值,直接让root指向node节点</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            root.add(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;中序遍历</span><br><span class="line">    public void infixOrder() &#123;</span><br><span class="line">        if (root !&#x3D; null) &#123;</span><br><span class="line">            root.infixOrder();</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            System.out.println(&quot;二叉排序树为空&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;创建node节点</span><br><span class="line">class Node &#123;</span><br><span class="line">    int value;</span><br><span class="line">    Node left;</span><br><span class="line">    Node right;</span><br><span class="line"></span><br><span class="line">    public Node(int value) &#123;</span><br><span class="line">        this.value &#x3D; value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 查找要删除的结点</span><br><span class="line">     *</span><br><span class="line">     * @param value 希望删除结点的值</span><br><span class="line">     * @return 如果找到返回该结点的值.否则返回Null</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public Node search(int value) &#123;</span><br><span class="line">        if (value &#x3D;&#x3D; this.value) &#123;</span><br><span class="line">            &#x2F;&#x2F;找到就是该点</span><br><span class="line">            return this;</span><br><span class="line">        &#125; else if (value &lt; this.value) &#123;</span><br><span class="line">            &#x2F;&#x2F;如果查找的值小于当前结点,向左子树递归查找</span><br><span class="line">            if (this.left &#x3D;&#x3D; null) &#123;</span><br><span class="line">                return null;</span><br><span class="line">            &#125;</span><br><span class="line">            return this.left.search(value);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            &#x2F;&#x2F;如果查找的值不小于当前结点,向右子树递归查找</span><br><span class="line">            if (this.right &#x3D;&#x3D; null) &#123;</span><br><span class="line">                return null;</span><br><span class="line">            &#125;</span><br><span class="line">            return this.right.search(value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 查找要删除结点的父结点</span><br><span class="line">     *</span><br><span class="line">     * @param value 要找的结点的值</span><br><span class="line">     * @return 返回的时要删除结点的父结点, 如果没有就返回null</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public Node searchParent(int value) &#123;</span><br><span class="line">        &#x2F;&#x2F;如果当前结点就是要删除结点的父结点,就返回</span><br><span class="line">        if ((this.left !&#x3D; null &amp;&amp; this.left.value &#x3D;&#x3D; value) || (this.right !&#x3D; null &amp;&amp; this.right.value &#x3D;&#x3D; value)) &#123;</span><br><span class="line">            return this;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            &#x2F;&#x2F;如果查找的值小于当前结点的值,并且当前结点的左子结点不为空</span><br><span class="line">            if (value &lt; this.value &amp;&amp; this.left !&#x3D; null) &#123;</span><br><span class="line">                return this.left.searchParent(value);</span><br><span class="line">            &#125; else if (value &gt;&#x3D; this.value &amp;&amp; this.right !&#x3D; null) &#123;</span><br><span class="line">                return this.right.searchParent(value);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                return null; &#x2F;&#x2F;没有找到父结点</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return &quot;Node&#123;&quot; +</span><br><span class="line">                &quot;value&#x3D;&quot; + value +</span><br><span class="line">                &#39;&#125;&#39;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 添加结点方法</span><br><span class="line">     * 递归的形式添加结点,需要满足二叉排序树</span><br><span class="line">     *</span><br><span class="line">     * @param node</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public void add(Node node) &#123;</span><br><span class="line">        if (node &#x3D;&#x3D; null) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;判断传入的节点的值,和当前根节点的值关系</span><br><span class="line">        if (node.value &lt; this.value) &#123;</span><br><span class="line">            &#x2F;&#x2F;当前节点的左子节点为null</span><br><span class="line">            if (this.left &#x3D;&#x3D; null) &#123;</span><br><span class="line">                this.left &#x3D; node;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                &#x2F;&#x2F;递归的向左子树添加</span><br><span class="line">                this.left.add(node);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123; &#x2F;&#x2F;添加的节点的值大于当前节点的值</span><br><span class="line">            if (this.right &#x3D;&#x3D; null) &#123;</span><br><span class="line">                this.right &#x3D; node;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                this.right.add(node);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;中序遍历</span><br><span class="line">    public void infixOrder() &#123;</span><br><span class="line">        if (this.left !&#x3D; null) &#123;</span><br><span class="line">            this.left.infixOrder();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(this);</span><br><span class="line">        if (this.right !&#x3D; null) &#123;</span><br><span class="line">            this.right.infixOrder();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;java实现二叉排序树&quot;&gt;&lt;a href=&quot;#java实现二叉排序树&quot; class=&quot;headerlink&quot; title=&quot;java实现二叉排序树&quot;&gt;&lt;/a&gt;java实现二叉排序树&lt;/h1&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;tabl
      
    
    </summary>
    
    
      <category term="数据结构" scheme="https://todcsw.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="学习" scheme="https://todcsw.github.io/tags/%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="java" scheme="https://todcsw.github.io/tags/java/"/>
    
      <category term="数据结构" scheme="https://todcsw.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>java实现赫夫曼编码的压缩和解压</title>
    <link href="https://todcsw.github.io/2020/04/29/java%E5%AE%9E%E7%8E%B0%E8%B5%AB%E5%A4%AB%E6%9B%BC%E7%BC%96%E7%A0%81%E7%9A%84%E5%8E%8B%E7%BC%A9%E5%92%8C%E8%A7%A3%E5%8E%8B/"/>
    <id>https://todcsw.github.io/2020/04/29/java%E5%AE%9E%E7%8E%B0%E8%B5%AB%E5%A4%AB%E6%9B%BC%E7%BC%96%E7%A0%81%E7%9A%84%E5%8E%8B%E7%BC%A9%E5%92%8C%E8%A7%A3%E5%8E%8B/</id>
    <published>2020-04-29T13:43:23.000Z</published>
    <updated>2020-05-01T08:18:08.674Z</updated>
    
    <content type="html"><![CDATA[<h1 id="赫夫曼编码的压缩和解压"><a href="#赫夫曼编码的压缩和解压" class="headerlink" title="赫夫曼编码的压缩和解压"></a>赫夫曼编码的压缩和解压</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package com.csw.huffmantree;</span><br><span class="line"></span><br><span class="line">import java.io.*;</span><br><span class="line">import java.util.*;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * @Auther: 行路</span><br><span class="line"> * @Date: Created on 2020&#x2F;4&#x2F;29 20:11 星期三</span><br><span class="line"> * @Description: com.csw.huffmantree 赫夫曼编码的压缩和解压</span><br><span class="line"> * @version: 1.0</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class HuffmanCode &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        String content &#x3D; &quot;i like like like java do you like a java&quot;;</span><br><span class="line">        byte[] contentBytes &#x3D; content.getBytes();</span><br><span class="line">        System.out.println(contentBytes.length);</span><br><span class="line"></span><br><span class="line">        byte[] huffmanCodeBytes &#x3D; huffmanZip(contentBytes);</span><br><span class="line">        System.out.println(&quot;压缩后的结果:&quot; + Arrays.toString(huffmanCodeBytes) + &quot;长度&#x3D;&quot; + huffmanCodeBytes.length);</span><br><span class="line"></span><br><span class="line">        byte[] bytes &#x3D; decode(huffmanCodes, huffmanCodeBytes);</span><br><span class="line">        System.out.println(&quot;原来的字符串&#x3D;&quot; + new String(bytes));</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;测试压缩文件的代码</span><br><span class="line">        zipFile(&quot;d:&#x2F;&#x2F;src.bmp&quot;, &quot;d:&#x2F;&#x2F;src.hhh&quot;);</span><br><span class="line">        &#x2F;&#x2F;测试解压文件</span><br><span class="line">        unZipFile(&quot;d:&#x2F;&#x2F;dst.zip&quot;,&quot;d:&#x2F;&#x2F;src2.bmp&quot;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#x2F;*分步过程</span><br><span class="line">        List&lt;Node1&gt; nodes &#x3D; getNodes(contentBytes);</span><br><span class="line">        System.out.println(nodes);</span><br><span class="line">        System.out.println(&quot;测试创建的二叉树~~~~~哈夫曼树&quot;);</span><br><span class="line">        Node1 root &#x3D; createHuffmanTree(nodes);</span><br><span class="line">        System.out.println(&quot;前序遍历&quot;);</span><br><span class="line">        root.preOrder();</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;测试生成了对应的赫夫曼编码</span><br><span class="line">        getCodes(root);</span><br><span class="line">        System.out.println(&quot;生成的赫夫曼编码表&quot; + huffmanCodes);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;测试</span><br><span class="line">        byte[] huffmanCodeBytes &#x3D; zip(contentBytes, huffmanCodes);</span><br><span class="line">        System.out.println(&quot;huffmanCodeBytes&#x3D;&quot;+Arrays.toString(huffmanCodeBytes));</span><br><span class="line">        *&#x2F;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 编写一个方法,完成对压缩文件的解压</span><br><span class="line">     *</span><br><span class="line">     * @param zipFile 准备解压的文件</span><br><span class="line">     * @param dstFile 将文件解压到那个路径</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public static void unZipFile(String zipFile, String dstFile) &#123;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;定义文件输入流</span><br><span class="line">        InputStream is &#x3D; null;</span><br><span class="line">        &#x2F;&#x2F;定义一个对象输入流</span><br><span class="line">        ObjectInputStream ois &#x3D; null;</span><br><span class="line">        &#x2F;&#x2F;定义文件输出流</span><br><span class="line">        OutputStream os &#x3D; null;</span><br><span class="line">        try &#123;</span><br><span class="line">            &#x2F;&#x2F;创建文件输入流</span><br><span class="line">            is &#x3D; new FileInputStream(zipFile);</span><br><span class="line">            &#x2F;&#x2F;创建一个和is关联的对象输入流</span><br><span class="line">            ois &#x3D; new ObjectInputStream(is);</span><br><span class="line">            &#x2F;&#x2F;读取byte数组 huffmanBytes</span><br><span class="line">            byte[] huffmanBytes &#x3D; (byte[]) ois.readObject();</span><br><span class="line">            &#x2F;&#x2F;读取赫夫曼编码表</span><br><span class="line">            Map&lt;Byte, String&gt; huffmanCodes &#x3D; (Map&lt;Byte, String&gt;) ois.readObject();</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F;解码</span><br><span class="line">            byte[] bytes &#x3D; decode(huffmanCodes, huffmanBytes);</span><br><span class="line">            &#x2F;&#x2F;将bytes数组写入目标文件</span><br><span class="line">            os &#x3D; new FileOutputStream(dstFile);</span><br><span class="line">            &#x2F;&#x2F;写数据到文件中</span><br><span class="line">            os.write(bytes);</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                os.close();</span><br><span class="line">                ois.close();</span><br><span class="line">                is.close();</span><br><span class="line">            &#125; catch (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 编写方法,将一个文件进行压缩</span><br><span class="line">     *</span><br><span class="line">     * @param srcFile 你写入希望压缩文件的全路径</span><br><span class="line">     * @param dstFile 压缩文件放入那个目录</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public static void zipFile(String srcFile, String dstFile) &#123;</span><br><span class="line">        &#x2F;&#x2F;创建输入输出流</span><br><span class="line">        FileInputStream is &#x3D; null;</span><br><span class="line">        FileOutputStream os &#x3D; null;</span><br><span class="line">        ObjectOutputStream oos &#x3D; null;</span><br><span class="line">        &#x2F;&#x2F;创建文件的输入流</span><br><span class="line">        try &#123;</span><br><span class="line">            is &#x3D; new FileInputStream(srcFile);</span><br><span class="line">            &#x2F;&#x2F;创建一个和原文件大小一样的数组</span><br><span class="line">            byte[] b &#x3D; new byte[is.available()];</span><br><span class="line">            &#x2F;&#x2F;读取文件</span><br><span class="line">            is.read(b);</span><br><span class="line">            &#x2F;&#x2F;读取文件对应赫夫曼编码表</span><br><span class="line">            &#x2F;&#x2F;直接对源文件进行压缩</span><br><span class="line">            byte[] huffmanBytes &#x3D; huffmanZip(b);</span><br><span class="line">            os &#x3D; new FileOutputStream(dstFile);</span><br><span class="line">            &#x2F;&#x2F;创建一个和文件输出流相关联的objectOutputStream</span><br><span class="line">            oos &#x3D; new ObjectOutputStream(os);</span><br><span class="line">            &#x2F;&#x2F;把赫夫曼编码后的字节数组写入压缩文件</span><br><span class="line">            oos.writeObject(huffmanBytes);</span><br><span class="line">            &#x2F;&#x2F;以对象流的方式写进赫夫曼编码,为了我们恢复源文件时使用，</span><br><span class="line">            &#x2F;&#x2F;注意赫夫曼编码写入压缩文件</span><br><span class="line">            oos.writeObject(huffmanCodes);</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                is.close();</span><br><span class="line">                oos.close();</span><br><span class="line">                os.close();</span><br><span class="line">            &#125; catch (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;完成数据的解压 思路</span><br><span class="line">    &#x2F;&#x2F;1.将huffmanCodeBytes[-88, -65, -56, -65, -56, -65, -55, 77, -57, 6, -24, -14, -117, -4, -60, -90, 28]</span><br><span class="line">    &#x2F;&#x2F;重写先转成赫夫曼对应的二进制的字符串“1010100010111...”</span><br><span class="line">    &#x2F;&#x2F;2.赫夫曼编码对应的二进制的字符串“1010100010111...”&#x3D;》对照赫夫曼编码&#x3D;》 “i like like like java do you like ”</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 编写方法,完成对压缩数据的编码</span><br><span class="line">     *</span><br><span class="line">     * @param huffmanCodes 赫夫曼编码表</span><br><span class="line">     * @param huffmanBytes 赫夫曼编码得到的字节数组</span><br><span class="line">     * @return 就是原来的字符串对应的数组</span><br><span class="line">     *&#x2F;</span><br><span class="line">    private static byte[] decode(Map&lt;Byte, String&gt; huffmanCodes, byte[] huffmanBytes) &#123;</span><br><span class="line">        &#x2F;&#x2F;先得到huffmanBytes,对应的二进制字符串 形式1010100000</span><br><span class="line">        StringBuilder stringBuilder &#x3D; new StringBuilder();</span><br><span class="line">        &#x2F;&#x2F;将byte数组转成二进制字符串</span><br><span class="line">        for (int i &#x3D; 0; i &lt; huffmanBytes.length; i++) &#123;</span><br><span class="line">            byte b &#x3D; huffmanBytes[i];</span><br><span class="line">            &#x2F;&#x2F;判断是不是最后一个字节</span><br><span class="line">            boolean flag &#x3D; (i &#x3D;&#x3D; huffmanBytes.length - 1);</span><br><span class="line">            stringBuilder.append(byteToBitString(flag, b));</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;把字符串按照指定的赫夫曼编码就行解码</span><br><span class="line">        &#x2F;&#x2F;把赫夫曼编码进行交换,因为反向查询</span><br><span class="line">        Map&lt;String, Byte&gt; map &#x3D; new HashMap&lt;&gt;();</span><br><span class="line">        for (Map.Entry&lt;Byte, String&gt; entry : huffmanCodes.entrySet()) &#123;</span><br><span class="line">            map.put(entry.getValue(), entry.getKey());</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;创建集合存放byte</span><br><span class="line">        List&lt;Byte&gt; list &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">        &#x2F;&#x2F;可以理解位索引</span><br><span class="line">        for (int i &#x3D; 0; i &lt; stringBuilder.length(); ) &#123;</span><br><span class="line">            int count &#x3D; 1; &#x2F;&#x2F;小的计数器</span><br><span class="line">            boolean flag &#x3D; true;</span><br><span class="line">            Byte b &#x3D; null;</span><br><span class="line">            while (flag) &#123;</span><br><span class="line">                &#x2F;&#x2F;递增的取出</span><br><span class="line">                String key &#x3D; stringBuilder.substring(i, i + count); &#x2F;&#x2F;i不动,让count移动,指定匹配道的字符</span><br><span class="line">                b &#x3D; map.get(key);</span><br><span class="line">                if (b &#x3D;&#x3D; null) &#123;</span><br><span class="line">                    &#x2F;&#x2F;说明没有匹配道</span><br><span class="line">                    count++;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    flag &#x3D; false;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            list.add(b);</span><br><span class="line">            i +&#x3D; count; &#x2F;&#x2F;i直接移动到count</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;当for循环结束后,这个list存放了所有字符</span><br><span class="line">        &#x2F;&#x2F;把list中的数据放入到byte[] 并返回</span><br><span class="line">        byte[] b &#x3D; new byte[list.size()];</span><br><span class="line">        for (int i &#x3D; 0; i &lt; b.length; i++) &#123;</span><br><span class="line">            b[i] &#x3D; list.get(i);</span><br><span class="line">        &#125;</span><br><span class="line">        return b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 将一个byte转成二进制的字符串</span><br><span class="line">     *</span><br><span class="line">     * @param b</span><br><span class="line">     * @param flag 表示表示是否需要补高位</span><br><span class="line">     * @return 返回该byte对应的 二进制字符串(补码)</span><br><span class="line">     *&#x2F;</span><br><span class="line">    private static String byteToBitString(boolean flag, byte b) &#123;</span><br><span class="line">        &#x2F;&#x2F;使用变量保存b</span><br><span class="line">        int temp &#x3D; b; &#x2F;&#x2F;将b转成Int</span><br><span class="line">        &#x2F;&#x2F;如果是整数我们还需要补位</span><br><span class="line">        if (flag) &#123;</span><br><span class="line">            temp |&#x3D; 256; &#x2F;&#x2F;temp按位与 10000 0000 |0000 0001&#x3D;&gt;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        String str &#x3D; Integer.toBinaryString(temp); &#x2F;&#x2F;返回的是temp对应二进制的补码</span><br><span class="line">        if (flag) &#123;</span><br><span class="line">            return str.substring(str.length() - 8);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return str;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 使用一个方法,将前面的方法封装起来,便于我们的调用</span><br><span class="line">     *</span><br><span class="line">     * @param bytes 原始的字符串对应的字符串,便于我们调用</span><br><span class="line">     * @return 是经过赫夫曼编码处理后的字节数组</span><br><span class="line">     *&#x2F;</span><br><span class="line">    private static byte[] huffmanZip(byte[] bytes) &#123;</span><br><span class="line">        List&lt;Node1&gt; nodes &#x3D; getNodes(bytes);</span><br><span class="line">        &#x2F;&#x2F;根据nodes创建的赫夫曼树</span><br><span class="line">        Node1 huffmanTreeRoot &#x3D; createHuffmanTree(nodes);</span><br><span class="line">        &#x2F;&#x2F;生成对应的赫夫曼编码(根据赫夫曼树)</span><br><span class="line">        Map&lt;Byte, String&gt; huffmanCodes &#x3D; getCodes(huffmanTreeRoot);</span><br><span class="line">        &#x2F;&#x2F;根据生成的赫夫曼编码,压缩得到压缩后的赫夫曼编码字节数组</span><br><span class="line">        byte[] huffmanCodeBytes &#x3D; zip(bytes, huffmanCodes);</span><br><span class="line">        return huffmanCodeBytes;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 编写一个方法,将字符串对应的byte[]数组,通过生成的赫夫曼编码表返回一个赫夫曼编码压缩后的byte[]</span><br><span class="line">     *</span><br><span class="line">     * @param bytes        原始的字符串对应的byte[]</span><br><span class="line">     * @param huffmanCodes 生成赫夫曼编码map</span><br><span class="line">     * @return 返回赫夫曼编码处理后的byte[]</span><br><span class="line">     * 举例:String content&#x3D;&quot;i like like like java do you like a java&quot;; -&gt;byte[] contentBytes&#x3D;&gt; content.getBytes</span><br><span class="line">     * 返回的是字符串对应的byte数组 &#x3D;&gt;即8个对应一个byte放到byte数组中</span><br><span class="line">     * 10101000(补码)&#x3D;&gt; 10101000-1&#x3D;&gt;10100111(反码)&#x3D;&gt;11011000(原码)&#x3D;-88</span><br><span class="line">     *&#x2F;</span><br><span class="line">    private static byte[] zip(byte[] bytes, Map&lt;Byte, String&gt; huffmanCodes) &#123;</span><br><span class="line">        &#x2F;&#x2F;1.利用huffmanCodes将bytes转成赫夫曼编码对应的字符串</span><br><span class="line">        StringBuilder stringBuilder &#x3D; new StringBuilder();</span><br><span class="line">        &#x2F;&#x2F;遍历bytes数组</span><br><span class="line">        for (byte b : bytes) &#123;</span><br><span class="line">            stringBuilder.append(huffmanCodes.get(b));</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;将&quot;&quot;转成byte[]</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;统计返回byte[] huffmanCodeBytes长度</span><br><span class="line">        &#x2F;&#x2F;一句话</span><br><span class="line">        &#x2F;&#x2F;int len&#x3D;(stringBuilder.length()+7)&#x2F;8;</span><br><span class="line">        int len;</span><br><span class="line">        if (stringBuilder.length() % 8 &#x3D;&#x3D; 0) &#123;</span><br><span class="line">            len &#x3D; stringBuilder.length() &#x2F; 8;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            len &#x3D; stringBuilder.length() &#x2F; 8 + 1;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;创建存储压缩后的byte数组</span><br><span class="line">        byte[] huffmanCodeBytes &#x3D; new byte[len];</span><br><span class="line">        int index &#x3D; 0; &#x2F;&#x2F;记录是第几个byte</span><br><span class="line">        for (int i &#x3D; 0; i &lt; stringBuilder.length(); i +&#x3D; 8) &#123;</span><br><span class="line">            &#x2F;&#x2F;因为是每8位对应一个byte，所以步长+8</span><br><span class="line">            String strByte;</span><br><span class="line">            if (i + 8 &gt; stringBuilder.length()) &#123;</span><br><span class="line">                &#x2F;&#x2F;不够8位</span><br><span class="line">                strByte &#x3D; stringBuilder.substring(i);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                strByte &#x3D; stringBuilder.substring(i, i + 8);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F;将strByte转成一个byte，放入到huffmanCodeBytes</span><br><span class="line">            huffmanCodeBytes[index] &#x3D; (byte) Integer.parseInt(strByte, 2);</span><br><span class="line">            index++;</span><br><span class="line">        &#125;</span><br><span class="line">        return huffmanCodeBytes;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;生成赫夫曼树对应的赫夫曼编码</span><br><span class="line">    &#x2F;&#x2F;思路:将赫夫曼编码表存在map&lt;Byte,String&gt;形式</span><br><span class="line">    &#x2F;&#x2F;32-&gt;01 97-&gt;100 100-&gt;11000等等</span><br><span class="line">    static Map&lt;Byte, String&gt; huffmanCodes &#x3D; new HashMap&lt;&gt;();</span><br><span class="line">    &#x2F;&#x2F;2.在生成赫夫曼编码表时需要取拼接路径,定义一个StringBuilder存储某个叶子结点的路径</span><br><span class="line">    static StringBuilder stringBuilder &#x3D; new StringBuilder();</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;为了调用方便,重载getCodes</span><br><span class="line">    private static Map&lt;Byte, String&gt; getCodes(Node1 root) &#123;</span><br><span class="line">        if (root &#x3D;&#x3D; null) &#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;处理root的左子树</span><br><span class="line">        getCodes(root.left, &quot;0&quot;, stringBuilder);</span><br><span class="line">        &#x2F;&#x2F;处理root的右子树</span><br><span class="line">        getCodes(root.right, &quot;1&quot;, stringBuilder);</span><br><span class="line">        return huffmanCodes;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 功能:将传入的Node结点的所有叶子结点的赫夫曼编码得到,并放入到</span><br><span class="line">     *</span><br><span class="line">     * @param node          传入结点,</span><br><span class="line">     * @param code          路径:左子结点是0 右子结点1</span><br><span class="line">     * @param stringBuilder 用于拼接路径</span><br><span class="line">     *&#x2F;</span><br><span class="line">    private static void getCodes(Node1 node, String code, StringBuilder stringBuilder) &#123;</span><br><span class="line">        StringBuilder stringBuilder2 &#x3D; new StringBuilder(stringBuilder);</span><br><span class="line">        &#x2F;&#x2F;将code加入到stringBuilder2</span><br><span class="line">        stringBuilder2.append(code);</span><br><span class="line">        if (node !&#x3D; null) &#123;</span><br><span class="line">            &#x2F;&#x2F;如果node&#x3D;&#x3D;null不处理</span><br><span class="line">            &#x2F;&#x2F;判断当前node是叶子结点还是非叶子结点</span><br><span class="line">            if (node.data &#x3D;&#x3D; null) &#123;</span><br><span class="line">                &#x2F;&#x2F;非叶子结点</span><br><span class="line">                &#x2F;&#x2F;递归处理,向左,</span><br><span class="line">                getCodes(node.left, &quot;0&quot;, stringBuilder2);</span><br><span class="line">                &#x2F;&#x2F;向右递归</span><br><span class="line">                getCodes(node.right, &quot;1&quot;, stringBuilder2);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                &#x2F;&#x2F;说明是个叶子结点</span><br><span class="line">                &#x2F;&#x2F;表明找到了某个叶子结点的最后</span><br><span class="line">                huffmanCodes.put(node.data, stringBuilder2.toString());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;前序遍历的一个方法</span><br><span class="line">    private static void preOrder(Node1 root) &#123;</span><br><span class="line">        if (root !&#x3D; null) &#123;</span><br><span class="line">            root.preOrder();</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            System.out.println(&quot;赫夫曼树为空&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * @param bytes 接收一个字节数组</span><br><span class="line">     * @return 返回的是一个list形式,</span><br><span class="line">     *&#x2F;</span><br><span class="line">    private static List&lt;Node1&gt; getNodes(byte[] bytes) &#123;</span><br><span class="line">        &#x2F;&#x2F;创建一个ArrayList</span><br><span class="line">        ArrayList&lt;Node1&gt; nodes &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">        &#x2F;&#x2F;遍历bytes,统计每一个byte出现的次数-&gt;map[key,value]</span><br><span class="line">        Map&lt;Byte, Integer&gt; counts &#x3D; new HashMap&lt;&gt;();</span><br><span class="line">        for (byte b : bytes) &#123;</span><br><span class="line">            Integer count &#x3D; counts.get(b);</span><br><span class="line">            if (count &#x3D;&#x3D; null) &#123;</span><br><span class="line">                counts.put(b, 1);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                counts.put(b, count + 1);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;把每一个键值对转换成一个Node对象,并加入到nodes集合中</span><br><span class="line">        &#x2F;&#x2F;遍历map</span><br><span class="line">        for (Map.Entry&lt;Byte, Integer&gt; entry : counts.entrySet()) &#123;</span><br><span class="line">            nodes.add(new Node1(entry.getKey(), entry.getValue()));</span><br><span class="line">        &#125;</span><br><span class="line">        return nodes;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;可以通过List创建对应的赫夫曼树</span><br><span class="line">    private static Node1 createHuffmanTree(List&lt;Node1&gt; nodes) &#123;</span><br><span class="line">        while (nodes.size() &gt; 1) &#123;</span><br><span class="line">            &#x2F;&#x2F;排序,从小到大</span><br><span class="line">            Collections.sort(nodes);</span><br><span class="line">            &#x2F;&#x2F;取出第一颗最小的二叉树</span><br><span class="line">            Node1 leftNode &#x3D; nodes.get(0);</span><br><span class="line">            &#x2F;&#x2F;取出第二棵最小的二叉树</span><br><span class="line">            Node1 rightNode &#x3D; nodes.get(1);</span><br><span class="line">            &#x2F;&#x2F;创建一棵新的二叉树，它的根结点,没有data只有权值</span><br><span class="line">            Node1 parent &#x3D; new Node1(null, leftNode.weight + rightNode.weight);</span><br><span class="line">            parent.left &#x3D; leftNode;</span><br><span class="line">            parent.right &#x3D; rightNode;</span><br><span class="line">            &#x2F;&#x2F;将已经处理的两颗二叉树从nodes删除</span><br><span class="line">            nodes.remove(leftNode);</span><br><span class="line">            nodes.remove(rightNode);</span><br><span class="line">            &#x2F;&#x2F;将新的二叉树,加入到nodes</span><br><span class="line">            nodes.add(parent);</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;返回的结点,最后的结点就是哈夫曼树的根结点</span><br><span class="line">        return nodes.get(0);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;创建Node,带数据和权值</span><br><span class="line">class Node1 implements Comparable&lt;Node1&gt; &#123;</span><br><span class="line">    Byte data; &#x2F;&#x2F;存放数据本身,比如&#39;a&#39;&#x3D;&gt;97 &#39;&#39;&#x3D;&gt;32</span><br><span class="line">    int weight; &#x2F;&#x2F;权值,表示字符的出现次数</span><br><span class="line">    Node1 left; &#x2F;&#x2F;</span><br><span class="line">    Node1 right;</span><br><span class="line"></span><br><span class="line">    public Node1(Byte data, int weight) &#123;</span><br><span class="line">        this.data &#x3D; data;</span><br><span class="line">        this.weight &#x3D; weight;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public int compareTo(Node1 o) &#123;</span><br><span class="line">        return this.weight - o.weight;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return &quot;Node1[&quot; +</span><br><span class="line">                &quot;data&#x3D;&quot; + data + &quot; weight&#x3D;&quot; + weight +</span><br><span class="line">                &#39;]&#39;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;前序遍历</span><br><span class="line">    public void preOrder() &#123;</span><br><span class="line">        System.out.println(this);</span><br><span class="line">        if (this.left !&#x3D; null) &#123;</span><br><span class="line">            this.left.preOrder();</span><br><span class="line">        &#125;</span><br><span class="line">        if (this.right !&#x3D; null) &#123;</span><br><span class="line">            this.right.preOrder();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;赫夫曼编码的压缩和解压&quot;&gt;&lt;a href=&quot;#赫夫曼编码的压缩和解压&quot; class=&quot;headerlink&quot; title=&quot;赫夫曼编码的压缩和解压&quot;&gt;&lt;/a&gt;赫夫曼编码的压缩和解压&lt;/h1&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;tabl
      
    
    </summary>
    
    
      <category term="数据结构" scheme="https://todcsw.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="学习" scheme="https://todcsw.github.io/tags/%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="java" scheme="https://todcsw.github.io/tags/java/"/>
    
      <category term="数据结构" scheme="https://todcsw.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>java实现赫夫曼树</title>
    <link href="https://todcsw.github.io/2020/04/28/java%E5%AE%9E%E7%8E%B0%E8%B5%AB%E5%A4%AB%E6%9B%BC%E6%A0%91/"/>
    <id>https://todcsw.github.io/2020/04/28/java%E5%AE%9E%E7%8E%B0%E8%B5%AB%E5%A4%AB%E6%9B%BC%E6%A0%91/</id>
    <published>2020-04-28T08:45:43.000Z</published>
    <updated>2020-05-01T02:48:41.074Z</updated>
    
    <content type="html"><![CDATA[<h1 id="赫夫曼树"><a href="#赫夫曼树" class="headerlink" title="赫夫曼树"></a>赫夫曼树</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package com.csw.huffmantree;</span><br><span class="line"></span><br><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.Collection;</span><br><span class="line">import java.util.Collections;</span><br><span class="line">import java.util.List;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * @Auther: 行路</span><br><span class="line"> * @Date: Created on 2020&#x2F;4&#x2F;28 13:51 星期二</span><br><span class="line"> * @Description: com.csw.huffmantree 赫夫曼树</span><br><span class="line"> * @version: 1.0</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class HuffmanTree &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int[] arr &#x3D; &#123;13, 7, 8, 3, 29, 6, 1&#125;;</span><br><span class="line">        Node node &#x3D; createHuffmanTree(arr);</span><br><span class="line">        preOrder(node);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;编写一个前序遍历的方法</span><br><span class="line">    public static void preOrder(Node root)&#123;</span><br><span class="line">        if(root!&#x3D;null)&#123;</span><br><span class="line">            root.preOrder();</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            System.out.println(&quot;树是空树&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     *  创建赫夫曼树</span><br><span class="line">     * @param arr 需要创建哈夫曼树的数组</span><br><span class="line">     * @return 创建后的赫夫曼树的root结点</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public static Node createHuffmanTree(int[] arr) &#123;</span><br><span class="line">        &#x2F;&#x2F;第一步为了操作方便</span><br><span class="line">        &#x2F;&#x2F;1遍历arr数组</span><br><span class="line">        &#x2F;&#x2F;2.将arr的每个元素构成一个Node</span><br><span class="line">        &#x2F;&#x2F;3.将Node放入到ArrayList中</span><br><span class="line">        List&lt;Node&gt; nodes &#x3D; new ArrayList&lt;Node&gt;();</span><br><span class="line">        for (int value : arr) &#123;</span><br><span class="line">            nodes.add(new Node(value));</span><br><span class="line">        &#125;</span><br><span class="line">        while (nodes.size() &gt; 1) &#123;</span><br><span class="line">            &#x2F;&#x2F;排序从小到大</span><br><span class="line">            Collections.sort(nodes);</span><br><span class="line">            System.out.println(&quot;nodes&#x3D;&quot;+nodes);</span><br><span class="line">            &#x2F;&#x2F;取出权值最小的结点(二叉树)</span><br><span class="line">            Node leftNode &#x3D; nodes.get(0);</span><br><span class="line">            &#x2F;&#x2F;取出第二小</span><br><span class="line">            Node rightNode &#x3D; nodes.get(1);</span><br><span class="line">            &#x2F;&#x2F;构建新的二叉树</span><br><span class="line">            Node parent &#x3D; new Node(leftNode.value + rightNode.value);</span><br><span class="line">            parent.left &#x3D; leftNode;</span><br><span class="line">            parent.right &#x3D; rightNode;</span><br><span class="line">            &#x2F;&#x2F;从ArrayList删除处理过的二叉树</span><br><span class="line">            nodes.remove(leftNode);</span><br><span class="line">            nodes.remove(rightNode);</span><br><span class="line">            &#x2F;&#x2F;将parent加入到nodes</span><br><span class="line">            nodes.add(parent);</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;返回哈夫曼树树的root结点</span><br><span class="line">        return nodes.get(0);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * Description: 为了让node对象持续排序Collection集合排序</span><br><span class="line"> * 让Node实现comparable接口</span><br><span class="line"> * 创建结点类</span><br><span class="line"> *</span><br><span class="line"> * @author Todcsw</span><br><span class="line"> * @date</span><br><span class="line"> *&#x2F;</span><br><span class="line">class Node implements Comparable&lt;Node&gt; &#123;</span><br><span class="line">    int value;  &#x2F;&#x2F;结点权值</span><br><span class="line">    Node left;  &#x2F;&#x2F;指向左子结点</span><br><span class="line">    Node right; &#x2F;&#x2F;指向右子结点</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;写一个前序遍历</span><br><span class="line">    public void preOrder()&#123;</span><br><span class="line">        System.out.println(this);</span><br><span class="line">        if(this.left!&#x3D;null)&#123;</span><br><span class="line">            this.left.preOrder();</span><br><span class="line">        &#125;</span><br><span class="line">        if(this.right!&#x3D;null)&#123;</span><br><span class="line">            this.right.preOrder();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Node(int value) &#123;</span><br><span class="line">        this.value &#x3D; value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return &quot;Node[&quot; +</span><br><span class="line">                &quot;value&#x3D;&quot; + value +</span><br><span class="line">                &#39;]&#39;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public int compareTo(Node o) &#123;</span><br><span class="line">        &#x2F;&#x2F;表示从小到大</span><br><span class="line">        return this.value - o.value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;赫夫曼树&quot;&gt;&lt;a href=&quot;#赫夫曼树&quot; class=&quot;headerlink&quot; title=&quot;赫夫曼树&quot;&gt;&lt;/a&gt;赫夫曼树&lt;/h1&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;
      
    
    </summary>
    
    
      <category term="数据结构" scheme="https://todcsw.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="学习" scheme="https://todcsw.github.io/tags/%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="java" scheme="https://todcsw.github.io/tags/java/"/>
    
      <category term="数据结构" scheme="https://todcsw.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>java实现线索化二叉树及遍历</title>
    <link href="https://todcsw.github.io/2020/04/27/java%E5%AE%9E%E7%8E%B0%E7%BA%BF%E7%B4%A2%E5%8C%96%E4%BA%8C%E5%8F%89%E6%A0%91%E5%8F%8A%E9%81%8D%E5%8E%86/"/>
    <id>https://todcsw.github.io/2020/04/27/java%E5%AE%9E%E7%8E%B0%E7%BA%BF%E7%B4%A2%E5%8C%96%E4%BA%8C%E5%8F%89%E6%A0%91%E5%8F%8A%E9%81%8D%E5%8E%86/</id>
    <published>2020-04-27T07:59:23.000Z</published>
    <updated>2020-05-01T08:18:48.792Z</updated>
    
    <content type="html"><![CDATA[<h1 id="java实现线索化二叉树及遍历"><a href="#java实现线索化二叉树及遍历" class="headerlink" title="java实现线索化二叉树及遍历"></a>java实现线索化二叉树及遍历</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package com.csw.tree;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * @Auther: 行路</span><br><span class="line"> * @Date: Created on 2020&#x2F;4&#x2F;27 14:19 星期一</span><br><span class="line"> * @Description: com.csw.tree 线索二叉树(遍历线索二叉树)</span><br><span class="line"> * @version: 1.0</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class ThreadedBinaryTreeDemo &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        &#x2F;&#x2F;测试中序线索二叉树的功能</span><br><span class="line">        HeroNode1 root &#x3D; new HeroNode1(1, &quot;tom&quot;);</span><br><span class="line">        HeroNode1 node2 &#x3D; new HeroNode1(3, &quot;jack&quot;);</span><br><span class="line">        HeroNode1 node3 &#x3D; new HeroNode1(6, &quot;smith&quot;);</span><br><span class="line">        HeroNode1 node4 &#x3D; new HeroNode1(8, &quot;mary&quot;);</span><br><span class="line">        HeroNode1 node5 &#x3D; new HeroNode1(10, &quot;king&quot;);</span><br><span class="line">        HeroNode1 node6 &#x3D; new HeroNode1(14, &quot;dim&quot;);</span><br><span class="line">        &#x2F;&#x2F;后续会递归创建,目前手动创建</span><br><span class="line">        root.setLeft(node2);</span><br><span class="line">        root.setRight(node3);</span><br><span class="line">        node2.setLeft(node4);</span><br><span class="line">        node2.setRight(node5);</span><br><span class="line">        node3.setLeft(node6);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;测试中序线索化</span><br><span class="line">        ThreadedBinaryTree threadedBinaryTree &#x3D; new ThreadedBinaryTree();</span><br><span class="line">        threadedBinaryTree.setRoot(root);</span><br><span class="line">        threadedBinaryTree.threadedNodes();</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;测试:以10结点测试 左3右1</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;前驱结点:&quot; + node5.getLeft() + &quot;\n后继结点:&quot; + node5.getRight());</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;使用线索化的方式遍历线索化二叉树&quot;);</span><br><span class="line">        threadedBinaryTree.threadedList();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * Description: 定义BinaryTree1二叉树</span><br><span class="line"> * 定义ThreadedBinaryTree实现了线索化功能的二叉树</span><br><span class="line"> *</span><br><span class="line"> * @author Todcsw</span><br><span class="line"> * @date</span><br><span class="line"> *&#x2F;</span><br><span class="line">class ThreadedBinaryTree &#123;</span><br><span class="line">    private HeroNode1 root;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;为了实现线索化,需要创建要给指向当前结点的前驱结点的指针</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;递归进行线索化,pre总是保留前一个结点</span><br><span class="line">    private HeroNode1 pre &#x3D; null;</span><br><span class="line"></span><br><span class="line">    public void setRoot(HeroNode1 root) &#123;</span><br><span class="line">        this.root &#x3D; root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void threadedNodes() &#123;</span><br><span class="line">        this.threadNodes(root);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;遍历线索化二叉树的方法</span><br><span class="line">    public void threadedList() &#123;</span><br><span class="line">        &#x2F;&#x2F;定义变量,存储当前遍历的结点,从root开始</span><br><span class="line">        HeroNode1 node &#x3D; root;</span><br><span class="line">        while (node !&#x3D; null) &#123;</span><br><span class="line">            &#x2F;&#x2F;循环的找到leftType&#x3D;&#x3D;1结点,第一个找到的是8结点</span><br><span class="line">            &#x2F;&#x2F;后面随着遍历而变化,因为leftType&#x3D;&#x3D;1时,说明该结点时按照线索化</span><br><span class="line">            &#x2F;&#x2F;处理后的有效结点</span><br><span class="line">            while (node.getLeftType() &#x3D;&#x3D; 0) &#123;</span><br><span class="line">                node &#x3D; node.getLeft();</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F;打印当前这个结点</span><br><span class="line">            System.out.println(node);</span><br><span class="line">            &#x2F;&#x2F;如果当前结点的右指针指向的是后继结点,就一直输出</span><br><span class="line">            while (node.getRightType()&#x3D;&#x3D;1)&#123;</span><br><span class="line">                node&#x3D;node.getRight();</span><br><span class="line">                System.out.println(node);</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F;替换这个遍历的结点</span><br><span class="line">            node&#x3D;node.getRight();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;编写对二叉树进行中序线索化的方法、</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * @param node 就是当前需要线索化的结点</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public void threadNodes(HeroNode1 node) &#123;</span><br><span class="line">        &#x2F;&#x2F;如果node&#x3D;null，不能线索化</span><br><span class="line">        if (node &#x3D;&#x3D; null) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;先线索化左子树</span><br><span class="line">        threadNodes(node.getLeft());</span><br><span class="line">        &#x2F;&#x2F;线索化当前结点,处理当前结点的前驱结点</span><br><span class="line">        &#x2F;&#x2F;以8号结点 .left&#x3D;null,8结点的.leftType&#x3D;1</span><br><span class="line">        if (node.getLeft() &#x3D;&#x3D; null) &#123;</span><br><span class="line">            &#x2F;&#x2F;让当前结点的左子针指向前驱结点</span><br><span class="line">            node.setLeft(pre);</span><br><span class="line">            &#x2F;&#x2F;修改当前结点的左指针类型,指向前驱结点</span><br><span class="line">            node.setLeftType(1);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;处理后继结点</span><br><span class="line">        if (pre !&#x3D; null &amp;&amp; pre.getRight() &#x3D;&#x3D; null) &#123;</span><br><span class="line">            &#x2F;&#x2F;让前驱结点的右指针指向当前这个结点</span><br><span class="line">            pre.setRight(node);</span><br><span class="line">            &#x2F;&#x2F;修改前驱结点的右指针类型</span><br><span class="line">            pre.setRightType(1);</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;!!!每处理一个结点后,让当前结点是下一个结点的前驱结点</span><br><span class="line">        pre &#x3D; node;</span><br><span class="line">        &#x2F;&#x2F;在线索化右子树</span><br><span class="line">        threadNodes(node.getRight());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 前序遍历</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public void preOrder() &#123;</span><br><span class="line">        if (this.root !&#x3D; null) &#123;</span><br><span class="line">            this.root.preOrder();</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            System.out.println(&quot;二叉树为空无法遍历&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 中序遍历</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public void infixOrder() &#123;</span><br><span class="line">        if (this.root !&#x3D; null) &#123;</span><br><span class="line">            this.root.infixOrder();</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            System.out.println(&quot;二叉树为空无法遍历&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 后序遍历</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public void postOrder() &#123;</span><br><span class="line">        if (this.root !&#x3D; null) &#123;</span><br><span class="line">            this.root.postOrder();</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            System.out.println(&quot;二叉树为空无法遍历&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 递归删除</span><br><span class="line">     *</span><br><span class="line">     * @param no</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public void delNode(int no) &#123;</span><br><span class="line">        if (root !&#x3D; null) &#123;</span><br><span class="line">            &#x2F;&#x2F;判断root是不是要删除的</span><br><span class="line">            if (root.getNo() &#x3D;&#x3D; no) &#123;</span><br><span class="line">                root &#x3D; null;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                &#x2F;&#x2F;递归删除</span><br><span class="line">                root.delNode(no);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            System.out.println(&quot;空树不能删除&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 前序查找</span><br><span class="line">     *</span><br><span class="line">     * @param no</span><br><span class="line">     * @return</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public HeroNode1 preOrderSearch(int no) &#123;</span><br><span class="line">        if (root !&#x3D; null) &#123;</span><br><span class="line">            return root.preOrderSearch(no);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 中序查找</span><br><span class="line">     *</span><br><span class="line">     * @param no</span><br><span class="line">     * @return</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public HeroNode1 infixOrderSearch(int no) &#123;</span><br><span class="line">        if (root !&#x3D; null) &#123;</span><br><span class="line">            return root.infixOrderSearch(no);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 后序查找</span><br><span class="line">     *</span><br><span class="line">     * @param no</span><br><span class="line">     * @return</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public HeroNode1 postOrderSearch(int no) &#123;</span><br><span class="line">        if (root !&#x3D; null) &#123;</span><br><span class="line">            return root.postOrderSearch(no);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * Description: 创建HeroNode11节点</span><br><span class="line"> *</span><br><span class="line"> * @author Todcsw</span><br><span class="line"> * @date</span><br><span class="line"> *&#x2F;</span><br><span class="line">class HeroNode1 &#123;</span><br><span class="line">    private int no;</span><br><span class="line">    private String name;</span><br><span class="line">    private HeroNode1 left; &#x2F;&#x2F;默认为Null</span><br><span class="line">    private HeroNode1 right; &#x2F;&#x2F;默认null</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;说明leftType&#x3D;&#x3D;0表示指向的是左子树,如果是1则表示指向前驱结点</span><br><span class="line">    &#x2F;&#x2F;2.说明rightType&#x3D;&#x3D;0表示指向的右子树,如果是1则表示指向后继结点</span><br><span class="line">    private int leftType;</span><br><span class="line">    private int rightType;</span><br><span class="line"></span><br><span class="line">    public int getLeftType() &#123;</span><br><span class="line">        return leftType;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setLeftType(int leftType) &#123;</span><br><span class="line">        this.leftType &#x3D; leftType;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int getRightType() &#123;</span><br><span class="line">        return rightType;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setRightType(int rightType) &#123;</span><br><span class="line">        this.rightType &#x3D; rightType;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public HeroNode1(int no, String name) &#123;</span><br><span class="line">        this.no &#x3D; no;</span><br><span class="line">        this.name &#x3D; name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int getNo() &#123;</span><br><span class="line">        return no;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setNo(int no) &#123;</span><br><span class="line">        this.no &#x3D; no;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getName() &#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setName(String name) &#123;</span><br><span class="line">        this.name &#x3D; name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public HeroNode1 getLeft() &#123;</span><br><span class="line">        return left;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setLeft(HeroNode1 left) &#123;</span><br><span class="line">        this.left &#x3D; left;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public HeroNode1 getRight() &#123;</span><br><span class="line">        return right;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setRight(HeroNode1 right) &#123;</span><br><span class="line">        this.right &#x3D; right;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return &quot;HeroNode11&#123;&quot; +</span><br><span class="line">                &quot;no&#x3D;&quot; + no +</span><br><span class="line">                &quot;, name&#x3D;&#39;&quot; + name + &#39;\&#39;&#39; +</span><br><span class="line">                &#39;&#125;&#39;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 递归删除节点</span><br><span class="line">     * 如果删除的节点是叶子节点,则删除该节点</span><br><span class="line">     * 如果删除的节点是非叶子节点,则删除该子树</span><br><span class="line">     * 1.因为我们的二叉树是单向的,所以我们是判断当前节点的子节点是否需要删除的节点,而不能去判断,当前这个结点是不是需要删除的结点</span><br><span class="line">     * 2.如果当前结点的左子结点不为空,并且左子结点就是要删除的结点,就将this.left&#x3D;null;并且就返回(结束递归删除)</span><br><span class="line">     * 3.如果当前结点的右子结点不为空,并且右子结点就是要删除的结点,就将this.right&#x3D;null;并且就返回(结束递归删除)</span><br><span class="line">     * 4.如果第2和3步没有删除结点,那么晚我们需要向左子树就行递归删除</span><br><span class="line">     * 5.如果第4步也没有删除结点,则应当向右子树进行递归删除</span><br><span class="line">     *</span><br><span class="line">     * @param no</span><br><span class="line">     *&#x2F;</span><br><span class="line"></span><br><span class="line">    public void delNode(int no) &#123;</span><br><span class="line"></span><br><span class="line">        if (this.left !&#x3D; null &amp;&amp; this.left.no &#x3D;&#x3D; no) &#123;</span><br><span class="line">            this.left &#x3D; null;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        if (this.right !&#x3D; null &amp;&amp; this.right.no &#x3D;&#x3D; no) &#123;</span><br><span class="line">            this.right &#x3D; null;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        if (this.left !&#x3D; null) &#123;</span><br><span class="line">            this.left.delNode(no);</span><br><span class="line">        &#125;</span><br><span class="line">        if (this.right !&#x3D; null) &#123;</span><br><span class="line">            this.right.delNode(no);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 编写前序遍历的方法</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public void preOrder() &#123;</span><br><span class="line">        System.out.println(this); &#x2F;&#x2F;先输出父节点</span><br><span class="line">        &#x2F;&#x2F;递归向左子树遍历</span><br><span class="line">        if (this.left !&#x3D; null) &#123;</span><br><span class="line">            this.left.preOrder();</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;递归向右子树前序遍历</span><br><span class="line">        if (this.right !&#x3D; null) &#123;</span><br><span class="line">            this.right.preOrder();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 编写中序遍历的方法</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public void infixOrder() &#123;</span><br><span class="line">        &#x2F;&#x2F;递归向左子树中序遍历</span><br><span class="line">        if (this.left !&#x3D; null) &#123;</span><br><span class="line">            this.left.infixOrder();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(this);</span><br><span class="line">        if (this.right !&#x3D; null) &#123;</span><br><span class="line">            this.right.infixOrder();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 编写后序遍历的方法</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public void postOrder() &#123;</span><br><span class="line">        &#x2F;&#x2F;递归向左子树中序遍历</span><br><span class="line">        if (this.left !&#x3D; null) &#123;</span><br><span class="line">            this.left.postOrder();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (this.right !&#x3D; null) &#123;</span><br><span class="line">            this.right.postOrder();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(this);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 前序遍历查找</span><br><span class="line">     *</span><br><span class="line">     * @param no 查找no</span><br><span class="line">     * @return 如果找到就返回该node，如果没有找到就返回Null</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public HeroNode1 preOrderSearch(int no) &#123;</span><br><span class="line">        System.out.println(&quot;进入前序遍历&quot;);</span><br><span class="line">        &#x2F;&#x2F;比较当前节点是不是</span><br><span class="line">        if (this.no &#x3D;&#x3D; no) &#123;</span><br><span class="line">            return this;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;则判断当前节点的左子节点是否为空,如果不为空,则递归前序查找</span><br><span class="line">        HeroNode1 resNode &#x3D; null;</span><br><span class="line">        if (this.left !&#x3D; null) &#123;</span><br><span class="line">            resNode &#x3D; this.left.preOrderSearch(no);</span><br><span class="line">        &#125;</span><br><span class="line">        if (resNode !&#x3D; null) &#123;</span><br><span class="line">            &#x2F;&#x2F;说明左子树找到了</span><br><span class="line">            return resNode;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;1左递归前序查找,找到节点,则返回,否则继续判断</span><br><span class="line">        &#x2F;&#x2F;2当前的结点的右子节点是否为空,如果不空,则继续向右递归前序查找</span><br><span class="line">        if (this.right !&#x3D; null) &#123;</span><br><span class="line">            resNode &#x3D; this.right.preOrderSearch(no);</span><br><span class="line">        &#125;</span><br><span class="line">        return resNode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 中序遍历查找</span><br><span class="line">     *</span><br><span class="line">     * @param no</span><br><span class="line">     * @return</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public HeroNode1 infixOrderSearch(int no) &#123;</span><br><span class="line">        &#x2F;&#x2F;判断当前节点的左子节点是否为空,如果不为空,则递归中序查找</span><br><span class="line">        HeroNode1 resNode &#x3D; null;</span><br><span class="line">        if (this.left !&#x3D; null) &#123;</span><br><span class="line">            resNode &#x3D; this.left.infixOrderSearch(no);</span><br><span class="line">        &#125;</span><br><span class="line">        if (resNode !&#x3D; null) &#123;</span><br><span class="line">            return resNode;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot;进入中序遍历&quot;);</span><br><span class="line">        if (this.no &#x3D;&#x3D; no) &#123;</span><br><span class="line">            return this;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;向右进行中序查找</span><br><span class="line">        if (this.right !&#x3D; null) &#123;</span><br><span class="line">            resNode &#x3D; this.right.infixOrderSearch(no);</span><br><span class="line">        &#125;</span><br><span class="line">        return resNode;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 后续遍历查找</span><br><span class="line">     *</span><br><span class="line">     * @param no</span><br><span class="line">     * @return</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public HeroNode1 postOrderSearch(int no) &#123;</span><br><span class="line"></span><br><span class="line">        HeroNode1 resNode &#x3D; null;</span><br><span class="line">        if (this.left !&#x3D; null) &#123;</span><br><span class="line">            resNode &#x3D; this.left.postOrderSearch(no);</span><br><span class="line">        &#125;</span><br><span class="line">        if (resNode !&#x3D; null) &#123;</span><br><span class="line">            return resNode;</span><br><span class="line">        &#125;</span><br><span class="line">        if (this.right !&#x3D; null) &#123;</span><br><span class="line">            resNode &#x3D; this.right.postOrderSearch(no);</span><br><span class="line">        &#125;</span><br><span class="line">        if (resNode !&#x3D; null) &#123;</span><br><span class="line">            return resNode;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot;进入后序遍历&quot;);</span><br><span class="line">        if (this.no &#x3D;&#x3D; no) &#123;</span><br><span class="line">            return this;</span><br><span class="line">        &#125;</span><br><span class="line">        return resNode;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;java实现线索化二叉树及遍历&quot;&gt;&lt;a href=&quot;#java实现线索化二叉树及遍历&quot; class=&quot;headerlink&quot; title=&quot;java实现线索化二叉树及遍历&quot;&gt;&lt;/a&gt;java实现线索化二叉树及遍历&lt;/h1&gt;&lt;figure class=&quot;highli
      
    
    </summary>
    
    
      <category term="数据结构" scheme="https://todcsw.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="学习" scheme="https://todcsw.github.io/tags/%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="java" scheme="https://todcsw.github.io/tags/java/"/>
    
      <category term="数据结构" scheme="https://todcsw.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>java实现二叉树的前序中序后序遍历和查找及删除</title>
    <link href="https://todcsw.github.io/2020/04/26/java%E5%AE%9E%E7%8E%B0%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E5%BA%8F%E4%B8%AD%E5%BA%8F%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E5%92%8C%E6%9F%A5%E6%89%BE%E5%8F%8A%E5%88%A0%E9%99%A4/"/>
    <id>https://todcsw.github.io/2020/04/26/java%E5%AE%9E%E7%8E%B0%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E5%BA%8F%E4%B8%AD%E5%BA%8F%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E5%92%8C%E6%9F%A5%E6%89%BE%E5%8F%8A%E5%88%A0%E9%99%A4/</id>
    <published>2020-04-26T07:59:23.000Z</published>
    <updated>2020-04-24T07:59:44.033Z</updated>
    
    <content type="html"><![CDATA[<h1 id="java实现二叉树的前序中序后序遍历和查找及删除"><a href="#java实现二叉树的前序中序后序遍历和查找及删除" class="headerlink" title="java实现二叉树的前序中序后序遍历和查找及删除"></a>java实现二叉树的前序中序后序遍历和查找及删除</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package com.csw.tree;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * @Auther: 行路</span><br><span class="line"> * @Date: Created on 2020&#x2F;4&#x2F;26 13:00 星期日</span><br><span class="line"> * @Description: com.csw.tree 二叉树的前序中序后序遍历和查找及删除</span><br><span class="line"> * @version: 1.0</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class BinaryTreeDemo &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        &#x2F;&#x2F;先需要创建一颗二叉树</span><br><span class="line">        BinaryTree binaryTree &#x3D; new BinaryTree();</span><br><span class="line">        &#x2F;&#x2F;创建需要的节点</span><br><span class="line">        HeroNode root&#x3D;new HeroNode(1,&quot;宋江&quot;);</span><br><span class="line">        HeroNode node2&#x3D;new HeroNode(2,&quot;吴用&quot;);</span><br><span class="line">        HeroNode node3&#x3D;new HeroNode(3,&quot;卢俊义&quot;);</span><br><span class="line">        HeroNode node4&#x3D;new HeroNode(4,&quot;林冲&quot;);</span><br><span class="line">        HeroNode node5&#x3D;new HeroNode(5,&quot;关胜&quot;);</span><br><span class="line">        &#x2F;&#x2F;说明,我们先手动创建二叉树,后面会递归方式创建二叉树</span><br><span class="line">        root.setLeft(node2);</span><br><span class="line">        root.setRight(node3);</span><br><span class="line">        node3.setRight(node4);</span><br><span class="line">        node3.setLeft(node5);</span><br><span class="line">        binaryTree.setRoot(root);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;测试</span><br><span class="line">        System.out.println(&quot;前序遍历&quot;); &#x2F;&#x2F;</span><br><span class="line">        binaryTree.preOrder();</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;中序遍历&quot;); &#x2F;&#x2F;</span><br><span class="line">        binaryTree.infixOrder();</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;后序遍历&quot;); &#x2F;&#x2F;</span><br><span class="line">        binaryTree.postOrder();</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;前序查找~~~&quot;);</span><br><span class="line">        HeroNode resNode&#x3D;binaryTree.postOrderSearch(5);</span><br><span class="line">        if(resNode!&#x3D;null)&#123;</span><br><span class="line">            System.out.println(&quot;找到了信息为:&quot;+resNode.getNo()+resNode.getName());</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            System.out.println(&quot;找不到&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;测试删除结点&quot;);</span><br><span class="line">        binaryTree.preOrder();</span><br><span class="line">        binaryTree.delNode(5);</span><br><span class="line">        System.out.println(&quot;删除后的结点&quot;);</span><br><span class="line">        binaryTree.preOrder();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * Description: 定义BinaryTree二叉树</span><br><span class="line"> *</span><br><span class="line"> * @author Todcsw</span><br><span class="line"> * @date</span><br><span class="line"> *&#x2F;</span><br><span class="line">class BinaryTree &#123;</span><br><span class="line">    private HeroNode root;</span><br><span class="line"></span><br><span class="line">    public void setRoot(HeroNode root) &#123;</span><br><span class="line">        this.root &#x3D; root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 前序遍历</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public void preOrder() &#123;</span><br><span class="line">        if (this.root !&#x3D; null) &#123;</span><br><span class="line">            this.root.preOrder();</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            System.out.println(&quot;二叉树为空无法遍历&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 中序遍历</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public void infixOrder() &#123;</span><br><span class="line">        if (this.root !&#x3D; null) &#123;</span><br><span class="line">            this.root.infixOrder();</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            System.out.println(&quot;二叉树为空无法遍历&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 后序遍历</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public void postOrder() &#123;</span><br><span class="line">        if (this.root !&#x3D; null) &#123;</span><br><span class="line">            this.root.postOrder();</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            System.out.println(&quot;二叉树为空无法遍历&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 递归删除</span><br><span class="line">     * @param no</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public void delNode(int no)&#123;</span><br><span class="line">        if(root!&#x3D;null)&#123;</span><br><span class="line">            &#x2F;&#x2F;判断root是不是要删除的</span><br><span class="line">            if(root.getNo()&#x3D;&#x3D;no)&#123;</span><br><span class="line">                root&#x3D;null;</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                &#x2F;&#x2F;递归删除</span><br><span class="line">                root.delNode(no);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            System.out.println(&quot;空树不能删除&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 前序查找</span><br><span class="line">     * @param no</span><br><span class="line">     * @return</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public HeroNode preOrderSearch(int no)&#123;</span><br><span class="line">        if(root!&#x3D;null)&#123;</span><br><span class="line">            return root.preOrderSearch(no);</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 中序查找</span><br><span class="line">     * @param no</span><br><span class="line">     * @return</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public HeroNode infixOrderSearch(int no)&#123;</span><br><span class="line">        if(root!&#x3D;null)&#123;</span><br><span class="line">            return root.infixOrderSearch(no);</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 后序查找</span><br><span class="line">     * @param no</span><br><span class="line">     * @return</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public HeroNode postOrderSearch(int no)&#123;</span><br><span class="line">        if(root!&#x3D;null)&#123;</span><br><span class="line">            return root.postOrderSearch(no);</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * Description: 创建HeroNode节点</span><br><span class="line"> *</span><br><span class="line"> * @author Todcsw</span><br><span class="line"> * @date</span><br><span class="line"> *&#x2F;</span><br><span class="line">class HeroNode &#123;</span><br><span class="line">    private int no;</span><br><span class="line">    private String name;</span><br><span class="line">    private HeroNode left; &#x2F;&#x2F;默认为Null</span><br><span class="line">    private HeroNode right; &#x2F;&#x2F;默认null</span><br><span class="line"></span><br><span class="line">    public HeroNode(int no, String name) &#123;</span><br><span class="line">        this.no &#x3D; no;</span><br><span class="line">        this.name &#x3D; name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int getNo() &#123;</span><br><span class="line">        return no;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setNo(int no) &#123;</span><br><span class="line">        this.no &#x3D; no;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getName() &#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setName(String name) &#123;</span><br><span class="line">        this.name &#x3D; name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public HeroNode getLeft() &#123;</span><br><span class="line">        return left;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setLeft(HeroNode left) &#123;</span><br><span class="line">        this.left &#x3D; left;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public HeroNode getRight() &#123;</span><br><span class="line">        return right;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setRight(HeroNode right) &#123;</span><br><span class="line">        this.right &#x3D; right;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return &quot;HeroNode&#123;&quot; +</span><br><span class="line">                &quot;no&#x3D;&quot; + no +</span><br><span class="line">                &quot;, name&#x3D;&#39;&quot; + name + &#39;\&#39;&#39; +</span><br><span class="line">                &#39;&#125;&#39;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     *递归删除节点</span><br><span class="line">     *如果删除的节点是叶子节点,则删除该节点</span><br><span class="line">     *如果删除的节点是非叶子节点,则删除该子树</span><br><span class="line">     * 1.因为我们的二叉树是单向的,所以我们是判断当前节点的子节点是否需要删除的节点,而不能去判断,当前这个结点是不是需要删除的结点</span><br><span class="line">     * 2.如果当前结点的左子结点不为空,并且左子结点就是要删除的结点,就将this.left&#x3D;null;并且就返回(结束递归删除)</span><br><span class="line">     * 3.如果当前结点的右子结点不为空,并且右子结点就是要删除的结点,就将this.right&#x3D;null;并且就返回(结束递归删除)</span><br><span class="line">     * 4.如果第2和3步没有删除结点,那么晚我们需要向左子树就行递归删除</span><br><span class="line">     * 5.如果第4步也没有删除结点,则应当向右子树进行递归删除</span><br><span class="line">     * @param no</span><br><span class="line">     *&#x2F;</span><br><span class="line"></span><br><span class="line">    public void delNode(int no)&#123;</span><br><span class="line"></span><br><span class="line">        if(this.left!&#x3D;null&amp;&amp;this.left.no&#x3D;&#x3D;no)&#123;</span><br><span class="line">            this.left&#x3D;null;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        if(this.right!&#x3D;null&amp;&amp;this.right.no&#x3D;&#x3D;no)&#123;</span><br><span class="line">            this.right&#x3D;null;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        if(this.left!&#x3D;null)&#123;</span><br><span class="line">            this.left.delNode(no);</span><br><span class="line">        &#125;</span><br><span class="line">        if(this.right!&#x3D;null)&#123;</span><br><span class="line">            this.right.delNode(no);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 编写前序遍历的方法</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public void preOrder() &#123;</span><br><span class="line">        System.out.println(this); &#x2F;&#x2F;先输出父节点</span><br><span class="line">        &#x2F;&#x2F;递归向左子树遍历</span><br><span class="line">        if (this.left !&#x3D; null) &#123;</span><br><span class="line">            this.left.preOrder();</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;递归向右子树前序遍历</span><br><span class="line">        if (this.right !&#x3D; null) &#123;</span><br><span class="line">            this.right.preOrder();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 编写中序遍历的方法</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public void infixOrder() &#123;</span><br><span class="line">        &#x2F;&#x2F;递归向左子树中序遍历</span><br><span class="line">        if (this.left !&#x3D; null) &#123;</span><br><span class="line">            this.left.infixOrder();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(this);</span><br><span class="line">        if (this.right !&#x3D; null) &#123;</span><br><span class="line">            this.right.infixOrder();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 编写后序遍历的方法</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public void postOrder() &#123;</span><br><span class="line">        &#x2F;&#x2F;递归向左子树中序遍历</span><br><span class="line">        if (this.left !&#x3D; null) &#123;</span><br><span class="line">            this.left.postOrder();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (this.right !&#x3D; null) &#123;</span><br><span class="line">            this.right.postOrder();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(this);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 前序遍历查找</span><br><span class="line">     * @param no 查找no</span><br><span class="line">     * @return 如果找到就返回该node，如果没有找到就返回Null</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public HeroNode preOrderSearch(int no)&#123;</span><br><span class="line">        System.out.println(&quot;进入前序遍历&quot;);</span><br><span class="line">        &#x2F;&#x2F;比较当前节点是不是</span><br><span class="line">        if(this.no&#x3D;&#x3D;no)&#123;</span><br><span class="line">            return this;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;则判断当前节点的左子节点是否为空,如果不为空,则递归前序查找</span><br><span class="line">        HeroNode resNode&#x3D;null;</span><br><span class="line">        if(this.left!&#x3D;null)&#123;</span><br><span class="line">            resNode&#x3D;this.left.preOrderSearch(no);</span><br><span class="line">        &#125;</span><br><span class="line">        if(resNode!&#x3D;null)&#123;</span><br><span class="line">            &#x2F;&#x2F;说明左子树找到了</span><br><span class="line">            return resNode;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;1左递归前序查找,找到节点,则返回,否则继续判断</span><br><span class="line">        &#x2F;&#x2F;2当前的结点的右子节点是否为空,如果不空,则继续向右递归前序查找</span><br><span class="line">        if(this.right!&#x3D;null)&#123;</span><br><span class="line">            resNode&#x3D;this.right.preOrderSearch(no);</span><br><span class="line">        &#125;</span><br><span class="line">        return resNode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 中序遍历查找</span><br><span class="line">     * @param no</span><br><span class="line">     * @return</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public HeroNode infixOrderSearch(int no)&#123;</span><br><span class="line">        &#x2F;&#x2F;判断当前节点的左子节点是否为空,如果不为空,则递归中序查找</span><br><span class="line">        HeroNode resNode&#x3D;null;</span><br><span class="line">        if(this.left!&#x3D;null)&#123;</span><br><span class="line">            resNode&#x3D;this.left.infixOrderSearch(no);</span><br><span class="line">        &#125;</span><br><span class="line">        if(resNode!&#x3D;null)&#123;</span><br><span class="line">            return resNode;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot;进入中序遍历&quot;);</span><br><span class="line">        if(this.no&#x3D;&#x3D;no)&#123;</span><br><span class="line">            return this;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;向右进行中序查找</span><br><span class="line">        if(this.right!&#x3D;null)&#123;</span><br><span class="line">            resNode&#x3D;this.right.infixOrderSearch(no);</span><br><span class="line">        &#125;</span><br><span class="line">        return resNode;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 后续遍历查找</span><br><span class="line">     * @param no</span><br><span class="line">     * @return</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public HeroNode postOrderSearch(int no)&#123;</span><br><span class="line"></span><br><span class="line">        HeroNode resNode&#x3D;null;</span><br><span class="line">        if(this.left!&#x3D;null)&#123;</span><br><span class="line">            resNode&#x3D;this.left.postOrderSearch(no);</span><br><span class="line">        &#125;</span><br><span class="line">        if(resNode!&#x3D;null)&#123;</span><br><span class="line">            return resNode;</span><br><span class="line">        &#125;</span><br><span class="line">        if(this.right!&#x3D;null)&#123;</span><br><span class="line">            resNode&#x3D;this.right.postOrderSearch(no);</span><br><span class="line">        &#125;</span><br><span class="line">        if(resNode!&#x3D;null)&#123;</span><br><span class="line">            return resNode;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot;进入后序遍历&quot;);</span><br><span class="line">        if(this.no&#x3D;&#x3D;no)&#123;</span><br><span class="line">            return this;</span><br><span class="line">        &#125;</span><br><span class="line">        return resNode;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;java实现二叉树的前序中序后序遍历和查找及删除&quot;&gt;&lt;a href=&quot;#java实现二叉树的前序中序后序遍历和查找及删除&quot; class=&quot;headerlink&quot; title=&quot;java实现二叉树的前序中序后序遍历和查找及删除&quot;&gt;&lt;/a&gt;java实现二叉树的前序中序
      
    
    </summary>
    
    
      <category term="数据结构" scheme="https://todcsw.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="学习" scheme="https://todcsw.github.io/tags/%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="java" scheme="https://todcsw.github.io/tags/java/"/>
    
      <category term="数据结构" scheme="https://todcsw.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>java实现哈希表</title>
    <link href="https://todcsw.github.io/2020/04/25/java%E5%AE%9E%E7%8E%B0%E5%93%88%E5%B8%8C%E8%A1%A8/"/>
    <id>https://todcsw.github.io/2020/04/25/java%E5%AE%9E%E7%8E%B0%E5%93%88%E5%B8%8C%E8%A1%A8/</id>
    <published>2020-04-25T15:29:59.000Z</published>
    <updated>2020-04-23T15:44:46.913Z</updated>
    
    <content type="html"><![CDATA[<h1 id="java实现哈希表"><a href="#java实现哈希表" class="headerlink" title="java实现哈希表"></a>java实现哈希表</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package com.csw.hashtab;</span><br><span class="line"></span><br><span class="line">import java.util.Scanner;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * @Auther: 行路</span><br><span class="line"> * @Date: Created on 2020&#x2F;4&#x2F;25 20:21 星期六</span><br><span class="line"> * @Description: com.csw.hashtab 哈希表</span><br><span class="line"> * @version: 1.0</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class HashTabDemo &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        &#x2F;&#x2F;创建哈希表</span><br><span class="line">        HashTab hashTab&#x3D;new HashTab(7);</span><br><span class="line">        &#x2F;&#x2F;写一个简单的菜单</span><br><span class="line">        String key&#x3D;&quot;&quot;;</span><br><span class="line">        Scanner scanner&#x3D;new Scanner(System.in);</span><br><span class="line">        while (true)&#123;</span><br><span class="line">            System.out.println(&quot;add:添加雇员&quot;);</span><br><span class="line">            System.out.println(&quot;list:显示雇员&quot;);</span><br><span class="line">            System.out.println(&quot;find:查找雇员&quot;);</span><br><span class="line">            System.out.println(&quot;exit:退出系统&quot;);</span><br><span class="line">            key&#x3D;scanner.next();</span><br><span class="line">            switch (key)&#123;</span><br><span class="line">                case &quot;add&quot;:</span><br><span class="line">                    System.out.println(&quot;输入id&quot;);</span><br><span class="line">                    int id&#x3D;scanner.nextInt();</span><br><span class="line">                    System.out.println(&quot;输入名字&quot;);</span><br><span class="line">                    String name&#x3D;scanner.next();</span><br><span class="line">                    &#x2F;&#x2F;创建雇员</span><br><span class="line">                    Emp emp&#x3D;new Emp(id,name);</span><br><span class="line">                    hashTab.add(emp);</span><br><span class="line">                    break;</span><br><span class="line">                case &quot;list&quot;:</span><br><span class="line">                    hashTab.list();</span><br><span class="line">                    break;</span><br><span class="line">                case &quot;find&quot;:</span><br><span class="line">                    System.out.println(&quot;请输入要查找的id&quot;);</span><br><span class="line">                    id&#x3D;scanner.nextInt();</span><br><span class="line">                    hashTab.findEmpById(id);</span><br><span class="line">                    break;</span><br><span class="line">                case &quot;exit&quot;:</span><br><span class="line">                    scanner.close();</span><br><span class="line">                    System.exit(0);</span><br><span class="line">                default:</span><br><span class="line">                    break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;创建HashTab,管理多条链表</span><br><span class="line">class HashTab&#123;</span><br><span class="line">    private EmpLinkedList[] empLinkedListArray;</span><br><span class="line">    private int size; &#x2F;&#x2F;表示共有多少条</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;构造器</span><br><span class="line">    public HashTab(int size)&#123;</span><br><span class="line">        this.size&#x3D;size;</span><br><span class="line">        &#x2F;&#x2F;初始化empLinkedListArray</span><br><span class="line">        empLinkedListArray&#x3D;new EmpLinkedList[size];</span><br><span class="line">        &#x2F;&#x2F;不能忘,分别初始化每个链表</span><br><span class="line">        for(int i&#x3D;0;i&lt;size;i++)&#123;</span><br><span class="line">            empLinkedListArray[i]&#x3D;new EmpLinkedList();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;添加雇员</span><br><span class="line">    public void add(Emp emp)&#123;</span><br><span class="line">        &#x2F;&#x2F;根据员工的id,得到该员工应当添加到那条链表</span><br><span class="line">        int empLinkedListNo&#x3D;hashFun(emp.id);</span><br><span class="line">        &#x2F;&#x2F;将emp添加到链表中</span><br><span class="line">        empLinkedListArray[empLinkedListNo].add(emp);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;遍历所有表,哈希表hashtab</span><br><span class="line">    public void list()&#123;</span><br><span class="line">        for (int i&#x3D;0;i&lt;size;i++)&#123;</span><br><span class="line">            empLinkedListArray[i].list(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;编写散列函数,使用一个简单取模法</span><br><span class="line">    public int hashFun(int id)&#123;</span><br><span class="line">        return id%size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;根据输入的Id,查找这个雇员</span><br><span class="line">    public void findEmpById(int id)&#123;</span><br><span class="line">        &#x2F;&#x2F;使用散列函数确定到那条链表</span><br><span class="line">        int empLinkedListNo&#x3D;hashFun(id);</span><br><span class="line">        Emp emp&#x3D;empLinkedListArray[empLinkedListNo].findEmpById(id);</span><br><span class="line">        if(emp!&#x3D;null)&#123;</span><br><span class="line">            &#x2F;&#x2F;找到</span><br><span class="line">            System.out.printf(&quot;在第%d条链表中找到雇员id&#x3D;%d\n&quot;,(empLinkedListNo+1),id);</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            System.out.println(&quot;在哈希表中没有找到该雇员~&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;表示一个雇员</span><br><span class="line">class Emp&#123;</span><br><span class="line">    public int id;</span><br><span class="line">    public String name;</span><br><span class="line">    public Emp next;</span><br><span class="line"></span><br><span class="line">    public Emp(int id, String name) &#123;</span><br><span class="line">        this.id &#x3D; id;</span><br><span class="line">        this.name &#x3D; name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;创建EmpLinkedList,表示链表</span><br><span class="line">class EmpLinkedList&#123;</span><br><span class="line">    &#x2F;&#x2F;头指针,执行第一个Emp,因此我们这个链表的head是直接指向第一个Emp</span><br><span class="line">    private Emp head;  &#x2F;&#x2F;默认null</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;添加雇员到链表</span><br><span class="line">    &#x2F;&#x2F;1.假定,当添加雇员时 ,id是自增的,即id的分配总是从小到大</span><br><span class="line">    &#x2F;&#x2F;因此我们将该雇员直接加入到本链表即可</span><br><span class="line">    public void add(Emp emp)&#123;</span><br><span class="line">        &#x2F;&#x2F;如果添加的是第一个雇员</span><br><span class="line">        if(head&#x3D;&#x3D;null)&#123;</span><br><span class="line">            head&#x3D;emp;</span><br><span class="line">            return ;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;如果不是第一个雇员,则使用辅助指针,帮助定位到最后</span><br><span class="line">        Emp curEmp&#x3D;head;</span><br><span class="line">        while (true) &#123;</span><br><span class="line">            if (curEmp.next &#x3D;&#x3D; null) &#123;</span><br><span class="line">                &#x2F;&#x2F;说明已经到最后了</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            curEmp &#x3D; curEmp.next; &#x2F;&#x2F;后移</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;当退出时直接将 emp加入链表</span><br><span class="line">        curEmp.next&#x3D;emp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;遍历链表的雇员信息</span><br><span class="line">    public void list(int no)&#123;</span><br><span class="line">        if(head&#x3D;&#x3D;null)&#123;</span><br><span class="line">            &#x2F;&#x2F;说明链表为空</span><br><span class="line">            System.out.println(&quot;第&quot;+(no+1)+&quot;条链表为空&quot;);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.print(&quot;第&quot;+(no+1)+&quot;条链表的信息为:&quot;);</span><br><span class="line">        Emp curEmp&#x3D;head;</span><br><span class="line">        while (true)&#123;</span><br><span class="line">            System.out.printf(&quot;-&gt;id&#x3D;%d name&#x3D;%s\t&quot;,curEmp.id,curEmp.name);</span><br><span class="line">            if(curEmp.next&#x3D;&#x3D;null)&#123;</span><br><span class="line">                &#x2F;&#x2F;说明curEmp已经是最后节点了</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            curEmp&#x3D;curEmp.next;  &#x2F;&#x2F;后移遍历</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;根据id查找雇员</span><br><span class="line">    &#x2F;&#x2F;如果查找到,就返回Emp,如果没有找到,就返回null</span><br><span class="line">    public Emp findEmpById(int id)&#123;</span><br><span class="line">        &#x2F;&#x2F;判断链表是否为空</span><br><span class="line">        if(head&#x3D;&#x3D;null)&#123;</span><br><span class="line">            System.out.println(&quot;链表未找到&quot;);</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;辅助指针</span><br><span class="line">        Emp curEmp&#x3D;head;</span><br><span class="line">        while (true)&#123;</span><br><span class="line">            if(curEmp.id&#x3D;&#x3D;id)&#123;</span><br><span class="line">                &#x2F;&#x2F;找到,这时curEMp就指向要查找的雇员</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F;退出</span><br><span class="line">            if(curEmp.next&#x3D;&#x3D;null)&#123;</span><br><span class="line">                &#x2F;&#x2F;说明遍历当前链表没有找到雇员</span><br><span class="line">                curEmp&#x3D;null;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            curEmp&#x3D;curEmp.next;</span><br><span class="line">        &#125;</span><br><span class="line">        return curEmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;java实现哈希表&quot;&gt;&lt;a href=&quot;#java实现哈希表&quot; class=&quot;headerlink&quot; title=&quot;java实现哈希表&quot;&gt;&lt;/a&gt;java实现哈希表&lt;/h1&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;t
      
    
    </summary>
    
    
      <category term="数据结构" scheme="https://todcsw.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="学习" scheme="https://todcsw.github.io/tags/%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="java" scheme="https://todcsw.github.io/tags/java/"/>
    
      <category term="数据结构" scheme="https://todcsw.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>java实现插值查找和斐波那契查找算法</title>
    <link href="https://todcsw.github.io/2020/04/24/java%E5%AE%9E%E7%8E%B0%E6%8F%92%E5%80%BC%E6%9F%A5%E6%89%BE%E5%92%8C%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95/"/>
    <id>https://todcsw.github.io/2020/04/24/java%E5%AE%9E%E7%8E%B0%E6%8F%92%E5%80%BC%E6%9F%A5%E6%89%BE%E5%92%8C%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95/</id>
    <published>2020-04-24T12:32:32.000Z</published>
    <updated>2020-04-23T15:44:42.144Z</updated>
    
    <content type="html"><![CDATA[<h1 id="java实现插值查找和斐波那契查找算法"><a href="#java实现插值查找和斐波那契查找算法" class="headerlink" title="java实现插值查找和斐波那契查找算法"></a>java实现插值查找和斐波那契查找算法</h1><h2 id="插值查找"><a href="#插值查找" class="headerlink" title="插值查找"></a>插值查找</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package com.csw.search;</span><br><span class="line"></span><br><span class="line">import java.util.Arrays;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * @Auther: 行路</span><br><span class="line"> * @Date: Created on 2020&#x2F;4&#x2F;24 16:47 星期五</span><br><span class="line"> * @Description: com.csw.search 插值查找</span><br><span class="line"> * @version: 1.0</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class InsertValueSearch &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int[] arr&#x3D;new int[100];</span><br><span class="line">        for(int i&#x3D;0;i&lt;100;i++)&#123;</span><br><span class="line">            arr[i]&#x3D;i+1;</span><br><span class="line">        &#125;</span><br><span class="line">        int i &#x3D; insertValueSearch(arr, 0, arr.length - 1, 33);</span><br><span class="line">        System.out.println(&quot;查找次数:&quot;+count+&quot;，查找到的下标为:&quot;+i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 插值查找算法</span><br><span class="line">     * 要求数组是有序的</span><br><span class="line">     * @param arr</span><br><span class="line">     * @param left</span><br><span class="line">     * @param right</span><br><span class="line">     * @param findVal</span><br><span class="line">     * @return &#x2F;&#x2F;如果找到,就返回对应的值,如果没有找到,返回-1</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public static int count&#x3D;0;</span><br><span class="line">    public static int insertValueSearch(int[] arr,int left,int right,int findVal)&#123;</span><br><span class="line">        ++count;</span><br><span class="line">        &#x2F;&#x2F;注意这两个条件必须有,否则会得到mid可能越界</span><br><span class="line">        if(left&gt;right||findVal&lt;arr[0]||findVal&gt;arr[arr.length-1])&#123;</span><br><span class="line">            return -1;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;求出mid 自适应的值</span><br><span class="line">        int mid&#x3D;left+(right-left)*(findVal-arr[left])&#x2F;(arr[right]-arr[left]);</span><br><span class="line">        int midVal&#x3D;arr[mid];</span><br><span class="line">        if(findVal&gt;midVal)&#123;</span><br><span class="line">            return insertValueSearch(arr,mid+1,right,findVal);                    &#x2F;&#x2F;说明向右递归查找</span><br><span class="line">        &#125;else if(findVal&lt;midVal)&#123;</span><br><span class="line">            return insertValueSearch(arr,left,mid-1,findVal);</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            return mid;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="斐波那契查找"><a href="#斐波那契查找" class="headerlink" title="斐波那契查找"></a>斐波那契查找</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package com.csw.search;</span><br><span class="line"></span><br><span class="line">import java.util.Arrays;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * @Auther: 行路</span><br><span class="line"> * @Date: Created on 2020&#x2F;4&#x2F;23 23:19 星期二</span><br><span class="line"> * @Description: com.csw.search 斐波那契查找算法</span><br><span class="line"> * @version: 1.0</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class FibonacciSearch &#123;</span><br><span class="line">    public static int maxSize &#x3D; 20;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int[] arr &#x3D; &#123;1, 8, 10, 89, 1000, 1234&#125;;</span><br><span class="line">        System.out.println(fibSearch(arr,1234));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;mid&#x3D;low+F(k-1)+1,后面需要使用斐波那契数列,因此我们需要先获取到一个斐波那契数列</span><br><span class="line">    &#x2F;&#x2F;非递归的方式得到斐波那契数列</span><br><span class="line">    public static int[] fib() &#123;</span><br><span class="line">        int[] f &#x3D; new int[maxSize];</span><br><span class="line">        f[0] &#x3D; 1;</span><br><span class="line">        f[1] &#x3D; 1;</span><br><span class="line">        for (int i &#x3D; 2; i &lt; maxSize; i++) &#123;</span><br><span class="line">            f[i] &#x3D; f[i - 1] + f[i - 2];</span><br><span class="line">        &#125;</span><br><span class="line">        return f;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 使用非递归</span><br><span class="line">     * 编写斐波那契查找算法</span><br><span class="line">     *</span><br><span class="line">     * @param a   数组</span><br><span class="line">     * @param key 我们需要查找的关键码</span><br><span class="line">     * @return 返回对应的小标, 如果没有-1</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public static int fibSearch(int[] a, int key) &#123;</span><br><span class="line">        int low &#x3D; 0;</span><br><span class="line">        int high &#x3D; a.length - 1;</span><br><span class="line">        int k &#x3D; 0;  &#x2F;&#x2F;表示斐波那契分割数值对应下标</span><br><span class="line">        int mid &#x3D; 0;  &#x2F;&#x2F;存放mid值</span><br><span class="line">        int[] f &#x3D; fib();  &#x2F;&#x2F;获取斐波那契数列</span><br><span class="line">        &#x2F;&#x2F;获取到斐波那契分割值的小标</span><br><span class="line">        while (high &gt; f[k] - 1) &#123;</span><br><span class="line">            k++;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;因为f[k]值大于a的长度,因此许Arrays类,构造一个新的数组,并指向a[]</span><br><span class="line">        int[] temp &#x3D; Arrays.copyOf(a, f[k]);</span><br><span class="line">        &#x2F;&#x2F;实际上需要使用a数组最后的数填充temp</span><br><span class="line">        for (int i &#x3D; high + 1; i &lt; temp.length; i++) &#123;</span><br><span class="line">            temp[i] &#x3D; a[high];</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;使用while循环来循环处理,找到我们的数key</span><br><span class="line">        while (low &lt;&#x3D; high) &#123;</span><br><span class="line">            &#x2F;&#x2F;只要这个添加满足,就可以一直找</span><br><span class="line">            mid &#x3D; low + f[k - 1] - 1;</span><br><span class="line">            if(key&lt;temp[mid])&#123;</span><br><span class="line">                &#x2F;&#x2F;说明我们应该向数组的前面查找</span><br><span class="line">                high&#x3D;mid-1;</span><br><span class="line">                &#x2F;&#x2F;1.全部元素&#x3D;前面的元素+后边的元素</span><br><span class="line">                &#x2F;&#x2F;2.f[k]&#x3D;f[k-1]+h[k-2]</span><br><span class="line">                &#x2F;&#x2F;因为前面有f[k-1]个元素,所以可以继续拆分f[k-1]&#x3D;f[k-2]+f[k-3]</span><br><span class="line">                &#x2F;&#x2F;即f[k-1]的前面继续查找k--;</span><br><span class="line">                &#x2F;&#x2F;即下次循环mid&#x3D;f[k-1-1]-1;</span><br><span class="line">                k--;</span><br><span class="line">            &#125;else if(key&gt;temp[mid])&#123; &#x2F;&#x2F;说明向数组 的后面查找</span><br><span class="line">                low&#x3D;mid+1;</span><br><span class="line">                &#x2F;&#x2F;为什么是k-&#x3D;2,1.全部元素&#x3D;前面的元素+后边的元素</span><br><span class="line">                &#x2F;&#x2F;因为后面我们有f[k-2]个元素所以我们可以继续拆分</span><br><span class="line">                &#x2F;&#x2F;mid&#x3D;f[k-1-2]-1</span><br><span class="line">                k-&#x3D;2;</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                &#x2F;&#x2F;需要确定返回的是那个下标</span><br><span class="line">                if(mid&lt;&#x3D;high)&#123;</span><br><span class="line">                    return mid;</span><br><span class="line">                &#125;else&#123;</span><br><span class="line">                    return high;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;java实现插值查找和斐波那契查找算法&quot;&gt;&lt;a href=&quot;#java实现插值查找和斐波那契查找算法&quot; class=&quot;headerlink&quot; title=&quot;java实现插值查找和斐波那契查找算法&quot;&gt;&lt;/a&gt;java实现插值查找和斐波那契查找算法&lt;/h1&gt;&lt;h2 i
      
    
    </summary>
    
    
      <category term="数据结构" scheme="https://todcsw.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="学习" scheme="https://todcsw.github.io/tags/%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="java" scheme="https://todcsw.github.io/tags/java/"/>
    
      <category term="数据结构" scheme="https://todcsw.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>java实现顺序查找和二分查找</title>
    <link href="https://todcsw.github.io/2020/04/23/java%E5%AE%9E%E7%8E%B0%E9%A1%BA%E5%BA%8F%E6%9F%A5%E6%89%BE%E5%92%8C%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"/>
    <id>https://todcsw.github.io/2020/04/23/java%E5%AE%9E%E7%8E%B0%E9%A1%BA%E5%BA%8F%E6%9F%A5%E6%89%BE%E5%92%8C%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/</id>
    <published>2020-04-23T02:12:31.000Z</published>
    <updated>2020-04-21T09:47:36.130Z</updated>
    
    <content type="html"><![CDATA[<h1 id="java实现顺序查找和二分查找"><a href="#java实现顺序查找和二分查找" class="headerlink" title="java实现顺序查找和二分查找"></a>java实现顺序查找和二分查找</h1><h2 id="顺序查找"><a href="#顺序查找" class="headerlink" title="顺序查找"></a>顺序查找</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package com.csw.search;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * @Auther: 行路</span><br><span class="line"> * @Date: Created on 2020&#x2F;4&#x2F;23 8:57 星期三</span><br><span class="line"> * @Description: com.csw.search 顺序查找</span><br><span class="line"> * @version: 1.0</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class SeqSearch &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int[] arr&#x3D;&#123;1,9,11,-1,34,89&#125;;  &#x2F;&#x2F;没有顺序的数组</span><br><span class="line">        int index&#x3D;seqSearch(arr,11);</span><br><span class="line">        if(index&#x3D;&#x3D;-1)&#123;</span><br><span class="line">            System.out.println(&quot;没有找到&quot;);</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            System.out.println(&quot;找到,下标为&#x3D;&quot;+index);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 这里我们实现的线性查找是找到一个满足条件的值,就返回</span><br><span class="line">     * @param arr</span><br><span class="line">     * @param value</span><br><span class="line">     * @return</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public static int seqSearch(int[] arr,int value)&#123;</span><br><span class="line">        &#x2F;&#x2F;线性查找是逐一比对,发现有相同的值就返回下标</span><br><span class="line">        for(int i&#x3D;0;i&lt;arr.length;i++)&#123;</span><br><span class="line">            if(arr[i]&#x3D;&#x3D;value)&#123;</span><br><span class="line">                return i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package com.csw.search;</span><br><span class="line"></span><br><span class="line">import java.util.ArrayList;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * @Auther: 行路</span><br><span class="line"> * @Date: Created on 2020&#x2F;4&#x2F;23 9:09 星期三</span><br><span class="line"> * @Description: com.csw.search 二分查找</span><br><span class="line"> * @version: 1.0</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class BinarySearch &#123;</span><br><span class="line">    &#x2F;&#x2F;二分查找的前提是该数组必须是有序的</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int[] arr &#x3D; &#123;1, 8,10, 89, 1000, 1000,1000, 1234&#125;;</span><br><span class="line">        int resIndex &#x3D; binarySearch(arr, 0, arr.length - 1, 1000);</span><br><span class="line">        System.out.println(&quot;查找次数为:&quot;+count+&quot;,查找的下标为:&quot;+resIndex);</span><br><span class="line">        ArrayList&lt;Integer&gt; list &#x3D; binarySearch2(arr, 0, arr.length - 1, 1000);</span><br><span class="line">        System.out.println(list);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;二分查找</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * @param arr     数组</span><br><span class="line">     * @param left    左边的索引</span><br><span class="line">     * @param right   右边的索引</span><br><span class="line">     * @param findVal 要查找的值</span><br><span class="line">     * @return 如果找到返回下标, 如果没有找到, 就返回-1</span><br><span class="line">     *&#x2F;</span><br><span class="line"></span><br><span class="line">    public static int count&#x3D;0;</span><br><span class="line">    public static int binarySearch(int[] arr, int left, int right, int findVal) &#123;</span><br><span class="line">        &#x2F;&#x2F;当left&gt;right时,说明递归整个数组,但是没有找到</span><br><span class="line">        ++count;</span><br><span class="line">        if (left &gt; right) &#123;</span><br><span class="line">            return -1;</span><br><span class="line">        &#125;</span><br><span class="line">        int mid &#x3D; (left + right) &#x2F; 2;</span><br><span class="line">        int midVal &#x3D; arr[mid];</span><br><span class="line">        if (findVal &gt; midVal) &#123;</span><br><span class="line">            return binarySearch(arr, mid + 1, right, findVal); &#x2F;&#x2F;向右递归</span><br><span class="line">        &#125; else if (findVal &lt; midVal) &#123;</span><br><span class="line">            return binarySearch(arr, left, mid - 1, findVal);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return mid;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 课后思考题:当有多个相同的数值时,如何将所有的数组都查到,比如很多个1000</span><br><span class="line">     * 思路分析</span><br><span class="line">     * 1.找到mid值时,不马上返回</span><br><span class="line">     * 2.向mid索引值左边扫描,将所有满足1000的元素的下标,加入到集合ArrayList</span><br><span class="line">     * 3.向mid索引值的右边扫描,将所有满足1000,的元素下标,加入到ArrayList</span><br><span class="line">     *</span><br><span class="line">     * @param arr</span><br><span class="line">     * @param left</span><br><span class="line">     * @param right</span><br><span class="line">     * @param findVal</span><br><span class="line">     * @return</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public static ArrayList&lt;Integer&gt; binarySearch2(int[] arr, int left, int right, int findVal) &#123;</span><br><span class="line">        &#x2F;&#x2F;当left&gt;right时,说明递归整个数组,但是没有找到</span><br><span class="line">        if (left &gt; right) &#123;</span><br><span class="line">            return new ArrayList&lt;Integer&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">        int mid &#x3D; (left + right) &#x2F; 2;</span><br><span class="line">        int midVal &#x3D; arr[mid];</span><br><span class="line">        if (findVal &gt; midVal) &#123;</span><br><span class="line">            return binarySearch2(arr, mid + 1, right, findVal); &#x2F;&#x2F;向右递归</span><br><span class="line">        &#125; else if (findVal &lt; midVal) &#123;</span><br><span class="line">            return binarySearch2(arr, left, mid - 1, findVal);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            &#x2F;&#x2F;</span><br><span class="line">            ArrayList&lt;Integer&gt; resIndexList &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">            &#x2F;&#x2F;左边</span><br><span class="line">            int temp &#x3D; mid - 1;</span><br><span class="line">            while (true) &#123;</span><br><span class="line">                if (temp &lt; 0 || arr[temp] !&#x3D; findVal)&#123;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">                resIndexList.add(temp);</span><br><span class="line">                temp-&#x3D;1;  &#x2F;&#x2F;temp左移</span><br><span class="line">            &#125;</span><br><span class="line">            resIndexList.add(mid); &#x2F;&#x2F;中间</span><br><span class="line">            &#x2F;&#x2F;右边</span><br><span class="line">            temp&#x3D;mid+1;</span><br><span class="line">            while (true) &#123;</span><br><span class="line">                if (temp &gt;arr.length-1 || arr[temp] !&#x3D; findVal)&#123;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">                resIndexList.add(temp);</span><br><span class="line">                temp+&#x3D;1;  &#x2F;&#x2F;temp左移</span><br><span class="line">            &#125;</span><br><span class="line">            return resIndexList;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;java实现顺序查找和二分查找&quot;&gt;&lt;a href=&quot;#java实现顺序查找和二分查找&quot; class=&quot;headerlink&quot; title=&quot;java实现顺序查找和二分查找&quot;&gt;&lt;/a&gt;java实现顺序查找和二分查找&lt;/h1&gt;&lt;h2 id=&quot;顺序查找&quot;&gt;&lt;a href
      
    
    </summary>
    
    
      <category term="数据结构" scheme="https://todcsw.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="学习" scheme="https://todcsw.github.io/tags/%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="java" scheme="https://todcsw.github.io/tags/java/"/>
    
      <category term="数据结构" scheme="https://todcsw.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>java实现基数排序和堆排序</title>
    <link href="https://todcsw.github.io/2020/04/22/java%E5%AE%9E%E7%8E%B0%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F%E5%92%8C%E5%A0%86%E6%8E%92%E5%BA%8F/"/>
    <id>https://todcsw.github.io/2020/04/22/java%E5%AE%9E%E7%8E%B0%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F%E5%92%8C%E5%A0%86%E6%8E%92%E5%BA%8F/</id>
    <published>2020-04-22T09:33:36.000Z</published>
    <updated>2020-04-26T07:51:18.736Z</updated>
    
    <content type="html"><![CDATA[<h1 id="java实现基数排序和堆排序"><a href="#java实现基数排序和堆排序" class="headerlink" title="java实现基数排序和堆排序"></a>java实现基数排序和堆排序</h1><h2 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package com.csw.sort;</span><br><span class="line"></span><br><span class="line">import java.text.SimpleDateFormat;</span><br><span class="line">import java.util.Arrays;</span><br><span class="line">import java.util.Date;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * @Auther: 行路</span><br><span class="line"> * @Date: Created on 2020&#x2F;4&#x2F;22 16:27 星期三</span><br><span class="line"> * @Description: com.csw.sort 基数排序(目前只能排序正数)</span><br><span class="line"> * @version: 1.0</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class RadixSort &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int[] arr &#x3D; &#123;53, 3, 542, 748, 14, 214&#125;;</span><br><span class="line">        radixSort(arr);</span><br><span class="line">        testTime(); &#x2F;&#x2F;测试时间</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 基数排序</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public static void radixSort(int[] arr) &#123;</span><br><span class="line">        System.out.println(&quot;基数排序~~~~&quot;);</span><br><span class="line">        &#x2F;&#x2F;1.得到数组中最大的数的位数</span><br><span class="line">        int max &#x3D; arr[0];&#x2F;&#x2F;假设第一数就是最大值</span><br><span class="line">        for (int i &#x3D; 1; i &lt; arr.length; i++) &#123;</span><br><span class="line">            if (arr[i] &gt; max) &#123;</span><br><span class="line">                max &#x3D; arr[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;得到最大数是几位数</span><br><span class="line">        int maxLength &#x3D; (max + &quot;&quot;).length();</span><br><span class="line"></span><br><span class="line">        int[][] bucket &#x3D; new int[10][arr.length];</span><br><span class="line">        int[] bucketElementCounts &#x3D; new int[10];</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;使用循环将代码处理</span><br><span class="line">        for (int i &#x3D; 0, n &#x3D; 1; i &lt; maxLength; i++, n *&#x3D; 10) &#123;</span><br><span class="line">            &#x2F;&#x2F;争对每个元素对应位进行判断,第一次是个位,第二次是十位 ,第三次是百位</span><br><span class="line">            for (int j &#x3D; 0; j &lt; arr.length; j++) &#123;</span><br><span class="line">                &#x2F;&#x2F;取出每个元素的对应的值</span><br><span class="line">                int digitOfElement &#x3D; arr[j] &#x2F; n % 10;</span><br><span class="line">                &#x2F;&#x2F;放入到对应的桶中</span><br><span class="line">                bucket[digitOfElement][bucketElementCounts[digitOfElement]] &#x3D; arr[j];</span><br><span class="line">                bucketElementCounts[digitOfElement]++;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F;按照这个桶的顺序(一维数组的下标依次取出数据,放入原来的数组)</span><br><span class="line">            int index &#x3D; 0;</span><br><span class="line">            &#x2F;&#x2F;遍历每一个桶,并将桶中是数据,放入到原数组中</span><br><span class="line">            for (int k &#x3D; 0; k &lt; bucketElementCounts.length; k++) &#123;</span><br><span class="line">                &#x2F;&#x2F;如果桶中有数据,才放入到原数组中</span><br><span class="line">                if (bucketElementCounts[k] !&#x3D; 0) &#123;</span><br><span class="line">                    &#x2F;&#x2F;循环该桶即第k个桶,放入</span><br><span class="line">                    for (int l &#x3D; 0; l &lt; bucketElementCounts[k]; l++) &#123;</span><br><span class="line">                        &#x2F;&#x2F;取出元素放入到arr</span><br><span class="line">                        arr[index++] &#x3D; bucket[k][l];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                &#x2F;&#x2F;第i+1论处理后,需要将每个bucketElementCounts[k]&#x3D;0!!!!1</span><br><span class="line">                bucketElementCounts[k] &#x3D; 0;</span><br><span class="line">            &#125;</span><br><span class="line">           &#x2F;&#x2F; System.out.println(&quot;第&quot; + (i + 1) + &quot;轮,对个位的排序处理arr&#x3D;&quot; + Arrays.toString(arr));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 测试时间</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public static void testTime() &#123;</span><br><span class="line">        int[] arr &#x3D; new int[8000000];</span><br><span class="line">        for (int i &#x3D; 0; i &lt; 8000000; i++) &#123;</span><br><span class="line">            arr[i] &#x3D; (int) (Math.random() * 8000000);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Date date1 &#x3D; new Date();</span><br><span class="line">        SimpleDateFormat simpleDateFormatter &#x3D; new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);</span><br><span class="line">        String date1Str &#x3D; simpleDateFormatter.format(date1);</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;排序前的时间是&#x3D;&quot; + date1Str);</span><br><span class="line">        long l1 &#x3D; System.currentTimeMillis();</span><br><span class="line">        radixSort(arr);</span><br><span class="line"></span><br><span class="line">        Date date2 &#x3D; new Date();</span><br><span class="line">        &#x2F;&#x2F;   SimpleDateFormat simpleDateFormatter &#x3D; new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);</span><br><span class="line">        String date2Str &#x3D; simpleDateFormatter.format(date2);</span><br><span class="line">        System.out.println(&quot;排序后的时间是&#x3D;&quot; + date2Str);</span><br><span class="line">        long l2 &#x3D; System.currentTimeMillis();</span><br><span class="line">        System.out.println(&quot;耗时毫秒数为:&quot; + (l2 - l1));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 基数排序方法 思路分析得到推论</span><br><span class="line">     * @param arr</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public static void radixSortTest(int[] arr) &#123;</span><br><span class="line">        &#x2F;&#x2F;第一轮排序(针对每个元素的各位进行排序处理)</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;定义一个二维数组,表示10个桶,每个桶就是一个二维数组</span><br><span class="line">        &#x2F;&#x2F;1.二维数组包含10个一维数组</span><br><span class="line">        &#x2F;&#x2F;2.为了防止在放数的时候数据溢出,则每个一位数组(桶),大小位arr.length</span><br><span class="line">        &#x2F;&#x2F;3.名明确,基数排序是使用空间换时间</span><br><span class="line">        int[][] bucket &#x3D; new int[10][arr.length];</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;为了记录每个桶中,实际存放了多少数据,我们定义一个一维数组记录各个桶的每次放入的数据个数</span><br><span class="line">        &#x2F;&#x2F;bucketElementCounts[0],记录的就是bucket[0]桶的放入数据个数</span><br><span class="line">        int[] bucketElementCounts &#x3D; new int[10];</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;第一轮</span><br><span class="line">        for (int j &#x3D; 0; j &lt; arr.length; j++) &#123;</span><br><span class="line">            &#x2F;&#x2F;取出每个元素的个位的值</span><br><span class="line">            int digitOfElement &#x3D; arr[j] % 10;</span><br><span class="line">            &#x2F;&#x2F;放入到对应的桶中</span><br><span class="line">            bucket[digitOfElement][bucketElementCounts[digitOfElement]] &#x3D; arr[j];</span><br><span class="line">            bucketElementCounts[digitOfElement]++;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;按照这个桶的顺序(一维数组的下标依次取出数据,放入原来的数组)</span><br><span class="line">        int index &#x3D; 0;</span><br><span class="line">        &#x2F;&#x2F;遍历每一个桶,并将桶中是数据,放入到原数组中</span><br><span class="line">        for (int k &#x3D; 0; k &lt; bucketElementCounts.length; k++) &#123;</span><br><span class="line">            &#x2F;&#x2F;如果桶中有数据,才放入到原数组中</span><br><span class="line">            if (bucketElementCounts[k] !&#x3D; 0) &#123;</span><br><span class="line">                &#x2F;&#x2F;循环该桶即第k个桶,放入</span><br><span class="line">                for (int l &#x3D; 0; l &lt; bucketElementCounts[k]; l++) &#123;</span><br><span class="line">                    &#x2F;&#x2F;取出元素放入到arr</span><br><span class="line">                    arr[index++] &#x3D; bucket[k][l];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F;第1论处理后,需要将每个bucketElementCounts[k]&#x3D;0!!!!1</span><br><span class="line">            bucketElementCounts[k] &#x3D; 0;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot;第一轮,对个位的排序处理arr&#x3D;&quot; + Arrays.toString(arr));</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">        &#x2F;&#x2F;第二轮 对10位</span><br><span class="line">        for (int j &#x3D; 0; j &lt; arr.length; j++) &#123;</span><br><span class="line">            &#x2F;&#x2F;取出每个元素的个位的值</span><br><span class="line">            int digitOfElement &#x3D; arr[j] &#x2F; 10 % 10;</span><br><span class="line">            &#x2F;&#x2F;放入到对应的桶中</span><br><span class="line">            bucket[digitOfElement][bucketElementCounts[digitOfElement]] &#x3D; arr[j];</span><br><span class="line">            bucketElementCounts[digitOfElement]++;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;按照这个桶的顺序(一维数组的下标依次取出数据,放入原来的数组)</span><br><span class="line">        index &#x3D; 0;</span><br><span class="line">        &#x2F;&#x2F;遍历每一个桶,并将桶中是数据,放入到原数组中</span><br><span class="line">        for (int k &#x3D; 0; k &lt; bucketElementCounts.length; k++) &#123;</span><br><span class="line">            &#x2F;&#x2F;如果桶中有数据,才放入到原数组中</span><br><span class="line">            if (bucketElementCounts[k] !&#x3D; 0) &#123;</span><br><span class="line">                &#x2F;&#x2F;循环该桶即第k个桶,放入</span><br><span class="line">                for (int l &#x3D; 0; l &lt; bucketElementCounts[k]; l++) &#123;</span><br><span class="line">                    &#x2F;&#x2F;取出元素放入到arr</span><br><span class="line">                    arr[index++] &#x3D; bucket[k][l];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F;第1论处理后,需要将每个bucketElementCounts[k]&#x3D;0!!!!1</span><br><span class="line">            bucketElementCounts[k] &#x3D; 0;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot;第二轮,对个位的排序处理arr&#x3D;&quot; + Arrays.toString(arr));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">        &#x2F;&#x2F;第三轮</span><br><span class="line">        for (int j &#x3D; 0; j &lt; arr.length; j++) &#123;</span><br><span class="line">            &#x2F;&#x2F;取出每个元素的个位的值</span><br><span class="line">            int digitOfElement &#x3D; arr[j] &#x2F; 100 % 10;</span><br><span class="line">            &#x2F;&#x2F;放入到对应的桶中</span><br><span class="line">            bucket[digitOfElement][bucketElementCounts[digitOfElement]] &#x3D; arr[j];</span><br><span class="line">            bucketElementCounts[digitOfElement]++;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;按照这个桶的顺序(一维数组的下标依次取出数据,放入原来的数组)</span><br><span class="line">        index &#x3D; 0;</span><br><span class="line">        &#x2F;&#x2F;遍历每一个桶,并将桶中是数据,放入到原数组中</span><br><span class="line">        for (int k &#x3D; 0; k &lt; bucketElementCounts.length; k++) &#123;</span><br><span class="line">            &#x2F;&#x2F;如果桶中有数据,才放入到原数组中</span><br><span class="line">            if (bucketElementCounts[k] !&#x3D; 0) &#123;</span><br><span class="line">                &#x2F;&#x2F;循环该桶即第k个桶,放入</span><br><span class="line">                for (int l &#x3D; 0; l &lt; bucketElementCounts[k]; l++) &#123;</span><br><span class="line">                    &#x2F;&#x2F;取出元素放入到arr</span><br><span class="line">                    arr[index++] &#x3D; bucket[k][l];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F;第1论处理后,需要将每个bucketElementCounts[k]&#x3D;0!!!!1</span><br><span class="line">            bucketElementCounts[k] &#x3D; 0;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot;第三轮,对个位的排序处理arr&#x3D;&quot; + Arrays.toString(arr));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package com.csw.sort;</span><br><span class="line"></span><br><span class="line">import java.text.SimpleDateFormat;</span><br><span class="line">import java.util.Arrays;</span><br><span class="line">import java.util.Date;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * @Auther: 行路</span><br><span class="line"> * @Date: Created on 2020&#x2F;4&#x2F;26 14:18 星期日</span><br><span class="line"> * @Description: com.csw.sort 堆排序</span><br><span class="line"> * @version: 1.0</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class Heapsort &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        &#x2F;&#x2F;要求将数组升序排列</span><br><span class="line">        int arr[]&#x3D;&#123;4,6,8,5,9&#125;;</span><br><span class="line">        heapSort(arr);</span><br><span class="line">        testTime();&#x2F;&#x2F;测试时间</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;System.out.println(&#39;0&#39;*&#39;0&#39;&#x2F;(&#39;0&#39;+&#39;0&#39;)&#x3D;&#x3D;24);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;编写一个堆排序的方法</span><br><span class="line">    public static void heapSort(int arr[])&#123;</span><br><span class="line">        int temp&#x3D;0;</span><br><span class="line">        System.out.println(&quot;堆排序&quot;);</span><br><span class="line">        &#x2F;&#x2F;从堆底开始调整</span><br><span class="line">        for(int i&#x3D;arr.length&#x2F;2-1;i&gt;&#x3D;0;i--)&#123;</span><br><span class="line">            adjustHeap(arr,i,arr.length);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        for(int j&#x3D;arr.length-1;j&gt;0;j--)&#123;</span><br><span class="line">            &#x2F;&#x2F;交换</span><br><span class="line">            temp&#x3D;arr[j];</span><br><span class="line">            arr[j]&#x3D;arr[0];</span><br><span class="line">            arr[0]&#x3D;temp;</span><br><span class="line">            &#x2F;&#x2F;因为交换后只有栈顶不符合,所以直接调整栈顶</span><br><span class="line">            adjustHeap(arr,0,j);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot;数组&#x3D;&quot;+ Arrays.toString(arr));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;将一个数组(二叉树),调整成一个大顶推</span><br><span class="line"></span><br><span class="line">    &#x2F;** 功能：完成将以i对应的非叶子结点的树,调整成大顶堆</span><br><span class="line">     *  int[] arr&#x3D;&#123;4,6,8,5,9&#125; 调整后i&#x3D;1 adjustHeap-&gt;调整成49856</span><br><span class="line">     *  再次调用adjustHeap传入的是0 调整成96854</span><br><span class="line">     *  调整需要从下至上</span><br><span class="line">     * @param arr   表示待调整的数组</span><br><span class="line">     * @param i     表示非叶子结点在数组中的索引</span><br><span class="line">     * @param length 表示对多少个元素继续调整,length是在主键减少的</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public static void adjustHeap(int[] arr,int i,int length)&#123;</span><br><span class="line">        int temp&#x3D;arr[i]; &#x2F;&#x2F;取出当前元素的值,保存在临时变量中</span><br><span class="line">        &#x2F;&#x2F;开始调整 k&#x3D;i*2+1 k是i结点的左子结点</span><br><span class="line">        for(int k&#x3D;i*2+1;k&lt;length;k&#x3D;k*2+1)&#123;</span><br><span class="line">            if(k+1&lt;length&amp;&amp;arr[k]&lt;arr[k+1])&#123;</span><br><span class="line">                &#x2F;&#x2F;说明左子结点小于右子结点的值</span><br><span class="line">                k++;</span><br><span class="line">            &#125;</span><br><span class="line">            if(arr[k]&gt;temp)&#123;</span><br><span class="line">                &#x2F;&#x2F;如果子结点大于父结点</span><br><span class="line">                arr[i]&#x3D;arr[k]; &#x2F;&#x2F;把较大的值赋给当前结点</span><br><span class="line">                i&#x3D;k; &#x2F;&#x2F;i指向k,继续循环比较</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                break; &#x2F;&#x2F;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;当for循环后,已经将以i为父结点的树的最大值,放在了最顶(局部)</span><br><span class="line">        arr[i]&#x3D;temp; &#x2F;&#x2F;将temp值放到调整后的位置</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 测试时间</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public static void testTime() &#123;</span><br><span class="line">        int[] arr &#x3D; new int[80000];</span><br><span class="line">        for (int i &#x3D; 0; i &lt; 80000; i++) &#123;</span><br><span class="line">            arr[i] &#x3D; (int) (Math.random() * 80000);</span><br><span class="line">        &#125;</span><br><span class="line">        int[] temp&#x3D;new int[arr.length];</span><br><span class="line">        Date date1 &#x3D; new Date();</span><br><span class="line">        SimpleDateFormat simpleDateFormatter &#x3D; new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);</span><br><span class="line">        String date1Str &#x3D; simpleDateFormatter.format(date1);</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;排序前的时间是&#x3D;&quot; + date1Str);</span><br><span class="line">        long l1 &#x3D; System.currentTimeMillis();</span><br><span class="line">        heapSort(arr);</span><br><span class="line"></span><br><span class="line">        Date date2 &#x3D; new Date();</span><br><span class="line">        &#x2F;&#x2F;   SimpleDateFormat simpleDateFormatter &#x3D; new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);</span><br><span class="line">        String date2Str &#x3D; simpleDateFormatter.format(date2);</span><br><span class="line">        System.out.println(&quot;排序后的时间是&#x3D;&quot; + date2Str);</span><br><span class="line">        long l2 &#x3D; System.currentTimeMillis();</span><br><span class="line">        System.out.println(&quot;耗时毫秒数为:&quot; + (l2 - l1));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;java实现基数排序和堆排序&quot;&gt;&lt;a href=&quot;#java实现基数排序和堆排序&quot; class=&quot;headerlink&quot; title=&quot;java实现基数排序和堆排序&quot;&gt;&lt;/a&gt;java实现基数排序和堆排序&lt;/h1&gt;&lt;h2 id=&quot;基数排序&quot;&gt;&lt;a href=&quot;#基
      
    
    </summary>
    
    
      <category term="数据结构" scheme="https://todcsw.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="学习" scheme="https://todcsw.github.io/tags/%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="java" scheme="https://todcsw.github.io/tags/java/"/>
    
      <category term="数据结构" scheme="https://todcsw.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>java实现快速排序和归并排序</title>
    <link href="https://todcsw.github.io/2020/04/21/java%E5%AE%9E%E7%8E%B0%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%E5%92%8C%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/"/>
    <id>https://todcsw.github.io/2020/04/21/java%E5%AE%9E%E7%8E%B0%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%E5%92%8C%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/</id>
    <published>2020-04-21T04:35:32.000Z</published>
    <updated>2020-04-20T13:13:47.851Z</updated>
    
    <content type="html"><![CDATA[<h1 id="java实现快速排序和归并排序"><a href="#java实现快速排序和归并排序" class="headerlink" title="java实现快速排序和归并排序"></a>java实现快速排序和归并排序</h1><h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package com.csw.sort;</span><br><span class="line"></span><br><span class="line">import java.text.SimpleDateFormat;</span><br><span class="line">import java.util.Arrays;</span><br><span class="line">import java.util.Date;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * @Auther: 行路</span><br><span class="line"> * @Date: Created on 2020&#x2F;4&#x2F;20 15:50 星期一</span><br><span class="line"> * @Description: com.csw.sort 快速排序</span><br><span class="line"> * @version: 1.0</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class QuickSort &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int[] arr &#x3D; &#123;-9, 78, 0, 23, -567, 70, 12, 32, -1&#125;;</span><br><span class="line">        quickSort(arr, 0, arr.length - 1);</span><br><span class="line">        System.out.println(&quot;arr&#x3D;&quot; + Arrays.toString(arr));</span><br><span class="line">        testTime();  &#x2F;&#x2F;测试快速排序时间</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 快排</span><br><span class="line">     * @param a</span><br><span class="line">     * @param low</span><br><span class="line">     * @param high</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public static void quickSort(int a[],int low,int high) &#123;</span><br><span class="line">        if(low&lt;high) &#123;</span><br><span class="line">            int i&#x3D;partition(a,low,high);</span><br><span class="line">            quickSort(a,low,i-1);</span><br><span class="line">            quickSort(a,i+1,high);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public static int partition(int array[],int low,int high) &#123;</span><br><span class="line">        &#x2F;&#x2F;用子序列的第一个作为基准</span><br><span class="line">        int temp&#x3D;array[low];</span><br><span class="line">        int i&#x3D;low;</span><br><span class="line">        int j&#x3D;high;</span><br><span class="line">        while(i!&#x3D;j) &#123;</span><br><span class="line">            while(i&lt;j&amp;&amp;array[j]&gt;temp) &#123;</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">            if(i&lt;j) &#123;</span><br><span class="line">                array[i]&#x3D;array[j];</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            while(i&lt;j&amp;&amp;array[i]&lt;temp) &#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            if(i&lt;j) &#123;</span><br><span class="line">                array[j]&#x3D;array[i];</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        array[i]&#x3D;temp;</span><br><span class="line">        return i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 快排2</span><br><span class="line">     * @param arr</span><br><span class="line">     * @param left</span><br><span class="line">     * @param right</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public static void quickSort2(int[] arr, int left, int right) &#123;</span><br><span class="line">        int l &#x3D; left; &#x2F;&#x2F;左下标</span><br><span class="line">        int r &#x3D; right; &#x2F;&#x2F;右下标</span><br><span class="line">        &#x2F;&#x2F;pivot 中轴值</span><br><span class="line">        int pivot &#x3D; arr[(left + right) &#x2F; 2];</span><br><span class="line">        int temp &#x3D; 0; &#x2F;&#x2F;临时变量</span><br><span class="line">        &#x2F;&#x2F;while循环的目的是让比pivot值放到左边</span><br><span class="line">        &#x2F;&#x2F;比pivot值放到右边</span><br><span class="line">        while (l &lt; r) &#123;</span><br><span class="line">            &#x2F;&#x2F;在pivot的左边一直找,找到大于等于pivot值,才退出</span><br><span class="line">            while (arr[l] &lt; pivot) &#123;</span><br><span class="line">                l +&#x3D; 1;</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F;在pivot的右边一直找,找到大于等于pivot值,才退出</span><br><span class="line">            while (arr[r] &gt; pivot) &#123;</span><br><span class="line">                r -&#x3D; 1;</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F;如果l&gt;&#x3D;r说明pivot的左右两边的值已经按照左边全部是</span><br><span class="line">            &#x2F;&#x2F;小于等于pivot的值,右边全是大于等于pivot的值</span><br><span class="line">            if (l &gt;&#x3D; r) &#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F;交换</span><br><span class="line">            temp &#x3D; arr[l];</span><br><span class="line">            arr[l] &#x3D; arr[r];</span><br><span class="line">            arr[r] &#x3D; temp;</span><br><span class="line">            &#x2F;&#x2F;如果交换完后,发现这个arr[l]&#x3D;&#x3D;pivot值相等--,前移</span><br><span class="line">            if (arr[l] &#x3D;&#x3D; pivot) &#123;</span><br><span class="line">                r -&#x3D; 1;</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F;如果交换完后,发现这个arr[r]&#x3D;&#x3D;pivot值相等l++,后移</span><br><span class="line">            if (arr[r] &#x3D;&#x3D; pivot) &#123;</span><br><span class="line">                l +&#x3D; 1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;如果l&#x3D;&#x3D;r,必须l++,r--否则为栈溢出</span><br><span class="line">        if (l &#x3D;&#x3D; r) &#123;</span><br><span class="line">            l +&#x3D; 1;</span><br><span class="line">            r -&#x3D; 1;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;向右递归</span><br><span class="line">        if (left &lt; r) &#123;</span><br><span class="line">            quickSort(arr, left, r);</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;向右递归</span><br><span class="line">        if (right &gt; l) &#123;</span><br><span class="line">            quickSort(arr, l, right);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 测试时间</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public static void testTime() &#123;</span><br><span class="line">        int[] arr &#x3D; new int[8000000];</span><br><span class="line">        for (int i &#x3D; 0; i &lt; 8000000; i++) &#123;</span><br><span class="line">            arr[i] &#x3D; (int) (Math.random() * 8000000);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Date date1 &#x3D; new Date();</span><br><span class="line">        SimpleDateFormat simpleDateFormatter &#x3D; new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);</span><br><span class="line">        String date1Str &#x3D; simpleDateFormatter.format(date1);</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;排序前的时间是&#x3D;&quot; + date1Str);</span><br><span class="line">        long l1 &#x3D; System.currentTimeMillis();</span><br><span class="line">        quickSort(arr, 0, arr.length - 1);</span><br><span class="line"></span><br><span class="line">        Date date2 &#x3D; new Date();</span><br><span class="line">        &#x2F;&#x2F;   SimpleDateFormat simpleDateFormatter &#x3D; new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);</span><br><span class="line">        String date2Str &#x3D; simpleDateFormatter.format(date2);</span><br><span class="line">        System.out.println(&quot;排序后的时间是&#x3D;&quot; + date2Str);</span><br><span class="line">        long l2 &#x3D; System.currentTimeMillis();</span><br><span class="line">        System.out.println(&quot;耗时毫秒数为:&quot; + (l2 - l1));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package com.csw.sort;</span><br><span class="line"></span><br><span class="line">import java.text.SimpleDateFormat;</span><br><span class="line">import java.util.Arrays;</span><br><span class="line">import java.util.Date;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * @Auther: 行路</span><br><span class="line"> * @Date: Created on 2020&#x2F;4&#x2F;20 17:01 星期一</span><br><span class="line"> * @Description: com.csw.sort 归并排序</span><br><span class="line"> * @version: 1.0</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class MergeSort &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int[] arr &#x3D; &#123;8, 4, 5, 7, 1, 3, 6, 2&#125;;  &#x2F;&#x2F;merge的次数 arr.length-1次</span><br><span class="line">        int[] temp&#x3D;new int[arr.length]; &#x2F;&#x2F;归并排序,需要一个额外的空间</span><br><span class="line">        mergeSort(arr,0,arr.length-1,temp);</span><br><span class="line">        System.out.println(&quot;归并排序后&quot;+ Arrays.toString(arr));</span><br><span class="line"></span><br><span class="line">        testTime(); &#x2F;&#x2F;测试归并排序时间</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;分+和</span><br><span class="line">    public static void mergeSort(int[] arr,int left,int right,int[] temp)&#123;</span><br><span class="line">        if(left&lt;right)&#123;</span><br><span class="line">            int mid&#x3D;(left+right)&#x2F;2; &#x2F;&#x2F;中间索引</span><br><span class="line">            &#x2F;&#x2F;向左递归进行分解</span><br><span class="line">            mergeSort(arr,left,mid,temp);</span><br><span class="line">            &#x2F;&#x2F;向右递归进行分解</span><br><span class="line">            mergeSort(arr,mid+1,right,temp);</span><br><span class="line">            &#x2F;&#x2F;到合并</span><br><span class="line">            merge(arr,left,mid,right,temp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 合并的方法</span><br><span class="line">     *</span><br><span class="line">     * @param arr   待排序的原始数组</span><br><span class="line">     * @param left  左边有序序列的初始索引</span><br><span class="line">     * @param mid   中间索引</span><br><span class="line">     * @param right 右边索引</span><br><span class="line">     * @param temp  做中转数组</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public static void merge(int[] arr, int left, int mid, int right, int[] temp) &#123;</span><br><span class="line">        int i &#x3D; left; &#x2F;&#x2F;初始化i,左边有序序列的初始索引</span><br><span class="line">        int j &#x3D; mid + 1;&#x2F;&#x2F;初始化j,右边有序序列的初始索引</span><br><span class="line">        int t &#x3D; 0; &#x2F;&#x2F;指向temp数组的当前索引</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;(一)先把左右两边(有序)的数据按照规则填充到temp数组</span><br><span class="line">        &#x2F;&#x2F;直到左右两边的有序序列,有一边处理完毕为止</span><br><span class="line">        while (i &lt;&#x3D; mid &amp;&amp; j &lt;&#x3D; right) &#123;  &#x2F;&#x2F;继续</span><br><span class="line">            &#x2F;&#x2F;如果发现左边的有序序列的当前元素,小于等于右边有序序列的当前元素</span><br><span class="line">            &#x2F;&#x2F;即将左边的当前元素拷贝到temp数组中</span><br><span class="line">            &#x2F;&#x2F;然后t往后移</span><br><span class="line">            if (arr[i] &lt;&#x3D; arr[j]) &#123;</span><br><span class="line">                temp[t] &#x3D; arr[i];</span><br><span class="line">                t +&#x3D; 1;</span><br><span class="line">                i +&#x3D; 1;</span><br><span class="line">            &#125; else &#123; &#x2F;&#x2F;反之,右边的有序序列当前元素小于左边的</span><br><span class="line">                temp[t] &#x3D; arr[j];</span><br><span class="line">                t +&#x3D; 1;</span><br><span class="line">                j +&#x3D; 1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;(二)把剩余数据的一边的数据依次全部填充到temp中</span><br><span class="line">        while (i &lt;&#x3D; mid) &#123; &#x2F;&#x2F;左边的有序序列还有剩余元素,就全部填充到temp</span><br><span class="line">            temp[t] &#x3D; arr[i];</span><br><span class="line">            t +&#x3D; 1;</span><br><span class="line">            i +&#x3D; 1;</span><br><span class="line">        &#125;</span><br><span class="line">        while (j &lt;&#x3D; right) &#123;</span><br><span class="line">            temp[t] &#x3D; arr[j];</span><br><span class="line">            t +&#x3D; 1;</span><br><span class="line">            j +&#x3D; 1;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;(三)将temp数组的元素拷贝到arr</span><br><span class="line">        &#x2F;&#x2F;注意并不是每次都拷贝所有</span><br><span class="line">        t &#x3D; 0;</span><br><span class="line">        int tempLeft &#x3D; left;</span><br><span class="line">        while (tempLeft&lt;&#x3D;right)&#123;</span><br><span class="line">            &#x2F;&#x2F;第一次合并tempLeft&#x3D;0,right&#x3D;1 &#x2F;&#x2F;第二次tempLeft&#x3D;2,right&#x3D;3 &#x2F;&#x2F;第三次tempLeft&#x3D;0,right&#x3D;3</span><br><span class="line">            &#x2F;&#x2F;最后一次tempLeft&#x3D;0,right&#x3D;7</span><br><span class="line">            &#x2F;&#x2F;依次拷贝</span><br><span class="line">            arr[tempLeft]&#x3D;temp[t];</span><br><span class="line">            t+&#x3D;1;</span><br><span class="line">            tempLeft+&#x3D;1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 测试时间</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public static void testTime() &#123;</span><br><span class="line">        int[] arr &#x3D; new int[80000];</span><br><span class="line">        for (int i &#x3D; 0; i &lt; 80000; i++) &#123;</span><br><span class="line">            arr[i] &#x3D; (int) (Math.random() * 80000);</span><br><span class="line">        &#125;</span><br><span class="line">        int[] temp&#x3D;new int[arr.length];</span><br><span class="line">        Date date1 &#x3D; new Date();</span><br><span class="line">        SimpleDateFormat simpleDateFormatter &#x3D; new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);</span><br><span class="line">        String date1Str &#x3D; simpleDateFormatter.format(date1);</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;排序前的时间是&#x3D;&quot; + date1Str);</span><br><span class="line">        long l1 &#x3D; System.currentTimeMillis();</span><br><span class="line">        mergeSort(arr, 0, arr.length - 1,temp);</span><br><span class="line"></span><br><span class="line">        Date date2 &#x3D; new Date();</span><br><span class="line">        &#x2F;&#x2F;   SimpleDateFormat simpleDateFormatter &#x3D; new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);</span><br><span class="line">        String date2Str &#x3D; simpleDateFormatter.format(date2);</span><br><span class="line">        System.out.println(&quot;排序后的时间是&#x3D;&quot; + date2Str);</span><br><span class="line">        long l2 &#x3D; System.currentTimeMillis();</span><br><span class="line">        System.out.println(&quot;耗时毫秒数为:&quot; + (l2 - l1));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;java实现快速排序和归并排序&quot;&gt;&lt;a href=&quot;#java实现快速排序和归并排序&quot; class=&quot;headerlink&quot; title=&quot;java实现快速排序和归并排序&quot;&gt;&lt;/a&gt;java实现快速排序和归并排序&lt;/h1&gt;&lt;h2 id=&quot;快速排序&quot;&gt;&lt;a href
      
    
    </summary>
    
    
      <category term="数据结构" scheme="https://todcsw.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="学习" scheme="https://todcsw.github.io/tags/%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="java" scheme="https://todcsw.github.io/tags/java/"/>
    
      <category term="数据结构" scheme="https://todcsw.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>java实现插入排序和希尔排序</title>
    <link href="https://todcsw.github.io/2020/04/20/java%E5%AE%9E%E7%8E%B0%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F%E5%92%8C%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F/"/>
    <id>https://todcsw.github.io/2020/04/20/java%E5%AE%9E%E7%8E%B0%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F%E5%92%8C%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F/</id>
    <published>2020-04-20T05:45:04.000Z</published>
    <updated>2020-04-20T05:47:29.412Z</updated>
    
    <content type="html"><![CDATA[<h1 id="java实现插入排序和希尔排序"><a href="#java实现插入排序和希尔排序" class="headerlink" title="java实现插入排序和希尔排序"></a>java实现插入排序和希尔排序</h1><h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package com.csw.sort;</span><br><span class="line"></span><br><span class="line">import java.text.SimpleDateFormat;</span><br><span class="line">import java.util.Arrays;</span><br><span class="line">import java.util.Date;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * @Auther: 行路</span><br><span class="line"> * @Date: Created on 2020&#x2F;4&#x2F;19 15:16 星期日</span><br><span class="line"> * @Description: com.csw.sort 插入排序</span><br><span class="line"> * @version: 1.0</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class InsertSort &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int[] arr &#x3D; &#123;101, 34, 119, 1, -1, 89&#125;;</span><br><span class="line">        System.out.println(&quot;老师的方法&quot;);</span><br><span class="line">        insertSort(arr);</span><br><span class="line">        System.out.println(&quot;我的方法&quot;);</span><br><span class="line">        int[] arr1 &#x3D; &#123;101, 34, 119, 1, -1, 89&#125;;</span><br><span class="line">        insertSort1(arr1);</span><br><span class="line"></span><br><span class="line">        testTime();&#x2F;&#x2F;80000个数据排序测试时间</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;插入排序</span><br><span class="line">    public static void insertSort(int[] arr) &#123;</span><br><span class="line">        System.out.println(&quot;插入排序~~~~&quot;);</span><br><span class="line">        for (int i &#x3D; 1; i &lt; arr.length; i++) &#123;</span><br><span class="line">            int insertVal &#x3D; arr[i];</span><br><span class="line">            int insertIndex &#x3D; i - 1;</span><br><span class="line">            while (insertIndex &gt;&#x3D; 0 &amp;&amp; insertVal &lt; arr[insertIndex]) &#123;</span><br><span class="line">                arr[insertIndex + 1] &#x3D; arr[insertIndex];</span><br><span class="line">                insertIndex--;</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F;当退出while循环时,说明插入的位置找到,insertIndex-1</span><br><span class="line">            arr[insertIndex + 1] &#x3D; insertVal;</span><br><span class="line">            &#x2F;&#x2F; System.out.println(&quot;第&quot;+i+&quot;轮&quot;);</span><br><span class="line">            &#x2F;&#x2F; System.out.println(Arrays.toString(arr));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 自己写的双重循环</span><br><span class="line">     *</span><br><span class="line">     * @param arr</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public static void insertSort1(int[] arr) &#123;</span><br><span class="line">        for (int i &#x3D; 1; i &lt; arr.length; i++) &#123;</span><br><span class="line">            int insertValue &#x3D; arr[i];</span><br><span class="line">            int k &#x3D; i - 1;</span><br><span class="line">            int j &#x3D; 0;</span><br><span class="line">            for (j &#x3D; k; j &gt;&#x3D; 0 &amp;&amp; insertValue &lt; arr[j]; j--) &#123;</span><br><span class="line">                arr[j + 1] &#x3D; arr[j];</span><br><span class="line">            &#125;</span><br><span class="line">            arr[j + 1] &#x3D; insertValue;</span><br><span class="line">           &#x2F;&#x2F; System.out.println(&quot;第&quot; + i + &quot;轮&quot;);</span><br><span class="line">           &#x2F;&#x2F; System.out.println(Arrays.toString(arr));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 测试时间</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public static void testTime() &#123;</span><br><span class="line">        int[] arr &#x3D; new int[80000];</span><br><span class="line">        for (int i &#x3D; 0; i &lt; 80000; i++) &#123;</span><br><span class="line">            arr[i] &#x3D; (int) (Math.random() * 80000);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Date date1 &#x3D; new Date();</span><br><span class="line">        SimpleDateFormat simpleDateFormatter &#x3D; new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);</span><br><span class="line">        String date1Str &#x3D; simpleDateFormatter.format(date1);</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;排序前的时间是&#x3D;&quot; + date1Str);</span><br><span class="line">        long l &#x3D; System.currentTimeMillis();</span><br><span class="line">        insertSort(arr);</span><br><span class="line"></span><br><span class="line">        Date date2 &#x3D; new Date();</span><br><span class="line">        &#x2F;&#x2F;   SimpleDateFormat simpleDateFormatter &#x3D; new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);</span><br><span class="line">        String date2Str &#x3D; simpleDateFormatter.format(date2);</span><br><span class="line">        System.out.println(&quot;排序后的时间是&#x3D;&quot; + date2Str);</span><br><span class="line">        long l1 &#x3D; System.currentTimeMillis();</span><br><span class="line">        System.out.println(&quot;耗时毫秒数为:&quot;+(l1-l));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 以下时分析的思路</span><br><span class="line">     * 使用逐步推导的方式来讲解,边离理解</span><br><span class="line">     *     第一轮int[] arr&#x3D;&#123;101,34,119,1&#125;;</span><br><span class="line">     *</span><br><span class="line">     *     定义待插入的差个数</span><br><span class="line">     *         int insertVal&#x3D;arr[1];</span><br><span class="line">     *         int insertIndex&#x3D;1-1; &#x2F;&#x2F;arr[1]前面的下标</span><br><span class="line">     *</span><br><span class="line">     *     给InsertVal,找到插入的位置</span><br><span class="line">     *     insertIndex&gt;&#x3D;0这保证插入位置时,不越界</span><br><span class="line">     *     insertVal&lt;arr[insertIndex]待插入数没有找到插入位置</span><br><span class="line">     *     需要将arr[insertIndex] 后移</span><br><span class="line">     *         while (insertIndex&gt;&#x3D;0&amp;&amp;insertVal&lt;arr[insertIndex])&#123;</span><br><span class="line">     *             arr[insertIndex+1]&#x3D;arr[insertIndex];</span><br><span class="line">     *             insertIndex--;</span><br><span class="line">     *         &#125;</span><br><span class="line">     *     当退出while循环时,说明插入的位置找到,insertIndex+1</span><br><span class="line">     *         arr[insertIndex+1]&#x3D;insertVal;</span><br><span class="line">     *         System.out.println(&quot;第一轮插入后&quot;);</span><br><span class="line">     *         System.out.println(Arrays.toString(arr));</span><br><span class="line">     *&#x2F;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package com.csw.sort;</span><br><span class="line"></span><br><span class="line">import java.text.SimpleDateFormat;</span><br><span class="line">import java.util.Arrays;</span><br><span class="line">import java.util.Date;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * @Auther: 行路</span><br><span class="line"> * @Date: Created on 2020&#x2F;4&#x2F;19 22:22 星期日</span><br><span class="line"> * @Description: com.csw.sort 希尔排序</span><br><span class="line"> * @version: 1.0</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class ShellSort &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int[] arr &#x3D; &#123;8, 9, 1, 7, 2, 3, 5, 4, 6, 0&#125;;</span><br><span class="line">        shellSort(arr);</span><br><span class="line">        testTime(); &#x2F;&#x2F;测试交换法的时间</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 交换式的希尔排序(交换的时候有点冒泡的意思)</span><br><span class="line">     * @param arr</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public static void shellSort(int[] arr) &#123;</span><br><span class="line">        System.out.println(&quot;希尔排序插入采用交换法&quot;);</span><br><span class="line">        int temp &#x3D; 0;</span><br><span class="line">        int count &#x3D; 0;</span><br><span class="line">        for (int gap &#x3D; arr.length &#x2F; 2; gap &gt; 0; gap &#x2F;&#x3D; 2) &#123;</span><br><span class="line">            for (int i &#x3D; gap; i &lt; arr.length; i++) &#123;</span><br><span class="line">                &#x2F;&#x2F;遍历个组中所有的元素(共gap组,每一组个元素),步长为gap</span><br><span class="line">                for (int j &#x3D; i - gap; j &gt;&#x3D; 0; j -&#x3D; gap) &#123;</span><br><span class="line">                    &#x2F;&#x2F;如果当前元素大于加上步长后的那个元素,说明交换</span><br><span class="line">                    if (arr[j] &gt; arr[j + gap]) &#123;</span><br><span class="line">                        temp &#x3D; arr[j];</span><br><span class="line">                        arr[j] &#x3D; arr[j + gap];</span><br><span class="line">                        arr[j + gap] &#x3D; temp;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">           &#x2F;&#x2F; System.out.println(&quot;希尔排序第&quot; + (++count) + &quot;轮:&quot; + Arrays.toString(arr));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 移位式的希尔排序(交换的时候采用的是插入)</span><br><span class="line">     * @param arr</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public static void shellSort2(int[] arr) &#123;</span><br><span class="line">        System.out.println(&quot;希尔排序插入采用移位&quot;);</span><br><span class="line"></span><br><span class="line">        int count &#x3D; 0;</span><br><span class="line">        for (int gap &#x3D; arr.length &#x2F; 2; gap &gt; 0; gap &#x2F;&#x3D; 2) &#123;</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F;增量gap,并逐步缩小增量</span><br><span class="line">            for (int i &#x3D; gap; i &lt; arr.length; i++) &#123;</span><br><span class="line">                &#x2F;&#x2F;遍历个组中所有的元素(共gap组,每一组个元素),步长为gap</span><br><span class="line">                   int j&#x3D;i;</span><br><span class="line">                   int temp&#x3D;arr[j];</span><br><span class="line">                   if (arr[j]&lt;arr[j-gap])&#123;</span><br><span class="line">                       while (j-gap&gt;&#x3D;0&amp;&amp;temp&lt;arr[j-gap])&#123;</span><br><span class="line">                           &#x2F;&#x2F;移动</span><br><span class="line">                           arr[j]&#x3D;arr[j-gap];</span><br><span class="line">                           j-&#x3D;gap;</span><br><span class="line">                       &#125;</span><br><span class="line">                       &#x2F;&#x2F;当退出while后,就给temp找到插入位置</span><br><span class="line">                       arr[j]&#x3D;temp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; System.out.println(&quot;希尔排序第&quot; + (++count) + &quot;轮:&quot; + Arrays.toString(arr));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 测试时间</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public static void testTime() &#123;</span><br><span class="line">        int[] arr &#x3D; new int[80000];</span><br><span class="line">        for (int i &#x3D; 0; i &lt; 80000; i++) &#123;</span><br><span class="line">            arr[i] &#x3D; (int) (Math.random() * 80000);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Date date1 &#x3D; new Date();</span><br><span class="line">        SimpleDateFormat simpleDateFormatter &#x3D; new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);</span><br><span class="line">        String date1Str &#x3D; simpleDateFormatter.format(date1);</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;排序前的时间是&#x3D;&quot; + date1Str);</span><br><span class="line">        long l &#x3D; System.currentTimeMillis();</span><br><span class="line">        shellSort2(arr);</span><br><span class="line"></span><br><span class="line">        Date date2 &#x3D; new Date();</span><br><span class="line">        &#x2F;&#x2F;   SimpleDateFormat simpleDateFormatter &#x3D; new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);</span><br><span class="line">        String date2Str &#x3D; simpleDateFormatter.format(date2);</span><br><span class="line">        System.out.println(&quot;排序后的时间是&#x3D;&quot; + date2Str);</span><br><span class="line">        long l1 &#x3D; System.currentTimeMillis();</span><br><span class="line">        System.out.println(&quot;耗时毫秒数为:&quot;+(l1-l));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 使用逐步推导得到方式</span><br><span class="line">     *</span><br><span class="line">     * @param arr</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public static void shellSortTest(int[] arr) &#123;</span><br><span class="line">        int temp &#x3D; 0;</span><br><span class="line">        &#x2F;&#x2F;希尔排序的第一轮排序</span><br><span class="line">        &#x2F;&#x2F;因为第一轮是将10个数据分成了5组</span><br><span class="line">        for (int i &#x3D; 5; i &lt; arr.length; i++) &#123;</span><br><span class="line">            &#x2F;&#x2F;遍历个组中所有的元素(共5组,每一组两个元素),步长为5</span><br><span class="line">            for (int j &#x3D; i - 5; j &gt;&#x3D; 0; j -&#x3D; 5) &#123;</span><br><span class="line">                &#x2F;&#x2F;如果当前元素大于加上步长后的那个元素,说明交换</span><br><span class="line">                if (arr[j] &gt; arr[j + 5]) &#123;</span><br><span class="line">                    temp &#x3D; arr[j];</span><br><span class="line">                    arr[j] &#x3D; arr[j + 5];</span><br><span class="line">                    arr[j + 5] &#x3D; temp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Arrays.toString(arr));</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;希尔排序的第一轮排序</span><br><span class="line">        &#x2F;&#x2F;因为第一轮是将10个数据分成了5组</span><br><span class="line">        for (int i &#x3D; 2; i &lt; arr.length; i++) &#123;</span><br><span class="line">            &#x2F;&#x2F;遍历个组中所有的元素(共5组,每一组两个元素),步长为5</span><br><span class="line">            for (int j &#x3D; i - 2; j &gt;&#x3D; 0; j -&#x3D; 2) &#123;</span><br><span class="line">                &#x2F;&#x2F;如果当前元素大于加上步长后的那个元素,说明交换</span><br><span class="line">                if (arr[j] &gt; arr[j + 2]) &#123;</span><br><span class="line">                    temp &#x3D; arr[j];</span><br><span class="line">                    arr[j] &#x3D; arr[j + 2];</span><br><span class="line">                    arr[j + 2] &#x3D; temp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Arrays.toString(arr));</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;希尔排序的第三轮排序</span><br><span class="line">        &#x2F;&#x2F;因为第一轮是将10个数据分成了5组</span><br><span class="line">        for (int i &#x3D; 1; i &lt; arr.length; i++) &#123;</span><br><span class="line">            &#x2F;&#x2F;遍历个组中所有的元素(共5组,每一组两个元素),步长为5</span><br><span class="line">            for (int j &#x3D; i - 1; j &gt;&#x3D; 0; j -&#x3D; 1) &#123;</span><br><span class="line">                &#x2F;&#x2F;如果当前元素大于加上步长后的那个元素,说明交换</span><br><span class="line">                if (arr[j] &gt; arr[j + 1]) &#123;</span><br><span class="line">                    temp &#x3D; arr[j];</span><br><span class="line">                    arr[j] &#x3D; arr[j + 1];</span><br><span class="line">                    arr[j + 1] &#x3D; temp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Arrays.toString(arr));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;java实现插入排序和希尔排序&quot;&gt;&lt;a href=&quot;#java实现插入排序和希尔排序&quot; class=&quot;headerlink&quot; title=&quot;java实现插入排序和希尔排序&quot;&gt;&lt;/a&gt;java实现插入排序和希尔排序&lt;/h1&gt;&lt;h2 id=&quot;插入排序&quot;&gt;&lt;a href
      
    
    </summary>
    
    
      <category term="数据结构" scheme="https://todcsw.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="学习" scheme="https://todcsw.github.io/tags/%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="java" scheme="https://todcsw.github.io/tags/java/"/>
    
      <category term="数据结构" scheme="https://todcsw.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>java实现冒泡排序和选择排序</title>
    <link href="https://todcsw.github.io/2020/04/19/java%E5%AE%9E%E7%8E%B0%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%E5%92%8C%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F/"/>
    <id>https://todcsw.github.io/2020/04/19/java%E5%AE%9E%E7%8E%B0%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%E5%92%8C%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F/</id>
    <published>2020-04-19T14:01:55.000Z</published>
    <updated>2020-04-19T14:08:08.531Z</updated>
    
    <content type="html"><![CDATA[<h1 id="java实现冒泡排序和选择排序"><a href="#java实现冒泡排序和选择排序" class="headerlink" title="java实现冒泡排序和选择排序"></a>java实现冒泡排序和选择排序</h1><h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package com.csw.sort;</span><br><span class="line"></span><br><span class="line">import java.text.SimpleDateFormat;</span><br><span class="line">import java.util.Arrays;</span><br><span class="line">import java.util.Date;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * @Auther: 行路</span><br><span class="line"> * @Date: Created on 2020&#x2F;4&#x2F;19 13:55 星期日</span><br><span class="line"> * @Description: com.csw.sort 冒泡排序 时间复杂度(n^2)</span><br><span class="line"> * @version: 1.0</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class BubbleSort &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int[] arr &#x3D; &#123;3, 9, -1, 10, 20&#125;;</span><br><span class="line">        sort1(arr);</span><br><span class="line">        sort2(arr);</span><br><span class="line">        testTime();&#x2F;&#x2F;80000个数据排序测试时间</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 冒泡排序</span><br><span class="line">     *</span><br><span class="line">     * @param arr</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public static void sort1(int arr[]) &#123;</span><br><span class="line">        System.out.println(&quot;初代冒泡排序--------&quot;);</span><br><span class="line">        int temp &#x3D; 0; &#x2F;&#x2F;临时变量</span><br><span class="line">        &#x2F;&#x2F;将最大的数排到最后</span><br><span class="line">        for (int i &#x3D; 0; i &lt; arr.length - 1; i++) &#123;</span><br><span class="line">            for (int j &#x3D; 0; j &lt; arr.length - i - 1; j++) &#123;</span><br><span class="line">                if (arr[j] &gt; arr[j + 1]) &#123;</span><br><span class="line">                    temp &#x3D; arr[j + 1];</span><br><span class="line">                    arr[j + 1] &#x3D; arr[j];</span><br><span class="line">                    arr[j] &#x3D; temp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F; System.out.println(&quot;第&quot;+(i+1)+&quot;趟排序&quot;);</span><br><span class="line">            &#x2F;&#x2F; System.out.println(Arrays.toString(arr));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 优化冒泡排序</span><br><span class="line">     *</span><br><span class="line">     * @param arr</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public static void sort2(int arr[]) &#123;</span><br><span class="line">        System.out.println(&quot;优化冒泡排序--------&quot;);</span><br><span class="line">        int temp &#x3D; 0; &#x2F;&#x2F;临时变量</span><br><span class="line">        boolean flag &#x3D; false;  &#x2F;&#x2F;表示变量,表示是否进行交换</span><br><span class="line">        &#x2F;&#x2F;将最大的数排到最后</span><br><span class="line">        for (int i &#x3D; 0; i &lt; arr.length - 1; i++) &#123;</span><br><span class="line"></span><br><span class="line">            for (int j &#x3D; 0; j &lt; arr.length - i - 1; j++) &#123;</span><br><span class="line">                if (arr[j] &gt; arr[j + 1]) &#123;</span><br><span class="line">                    flag &#x3D; true;</span><br><span class="line">                    temp &#x3D; arr[j + 1];</span><br><span class="line">                    arr[j + 1] &#x3D; arr[j];</span><br><span class="line">                    arr[j] &#x3D; temp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F;   System.out.println(&quot;第&quot;+(i+1)+&quot;趟排序&quot;);</span><br><span class="line">            &#x2F;&#x2F;  System.out.println(Arrays.toString(arr));</span><br><span class="line">            if (!flag) &#123; &#x2F;&#x2F;在一趟排序中,一次交换也没有发生过</span><br><span class="line">                break;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                flag &#x3D; false; &#x2F;&#x2F;重置false ,进行下次判断</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 80000个数据排序测试时间</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public static void testTime() &#123;</span><br><span class="line"></span><br><span class="line">        int[] arr &#x3D; new int[80000];</span><br><span class="line">        for (int i &#x3D; 0; i &lt; 80000; i++) &#123;</span><br><span class="line">            arr[i] &#x3D; (int) (Math.random() * 80000);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Date date1 &#x3D; new Date();</span><br><span class="line">        SimpleDateFormat simpleDateFormatter &#x3D; new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);</span><br><span class="line">        String date1Str &#x3D; simpleDateFormatter.format(date1);</span><br><span class="line">        System.out.println(&quot;排序前的时间是&#x3D;&quot; + date1Str);</span><br><span class="line"></span><br><span class="line">        sort1(arr);</span><br><span class="line"></span><br><span class="line">        Date date2 &#x3D; new Date();</span><br><span class="line">        &#x2F;&#x2F;   SimpleDateFormat simpleDateFormatter &#x3D; new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);</span><br><span class="line">        String date2Str &#x3D; simpleDateFormatter.format(date2);</span><br><span class="line">        System.out.println(&quot;排序后的时间是&#x3D;&quot; + date2Str);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package com.csw.sort;</span><br><span class="line"></span><br><span class="line">import java.text.SimpleDateFormat;</span><br><span class="line">import java.util.Arrays;</span><br><span class="line">import java.util.Date;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * @Auther: 行路</span><br><span class="line"> * @Date: Created on 2020&#x2F;4&#x2F;19 14:46 星期日</span><br><span class="line"> * @Description: com.csw.sort 选择排序</span><br><span class="line"> * @version: 1.0</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class SelectSort &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int[] arr &#x3D; &#123;101, 34, 119, 1&#125;;</span><br><span class="line">        selectSort(arr);</span><br><span class="line">        testTime(); &#x2F;&#x2F;80000个数据排序测试时间</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 使用逐步指导的方式来,讲解选择排序</span><br><span class="line">     * 第一轮</span><br><span class="line">     * 原始初始值 101,34,119,1</span><br><span class="line">     * 第一轮排序 :1,34,119,101</span><br><span class="line">     * 算法,先简单后复杂,就是可以把一个复杂的算法，拆分成简单的问题,逐步解决</span><br><span class="line">     * &lt;p&gt;</span><br><span class="line">     * 自己的理解：将每一次排序的第一个元素假定为最小值,定义俩变量一个记录值,一个记录下标用于交换</span><br><span class="line">     *</span><br><span class="line">     * @param arr</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public static void selectSort(int[] arr) &#123;</span><br><span class="line">        System.out.println(&quot;选择排序~~~~~&quot;);</span><br><span class="line">        &#x2F;&#x2F;在推导过程中</span><br><span class="line">        for (int i &#x3D; 0; i &lt; arr.length - 1; i++) &#123;</span><br><span class="line">            int minIndex &#x3D; i;</span><br><span class="line">            int min &#x3D; arr[minIndex];</span><br><span class="line">            for (int j &#x3D; i + 1; j &lt; arr.length; j++) &#123;</span><br><span class="line">                if (min &gt; arr[j]) &#123;</span><br><span class="line">                    min &#x3D; arr[j];</span><br><span class="line">                    minIndex &#x3D; j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F;当for循环结束时,将最小值放在arr[0]，即交换</span><br><span class="line">            if (minIndex !&#x3D; i) &#123;</span><br><span class="line">                arr[minIndex] &#x3D; arr[i];</span><br><span class="line">                arr[i] &#x3D; min;</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F; System.out.println(&quot;第&quot;+(i+1)+&quot;轮后~~&quot;);</span><br><span class="line">            &#x2F;&#x2F; System.out.println(Arrays.toString(arr));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void testTime() &#123;</span><br><span class="line">        int[] arr &#x3D; new int[80000];</span><br><span class="line">        for (int i &#x3D; 0; i &lt; 80000; i++) &#123;</span><br><span class="line">            arr[i] &#x3D; (int) (Math.random() * 80000);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Date date1 &#x3D; new Date();</span><br><span class="line">        SimpleDateFormat simpleDateFormatter &#x3D; new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);</span><br><span class="line">        String date1Str &#x3D; simpleDateFormatter.format(date1);</span><br><span class="line">        System.out.println(&quot;排序前的时间是&#x3D;&quot; + date1Str);</span><br><span class="line"></span><br><span class="line">        selectSort(arr);</span><br><span class="line"></span><br><span class="line">        Date date2 &#x3D; new Date();</span><br><span class="line">        &#x2F;&#x2F;   SimpleDateFormat simpleDateFormatter &#x3D; new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);</span><br><span class="line">        String date2Str &#x3D; simpleDateFormatter.format(date2);</span><br><span class="line">        System.out.println(&quot;排序后的时间是&#x3D;&quot; + date2Str);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;java实现冒泡排序和选择排序&quot;&gt;&lt;a href=&quot;#java实现冒泡排序和选择排序&quot; class=&quot;headerlink&quot; title=&quot;java实现冒泡排序和选择排序&quot;&gt;&lt;/a&gt;java实现冒泡排序和选择排序&lt;/h1&gt;&lt;h2 id=&quot;冒泡排序&quot;&gt;&lt;a href
      
    
    </summary>
    
    
      <category term="数据结构" scheme="https://todcsw.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="学习" scheme="https://todcsw.github.io/tags/%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="java" scheme="https://todcsw.github.io/tags/java/"/>
    
      <category term="数据结构" scheme="https://todcsw.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>java使用递归实现走出迷宫和八皇后问题</title>
    <link href="https://todcsw.github.io/2020/04/18/java%E4%BD%BF%E7%94%A8%E9%80%92%E5%BD%92%E5%AE%9E%E7%8E%B0%E8%B5%B0%E5%87%BA%E8%BF%B7%E5%AE%AB%E5%92%8C%E5%85%AB%E7%9A%87%E5%90%8E%E9%97%AE%E9%A2%98/"/>
    <id>https://todcsw.github.io/2020/04/18/java%E4%BD%BF%E7%94%A8%E9%80%92%E5%BD%92%E5%AE%9E%E7%8E%B0%E8%B5%B0%E5%87%BA%E8%BF%B7%E5%AE%AB%E5%92%8C%E5%85%AB%E7%9A%87%E5%90%8E%E9%97%AE%E9%A2%98/</id>
    <published>2020-04-18T04:51:05.000Z</published>
    <updated>2020-04-18T07:17:07.102Z</updated>
    
    <content type="html"><![CDATA[<h1 id="java使用递归实现走出迷宫"><a href="#java使用递归实现走出迷宫" class="headerlink" title="java使用递归实现走出迷宫"></a>java使用递归实现走出迷宫</h1><h2 id="废话不多说-直接上代码和运行结果"><a href="#废话不多说-直接上代码和运行结果" class="headerlink" title="废话不多说,直接上代码和运行结果"></a>废话不多说,直接上代码和运行结果</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package com.csw.recursion;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * @Auther: 行路</span><br><span class="line"> * @Date: Created on 2020&#x2F;4&#x2F;17 23:11 星期五</span><br><span class="line"> * @Description: com.csw.recursion 迷宫回溯问题</span><br><span class="line"> * @version: 1.0</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class MiGong &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        &#x2F;&#x2F;先创建一个二维数组,模拟迷宫</span><br><span class="line">        &#x2F;&#x2F;地图</span><br><span class="line">        int[][] map&#x3D;new int[8][7];</span><br><span class="line">        &#x2F;&#x2F;使用1表示强</span><br><span class="line">        &#x2F;&#x2F;上下全部置为1</span><br><span class="line">        for(int i&#x3D;0;i&lt;7;i++)&#123;</span><br><span class="line">            map[0][i]&#x3D;1;</span><br><span class="line">            map[7][i]&#x3D;1;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;左右全部置为1</span><br><span class="line">        for(int i&#x3D;0;i&lt;8;i++)&#123;</span><br><span class="line">            map[i][0]&#x3D;1;</span><br><span class="line">            map[i][6]&#x3D;1;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;设置挡板</span><br><span class="line">        map[3][1]&#x3D;1;</span><br><span class="line">        map[3][2]&#x3D;1;</span><br><span class="line">        &#x2F;&#x2F;map[1][2]&#x3D;1;</span><br><span class="line">        map[2][2]&#x3D;1;</span><br><span class="line">        &#x2F;&#x2F;输出地图</span><br><span class="line">        System.out.println(&quot;地图&quot;);</span><br><span class="line">        for(int i&#x3D;0;i&lt;8;i++)&#123;</span><br><span class="line">            for(int j&#x3D;0;j&lt;7;j++)&#123;</span><br><span class="line">                System.out.print(map[i][j]+&quot; &quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(&quot;&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;使用递归回溯来给小球找路</span><br><span class="line">        &#x2F;&#x2F;使用递归回溯</span><br><span class="line">        setWay(map,1,1);</span><br><span class="line">        &#x2F;&#x2F;输出新的地图</span><br><span class="line">        System.out.println(&quot;新的地图&quot;);</span><br><span class="line">        for(int i&#x3D;0;i&lt;8;i++)&#123;</span><br><span class="line">            for(int j&#x3D;0;j&lt;7;j++)&#123;</span><br><span class="line">                System.out.print(map[i][j]+&quot; &quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(&quot;&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 说明 map表示地图,i,j白澳式地图从那个位置开始触发(1,1)</span><br><span class="line">     * 如果小球能到map[6][5] 位置,则说明通路找到</span><br><span class="line">     * 约定:当map[i][j]&#x3D;0 表示没走过,当为1表示强 2为通路可以走,3表示已经走过</span><br><span class="line">     * 在走迷宫需要确定一个策略(方法)先走下-&gt;右-&gt;上-&gt;左,如果走不通就回溯</span><br><span class="line">     * @param map 表示地图</span><br><span class="line">     * @param i 从按个位置开始找</span><br><span class="line">     * @param j</span><br><span class="line">     * @return  如果找到通路,就返回true 否则返回false</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public static boolean setWay(int[][] map,int i,int j)&#123;</span><br><span class="line">        if(map[6][5]&#x3D;&#x3D;2)&#123;</span><br><span class="line">            &#x2F;&#x2F;通路已经找到</span><br><span class="line">            return true;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            if(map[i][j]&#x3D;&#x3D;0)&#123; &#x2F;&#x2F;如果当前这个点还没有走过</span><br><span class="line">                &#x2F;&#x2F;下-&gt;右-&gt;上-&gt;左 按照策略走</span><br><span class="line">                map[i][j]&#x3D;2; &#x2F;&#x2F;假定该点是可以走通的.</span><br><span class="line">                if(setWay(map,i+1,j))&#123;</span><br><span class="line">                    &#x2F;&#x2F;向下走,</span><br><span class="line">                    return true;</span><br><span class="line">                &#125;else if(setWay(map,i,j+1))&#123;</span><br><span class="line">                    &#x2F;&#x2F;向右走</span><br><span class="line">                    return true;</span><br><span class="line">                &#125;else if(setWay(map,i-1,j))&#123;</span><br><span class="line">                    &#x2F;&#x2F;向上走</span><br><span class="line">                    return true;</span><br><span class="line">                &#125;else if(setWay(map,i,j-1)) &#123;</span><br><span class="line">                    &#x2F;&#x2F;向左走</span><br><span class="line">                    return true;</span><br><span class="line">                &#125;else&#123;</span><br><span class="line">                    &#x2F;&#x2F;说明该点是走不通的</span><br><span class="line">                    map[i][j]&#x3D;3;</span><br><span class="line">                    return false;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                &#x2F;&#x2F;如果map[i][j]!&#x3D;0 可能是1，2，3</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h2><p><img src="/" class="lazyload" data-src="/images/%E8%BF%B7%E5%AE%AB.jpg"  alt=""></p><ul><li>0代表未走过的点</li><li>1代表迷宫的围墙</li><li>2代表走出迷宫的路线</li><li>3代表尝试走过,但走不通的点,进行回溯</li></ul><h1 id="java使用递归解决八皇后问题"><a href="#java使用递归解决八皇后问题" class="headerlink" title="java使用递归解决八皇后问题"></a>java使用递归解决八皇后问题</h1><h2 id="废话不多说-直接上代码"><a href="#废话不多说-直接上代码" class="headerlink" title="废话不多说,直接上代码"></a>废话不多说,直接上代码</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package com.csw.recursion;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * @Auther: 行路</span><br><span class="line"> * @Date: Created on 2020&#x2F;4&#x2F;18 13:31 星期六</span><br><span class="line"> * @Description: com.csw.recursion 八皇后问题</span><br><span class="line"> * @version: 1.0</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class Queen8 &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;定义一个max表示有多少皇后</span><br><span class="line">    int max&#x3D;8;</span><br><span class="line">    &#x2F;&#x2F;定义数组array 保存皇后放置的位置的结果</span><br><span class="line">    &#x2F;&#x2F;比如arr&#x3D;&#123;0,4,7,5,2,6,1,3&#125;</span><br><span class="line">    int[] array&#x3D;new int[max];</span><br><span class="line">    static int count&#x3D;0;</span><br><span class="line">    static int judgeCount&#x3D;0;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        &#x2F;&#x2F;测试8皇后是否正确</span><br><span class="line">        Queen8 queen8&#x3D;new Queen8();</span><br><span class="line">        queen8.check(0);</span><br><span class="line">        System.out.println(&quot;一共有&quot;+count+&quot;种解法&quot;);</span><br><span class="line">        System.out.println(&quot;共判断了多少次&quot;+judgeCount);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;编写一个方法,放置第n个皇后</span><br><span class="line">    &#x2F;&#x2F;特别注意：check是每一次递归,进入到check中都有for(int i&#x3D;0;i&lt;max;i++)因此会有回溯</span><br><span class="line">    private void check(int n)&#123;</span><br><span class="line">        if(n&#x3D;&#x3D;max)&#123; &#x2F;&#x2F;n&#x3D;8 ,其实8个皇后已然放好了</span><br><span class="line">            print();</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;依次放入皇后,并判断是否冲突</span><br><span class="line">        for (int i&#x3D;0;i&lt;max;i++)&#123;</span><br><span class="line">            &#x2F;&#x2F;先把当前这个皇后n,放到该行的1列</span><br><span class="line">            array[n]&#x3D;i;</span><br><span class="line">            &#x2F;&#x2F;判断当放置第n个皇后到i列时,是否冲突</span><br><span class="line">            if(judge(n))&#123;</span><br><span class="line">                &#x2F;&#x2F;不冲突</span><br><span class="line">                &#x2F;&#x2F;接着放n+1个皇后,即开始递归</span><br><span class="line">                check(n+1); &#x2F;&#x2F;</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F;如果冲突,就继续执行array[n]&#x3D;i;即将第n个皇后放置在本行的后移一个位置</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 查看当我们放置第n个皇后,就去检测该皇后是否和前面已经摆放的皇后冲突</span><br><span class="line">     * @param n 表示第n个皇后</span><br><span class="line">     * @return</span><br><span class="line">     *&#x2F;</span><br><span class="line">    private boolean judge(int n)&#123;</span><br><span class="line">        judgeCount++;</span><br><span class="line">        for(int i&#x3D;0;i&lt;n;i++)&#123;</span><br><span class="line">            &#x2F;&#x2F;1.array[i]&#x3D;&#x3D;array[n]表示判断第n个皇后是否和前面n-1个皇后在同一列</span><br><span class="line">            &#x2F;&#x2F;2.表示判断Math.abs(n-i)&#x3D;&#x3D;Math.abs(array[n]-array[i])第n个皇后和第i个皇后是否在同一斜线</span><br><span class="line">            &#x2F;&#x2F;n&#x3D;1 放在第二列 n&#x3D;1 array[1]&#x3D;1</span><br><span class="line">            &#x2F;&#x2F;Math.abs(1-0)&#x3D;&#x3D;1 Math.abs(1)</span><br><span class="line">            &#x2F;&#x2F;判断是否在同一行,没有必要,n每次都在递增</span><br><span class="line">            if(array[i]&#x3D;&#x3D;array[n]|| Math.abs(n-i)&#x3D;&#x3D;Math.abs(array[n]-array[i]))&#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     *写一个方法,可以将皇后摆放的位置打印出来</span><br><span class="line">     *&#x2F;</span><br><span class="line">    private void print()&#123;</span><br><span class="line">        count++;</span><br><span class="line">        for(int i&#x3D;0;i&lt;array.length;i++)&#123;</span><br><span class="line">            System.out.print(array[i]+&quot; &quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot;&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;java使用递归实现走出迷宫&quot;&gt;&lt;a href=&quot;#java使用递归实现走出迷宫&quot; class=&quot;headerlink&quot; title=&quot;java使用递归实现走出迷宫&quot;&gt;&lt;/a&gt;java使用递归实现走出迷宫&lt;/h1&gt;&lt;h2 id=&quot;废话不多说-直接上代码和运行结果&quot;
      
    
    </summary>
    
    
      <category term="数据结构" scheme="https://todcsw.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="学习" scheme="https://todcsw.github.io/tags/%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="java" scheme="https://todcsw.github.io/tags/java/"/>
    
      <category term="数据结构" scheme="https://todcsw.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>java实现中缀表达式转后缀表达式并使用栈计算逆波兰表达式</title>
    <link href="https://todcsw.github.io/2020/04/17/java%E5%AE%9E%E7%8E%B0%E4%B8%AD%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%BD%AC%E5%90%8E%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%B9%B6%E4%BD%BF%E7%94%A8%E6%A0%88%E8%AE%A1%E7%AE%97%E9%80%86%E6%B3%A2%E5%85%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    <id>https://todcsw.github.io/2020/04/17/java%E5%AE%9E%E7%8E%B0%E4%B8%AD%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%BD%AC%E5%90%8E%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%B9%B6%E4%BD%BF%E7%94%A8%E6%A0%88%E8%AE%A1%E7%AE%97%E9%80%86%E6%B3%A2%E5%85%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F/</id>
    <published>2020-04-17T14:10:01.000Z</published>
    <updated>2020-04-17T14:11:30.783Z</updated>
    
    <content type="html"><![CDATA[<h1 id="java实现中缀表达式转后缀表达式并使用栈计算逆波兰表达式"><a href="#java实现中缀表达式转后缀表达式并使用栈计算逆波兰表达式" class="headerlink" title="java实现中缀表达式转后缀表达式并使用栈计算逆波兰表达式"></a>java实现中缀表达式转后缀表达式并使用栈计算逆波兰表达式</h1><h2 id="废话不多说-直接上代码"><a href="#废话不多说-直接上代码" class="headerlink" title="废话不多说,直接上代码"></a>废话不多说,直接上代码</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package com.csw.stack;</span><br><span class="line"></span><br><span class="line">import javax.security.auth.Subject;</span><br><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.List;</span><br><span class="line">import java.util.Stack;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * @Auther: 行路</span><br><span class="line"> * @Date: Created on 2020&#x2F;4&#x2F;17 13:58 星期五</span><br><span class="line"> * @Description: com.csw.stack 中缀表达式转后缀表达式  再使用栈计算逆波兰表达式(后缀表达式)</span><br><span class="line"> * @version: 1.0</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class PolandNotation &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        &#x2F;&#x2F;完成将一个中缀表达式转成后缀表达式的功能</span><br><span class="line">        &#x2F;&#x2F;说明</span><br><span class="line">        &#x2F;&#x2F;1. 1+((2+3)*4)-5 &#x3D;&gt; 转成1 2 3 + 4 * + 5 -</span><br><span class="line">        &#x2F;&#x2F;2. 因为直接对str进行操作不方便,先将字符串装成对应的List;</span><br><span class="line">        &#x2F;&#x2F;即 ArrayList[1,+,(,]</span><br><span class="line">        &#x2F;&#x2F;3.得到的中缀表达式对应的List-&gt;后缀表达式对应的List</span><br><span class="line">        &#x2F;&#x2F;即ArrayList[12, +, (, (, 20, +, 3, ), *, 4, ), -, 5] &#x3D;&gt; ArrayList[1 ,2, 3, +, 4, *, +, 5 ,-]</span><br><span class="line">        String expression &#x3D; &quot;1+((2+3)*4)-5&quot;;</span><br><span class="line">        List&lt;String&gt; list &#x3D; toInfixExpressionList(expression);</span><br><span class="line">        System.out.println(&quot;中缀表达式:&quot;+list);</span><br><span class="line">        &#x2F;&#x2F;后缀表达式</span><br><span class="line">        List&lt;String&gt; list1 &#x3D; parseSuffixExpressionList(list);</span><br><span class="line">        System.out.println(&quot;后缀表达式:&quot;+list1);</span><br><span class="line">        System.out.printf(&quot;expressioon&#x3D;%d&quot;,calculate(list1));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;先定义一个逆波兰表达式</span><br><span class="line">        &#x2F;&#x2F;(3+4)*5-6 -&gt; 3 4 + 5 * 6 -</span><br><span class="line">        &#x2F;&#x2F;为了方便,数字和符号用空格隔开</span><br><span class="line">&#x2F;&#x2F;        String suffixExpression &#x3D; &quot;30 4 + 5 * 6 -&quot;;</span><br><span class="line">        &#x2F;&#x2F;思路</span><br><span class="line">        &#x2F;&#x2F;1.先将3 4 + 5 * 6 - 放到ArrayList中</span><br><span class="line">        &#x2F;&#x2F;2. 将ArrayList传递给一个方法,遍历arrayList配合栈,完成计算</span><br><span class="line">&#x2F;&#x2F;        List&lt;String&gt; rpnList &#x3D; getListString(suffixExpression);</span><br><span class="line">&#x2F;&#x2F;        System.out.println(rpnList);</span><br><span class="line">&#x2F;&#x2F;        int res &#x3D; calculate(rpnList);</span><br><span class="line">&#x2F;&#x2F;        System.out.println(&quot;计算结果:&quot; + res);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 将第一个逆波兰表达式,依次将数据和运算符放入到arrayList中</span><br><span class="line">     *</span><br><span class="line">     * @param suffixExpression</span><br><span class="line">     * @return</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public static List&lt;String&gt; getListString(String suffixExpression) &#123;</span><br><span class="line">        &#x2F;&#x2F;将suffixExpression分割</span><br><span class="line">        String[] split &#x3D; suffixExpression.split(&quot; &quot;);</span><br><span class="line">        List&lt;String&gt; list &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">        for (String ele : split) &#123;</span><br><span class="line">            list.add(ele);</span><br><span class="line">        &#125;</span><br><span class="line">        return list;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 将中缀表达式转成对应的List</span><br><span class="line">     * s&#x3D;&quot;1+((2+3)*4)-5&quot;</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public static List&lt;String&gt; toInfixExpressionList(String s) &#123;</span><br><span class="line">        &#x2F;&#x2F;定义一个List,存放中缀表达式对应的内容</span><br><span class="line">        List&lt;String&gt; ls &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">        int i &#x3D; 0; &#x2F;&#x2F;这时一个指针,用于遍历中缀表达式字符串</span><br><span class="line">        String str; &#x2F;&#x2F;对多位数的拼接</span><br><span class="line">        char c; &#x2F;&#x2F;每遍历到一个字符,就放入到c</span><br><span class="line">        do &#123;</span><br><span class="line">            &#x2F;&#x2F;如果c是一个非数字,我们就需要加入到ls中</span><br><span class="line"></span><br><span class="line">            if ((c &#x3D; s.charAt(i)) &lt; 48 || (c &#x3D; s.charAt(i)) &gt; 57) &#123;</span><br><span class="line">                ls.add(&quot;&quot; + c);</span><br><span class="line">                i++; &#x2F;&#x2F;i需要后移</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                &#x2F;&#x2F;如果是一个数,需要考虑多为数</span><br><span class="line">                str &#x3D; &quot;&quot;;&#x2F;&#x2F;先将str置成&quot;&quot;</span><br><span class="line">                while (i &lt; s.length() &amp;&amp; (c &#x3D; s.charAt(i)) &gt;&#x3D; 48 &amp;&amp; (c &#x3D; s.charAt(i)) &lt;&#x3D; 57) &#123;</span><br><span class="line">                    str +&#x3D; c;&#x2F;&#x2F;拼接</span><br><span class="line">                    i++;</span><br><span class="line">                &#125;</span><br><span class="line">                ls.add(str);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; while (i &lt; s.length());</span><br><span class="line">        return ls;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * &#x2F;&#x2F;即ArrayList[12, +, (, (, 20, +, 3, ), *, 4, ), -, 5] &#x3D;&gt; ArrayList[1 ,2, 3, +, 4, *, +, 5 ,-]</span><br><span class="line">     *</span><br><span class="line">     * @param ls</span><br><span class="line">     * @return</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public static List&lt;String&gt; parseSuffixExpressionList(List&lt;String&gt; ls) &#123;</span><br><span class="line">        &#x2F;&#x2F;定义两个栈</span><br><span class="line">        Stack&lt;String&gt; s1 &#x3D; new Stack&lt;String&gt;(); &#x2F;&#x2F;符号栈</span><br><span class="line">        &#x2F;&#x2F;说明s2这个栈,在整个转换过程中，没有pop操作,而且后面我们还需要逆序输出</span><br><span class="line">        &#x2F;&#x2F;因此我们直接使用List&lt;String&gt; s2</span><br><span class="line">        List&lt;String&gt; s2 &#x3D; new ArrayList&lt;&gt;();&#x2F;&#x2F;存储中间结果的list</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;遍历ls</span><br><span class="line">        for (String item : ls) &#123;</span><br><span class="line">            &#x2F;&#x2F;如果是一个数,加入到s2</span><br><span class="line">            if (item.matches(&quot;\\d+&quot;)) &#123;</span><br><span class="line">                s2.add(item);</span><br><span class="line">            &#125; else if (item.equals(&quot;(&quot;)) &#123;</span><br><span class="line">                s1.push(item);</span><br><span class="line">            &#125; else if (item.equals(&quot;)&quot;)) &#123;</span><br><span class="line">                &#x2F;&#x2F;如果是右括号“）”,则依次弹出s1栈顶的运算符,并压入s2，直到遇到左括号位置,此时将一对括号丢弃</span><br><span class="line">                while (!s1.peek().equals(&quot;(&quot;)) &#123;</span><br><span class="line">                    s2.add(s1.pop());</span><br><span class="line">                &#125;</span><br><span class="line">                s1.pop();&#x2F;&#x2F;将“（”弹出s1这个栈</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                &#x2F;&#x2F;当item的优先级小于等于s1栈顶运算符，将s1栈顶的运算符弹出并加入到s2中,再次转到4,1与s1中新的栈顶运算符比较</span><br><span class="line">                &#x2F;&#x2F;问题:缺少一个比较优先级高低的方法</span><br><span class="line">                while (s1.size() !&#x3D; 0 &amp;&amp; Operation.getValue(s1.peek())&gt;&#x3D;Operation.getValue(item))&#123;</span><br><span class="line">                    s2.add(s1.pop());</span><br><span class="line">                &#125;</span><br><span class="line">                &#x2F;&#x2F;还需要将item压入栈中</span><br><span class="line">                s1.push(item);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;将s1中剩余的运算符依次弹出并加入到s2</span><br><span class="line">        while (s1.size()!&#x3D;0)&#123;</span><br><span class="line">            s2.add(s1.pop());</span><br><span class="line">        &#125;</span><br><span class="line">        return s2; &#x2F;&#x2F;因为存放到list，因此按照顺序输出就是顺序的</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 3 4 + 5 * 6 -</span><br><span class="line">     * 完成对逆波兰表达式的运算</span><br><span class="line">     * 1.从左至右扫描,将3和4压入堆栈中</span><br><span class="line">     * 2.遇到+运算符,因此弹出4和3(4为栈顶元素,3为次顶元素,)计算出3+4的值,得7再将7入栈;</span><br><span class="line">     * 3.将5入栈</span><br><span class="line">     * 4.接下来是x运算,因此弹出5和7计算5*7&#x3D;35,将35入栈,将6入栈</span><br><span class="line">     * 最后是-运算符,计算出35-6的值,即29由此得出结果</span><br><span class="line">     *</span><br><span class="line">     * @param ls</span><br><span class="line">     * @return</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public static int calculate(List&lt;String&gt; ls) &#123;</span><br><span class="line">        &#x2F;&#x2F;创建一个栈,只需要一个栈</span><br><span class="line">        Stack&lt;String&gt; stack &#x3D; new Stack&lt;&gt;();</span><br><span class="line">        &#x2F;&#x2F;遍历ls</span><br><span class="line">        for (String item : ls) &#123;</span><br><span class="line">            &#x2F;&#x2F;使用正则表达式来取出数</span><br><span class="line">            if (item.matches(&quot;\\d+&quot;)) &#123;</span><br><span class="line">                &#x2F;&#x2F;匹配的是多位数</span><br><span class="line">                stack.push(item);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                &#x2F;&#x2F;pop出两个数,并运算,再入栈</span><br><span class="line">                int num2 &#x3D; Integer.parseInt(stack.pop());</span><br><span class="line">                int num1 &#x3D; Integer.parseInt(stack.pop());</span><br><span class="line">                int res &#x3D; 0;</span><br><span class="line">                if (item.equals(&quot;+&quot;)) &#123;</span><br><span class="line">                    res &#x3D; num1 + num2;</span><br><span class="line">                &#125; else if (item.equals(&quot;-&quot;)) &#123;</span><br><span class="line">                    res &#x3D; num1 - num2;</span><br><span class="line">                &#125; else if (item.equals(&quot;*&quot;)) &#123;</span><br><span class="line">                    res &#x3D; num1 * num2;</span><br><span class="line">                &#125; else if (item.equals(&quot;&#x2F;&quot;)) &#123;</span><br><span class="line">                    res &#x3D; num1 &#x2F; num2;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    throw new RuntimeException(&quot;运算符有误&quot;);</span><br><span class="line">                &#125;</span><br><span class="line">                &#x2F;&#x2F;把res入栈</span><br><span class="line">                stack.push(res + &quot;&quot;);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;最后留在stack中的数据就是运算结果</span><br><span class="line">        return Integer.parseInt(stack.pop());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * Description:编写一个类Operation可以返回一个运算符对应的优先级</span><br><span class="line"> *</span><br><span class="line"> * @author Todcsw</span><br><span class="line"> * @date</span><br><span class="line"> *&#x2F;</span><br><span class="line">class Operation &#123;</span><br><span class="line">    private static int ADD &#x3D; 1;</span><br><span class="line">    private static int SUB &#x3D; 1;</span><br><span class="line">    private static int MUL &#x3D; 2;</span><br><span class="line">    private static int DIV &#x3D; 2;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;写一个方法,返回对应的优先级数字</span><br><span class="line">    public static int getValue(String operation) &#123;</span><br><span class="line">        int result &#x3D; 0;</span><br><span class="line">        switch (operation) &#123;</span><br><span class="line">            case &quot;+&quot;:</span><br><span class="line">                result &#x3D;ADD;</span><br><span class="line">            break;</span><br><span class="line">            case &quot;-&quot;:</span><br><span class="line">                result &#x3D; SUB;</span><br><span class="line">                break;</span><br><span class="line">            case &quot;*&quot;:</span><br><span class="line">                result &#x3D;MUL;</span><br><span class="line">                break;</span><br><span class="line">            case &quot;&#x2F;&quot;:</span><br><span class="line">                result &#x3D;DIV;</span><br><span class="line">                break;</span><br><span class="line">            default:</span><br><span class="line">                &#x2F;&#x2F;result&#x3D;0;</span><br><span class="line">                &#x2F;&#x2F;System.out.println(&quot;不存在该运算符&quot;);</span><br><span class="line">                break;</span><br><span class="line">        &#125;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;java实现中缀表达式转后缀表达式并使用栈计算逆波兰表达式&quot;&gt;&lt;a href=&quot;#java实现中缀表达式转后缀表达式并使用栈计算逆波兰表达式&quot; class=&quot;headerlink&quot; title=&quot;java实现中缀表达式转后缀表达式并使用栈计算逆波兰表达式&quot;&gt;&lt;/a
      
    
    </summary>
    
    
      <category term="数据结构" scheme="https://todcsw.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="学习" scheme="https://todcsw.github.io/tags/%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="java" scheme="https://todcsw.github.io/tags/java/"/>
    
      <category term="数据结构" scheme="https://todcsw.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>java实现栈</title>
    <link href="https://todcsw.github.io/2020/04/16/java%E5%AE%9E%E7%8E%B0%E6%A0%88/"/>
    <id>https://todcsw.github.io/2020/04/16/java%E5%AE%9E%E7%8E%B0%E6%A0%88/</id>
    <published>2020-04-16T05:47:25.000Z</published>
    <updated>2020-04-16T05:49:37.319Z</updated>
    
    <content type="html"><![CDATA[<h1 id="java实现栈"><a href="#java实现栈" class="headerlink" title="java实现栈"></a>java实现栈</h1><h2 id="废话不多说-直接上代码"><a href="#废话不多说-直接上代码" class="headerlink" title="废话不多说,直接上代码"></a>废话不多说,直接上代码</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package com.csw.stack;</span><br><span class="line"></span><br><span class="line">import java.util.Scanner;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * @Auther: 行路</span><br><span class="line"> * @Date: Created on 2020&#x2F;4&#x2F;15 13:36 星期三</span><br><span class="line"> * @Description: com.csw.stack</span><br><span class="line"> * @version: 1.0</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class ArrayStackDemo &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        &#x2F;&#x2F;测试以下ArrayStack是否正确</span><br><span class="line">        &#x2F;&#x2F;先创建一个ArrayStack对象-&gt;表示栈</span><br><span class="line">        ArrayStack stack&#x3D;new ArrayStack(4);</span><br><span class="line">        String key&#x3D;&quot;&quot;;</span><br><span class="line">        boolean loop&#x3D;true;&#x2F;&#x2F;控制是否退出菜单</span><br><span class="line">        Scanner scanner&#x3D;new Scanner(System.in);</span><br><span class="line"></span><br><span class="line">        while (loop)&#123;</span><br><span class="line">            System.out.println(&quot;show :表示显示栈&quot;);</span><br><span class="line">            System.out.println(&quot;exit :退出程序&quot;);</span><br><span class="line">            System.out.println(&quot;push :表示添加数据到栈&quot;);</span><br><span class="line">            System.out.println(&quot;pop :表示从栈取出数据(出栈)&quot;);</span><br><span class="line">            System.out.println(&quot;请输入你的选择:&quot;);</span><br><span class="line">            key&#x3D;scanner.next();</span><br><span class="line">            switch (key)&#123;</span><br><span class="line">                case &quot;show&quot;:</span><br><span class="line">                    stack.list();</span><br><span class="line">                    break;</span><br><span class="line">                case &quot;push&quot;:</span><br><span class="line">                    System.out.println(&quot;请输入一个数&quot;);</span><br><span class="line">                    int value&#x3D;scanner.nextInt();</span><br><span class="line">                    stack.push(value);</span><br><span class="line">                    break;</span><br><span class="line">                case &quot;pop&quot;:</span><br><span class="line">                    try &#123;</span><br><span class="line">                        int res&#x3D;stack.pop();</span><br><span class="line">                        System.out.println(res);</span><br><span class="line">                    &#125;catch (Exception e)&#123;</span><br><span class="line">                        System.out.println(e.getMessage());</span><br><span class="line">                    &#125;</span><br><span class="line">                    break;</span><br><span class="line">                case &quot;exit&quot;:</span><br><span class="line">                    scanner.close();</span><br><span class="line">                    loop&#x3D;false;</span><br><span class="line">                    break;</span><br><span class="line">                default:</span><br><span class="line">                    break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot;程序退出&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;定义一个ArrayStacke 栈</span><br><span class="line">class ArrayStack&#123;</span><br><span class="line">    private int maxSize;</span><br><span class="line">    private int[] stack; &#x2F;&#x2F;数组模拟栈,数据放在该数组中</span><br><span class="line">    private int top&#x3D;-1; &#x2F;&#x2F;表示栈顶,初始化为-1</span><br><span class="line"></span><br><span class="line">    public ArrayStack(int maxSize) &#123;</span><br><span class="line">        this.maxSize &#x3D; maxSize;</span><br><span class="line">        stack&#x3D;new int[this.maxSize];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 栈满</span><br><span class="line">     * @return</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public boolean isFull()&#123;</span><br><span class="line">        return top&#x3D;&#x3D;maxSize-1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 栈空</span><br><span class="line">     * @return</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public boolean isEmpty()&#123;</span><br><span class="line">        return top&#x3D;&#x3D;-1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 入栈</span><br><span class="line">     * @param value</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public void push(int value)&#123;</span><br><span class="line">        &#x2F;&#x2F;先判断栈是否满</span><br><span class="line">        if(isFull())&#123;</span><br><span class="line">            System.out.println(&quot;栈满&quot;);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        top++;</span><br><span class="line">        stack[top]&#x3D;value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 出栈,将栈顶的数据返回</span><br><span class="line">     * @return</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public int pop()&#123;</span><br><span class="line">        &#x2F;&#x2F;先判断栈是否空</span><br><span class="line">        if(isEmpty())&#123;</span><br><span class="line">            throw new RuntimeException(&quot;栈空,没有数据&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        int value&#x3D;stack[top];</span><br><span class="line">        top--;</span><br><span class="line">        return value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 遍历从栈顶遍历数据</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public void list()&#123;</span><br><span class="line">        if(isEmpty())&#123;</span><br><span class="line">            System.out.println(&quot;栈空,没有数据&quot;);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i&#x3D;top;i&gt;&#x3D;0;i--)&#123;</span><br><span class="line">            System.out.printf(&quot;stack[%d]&#x3D;%d\n&quot;,i,stack[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="java用栈实现计算器"><a href="#java用栈实现计算器" class="headerlink" title="java用栈实现计算器"></a>java用栈实现计算器</h1><h2 id="废话不多说-直接上代码-1"><a href="#废话不多说-直接上代码-1" class="headerlink" title="废话不多说,直接上代码"></a>废话不多说,直接上代码</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package com.csw.stack;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * @Auther: 行路</span><br><span class="line"> * @Date: Created on 2020&#x2F;4&#x2F;15 20:25 星期三</span><br><span class="line"> * @Description: com.csw.stack</span><br><span class="line"> * @version: 1.0</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class Calculator &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        &#x2F;&#x2F;根据思路</span><br><span class="line">        String expression &#x3D; &quot;70+40*4-2&quot;;</span><br><span class="line">        &#x2F;&#x2F;先创建两个栈,数栈和符号栈</span><br><span class="line">        ArrayStack2 numStack &#x3D; new ArrayStack2(10);</span><br><span class="line">        ArrayStack2 operStack &#x3D; new ArrayStack2(10);</span><br><span class="line">        &#x2F;&#x2F;定义需要扫描的相关变量</span><br><span class="line">        int index &#x3D; 0;&#x2F;&#x2F;用于扫描</span><br><span class="line">        int num1 &#x3D; 0;</span><br><span class="line">        int num2 &#x3D; 0;</span><br><span class="line">        int oper &#x3D; 0;</span><br><span class="line">        int res &#x3D; 0;</span><br><span class="line">        char ch &#x3D; &#39; &#39;; &#x2F;&#x2F;将没次扫描得到的char保存到ch</span><br><span class="line">        String keepNum &#x3D; &quot;&quot;;</span><br><span class="line">        &#x2F;&#x2F;开始while循环的扫描expression</span><br><span class="line">        while (true) &#123;</span><br><span class="line">            &#x2F;&#x2F;一次得到experession的每一个字符</span><br><span class="line">            ch &#x3D; expression.substring(index, index + 1).charAt(0);</span><br><span class="line">            &#x2F;&#x2F;判断ch是什么做响应的处理</span><br><span class="line">            if (operStack.isOper(ch)) &#123; &#x2F;&#x2F;如果是运算符</span><br><span class="line">                &#x2F;&#x2F;判断当前的符号栈是否为空</span><br><span class="line">                if (!operStack.isEmpty()) &#123;</span><br><span class="line">                    &#x2F;&#x2F;如果符号栈有操作符,就进行比较,如果当前的操作符优先级,小于火等于栈中的操作符,就需要从数栈</span><br><span class="line">                    &#x2F;&#x2F;中pop出两个数,再从符号栈中pop出一个符号,进行运算,将得到结果,入数栈后,然后将当前的操作符入符号栈</span><br><span class="line">                    if (operStack.priority(ch) &lt;&#x3D; operStack.priority(operStack.peek())) &#123;</span><br><span class="line">                        &#x2F;&#x2F;从数栈中pop出两个数</span><br><span class="line">                        num1 &#x3D; numStack.pop();</span><br><span class="line">                        num2 &#x3D; numStack.pop();</span><br><span class="line">                        oper &#x3D; operStack.pop();</span><br><span class="line">                        res &#x3D; numStack.cal(num1, num2, oper);</span><br><span class="line">                        &#x2F;&#x2F;把运算的结果入数栈</span><br><span class="line">                        numStack.push(res);</span><br><span class="line">                        &#x2F;&#x2F;然后把当前的操作符入符号栈</span><br><span class="line">                        operStack.push(ch);</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        &#x2F;&#x2F;如果当前的操作符优先级大于,直接入符号栈</span><br><span class="line">                        operStack.push(ch);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    &#x2F;&#x2F;如果为空,直接入符号栈</span><br><span class="line">                    operStack.push(ch);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                &#x2F;&#x2F;如果是数就直接用数栈</span><br><span class="line">                &#x2F;&#x2F; numStack.push(ch-48);&#x2F;&#x2F;? &quot;1+3&quot;</span><br><span class="line">                &#x2F;&#x2F;1.当处理多位数时,不能发现一个数就立即入栈,因为可能是多位数</span><br><span class="line">                &#x2F;&#x2F;2.在处理数,需要想expression的表达式index后再看一位,如果是数</span><br><span class="line">                &#x2F;&#x2F;3.因此需要定义字符串变量,用于拼接</span><br><span class="line">                &#x2F;&#x2F;处理多位数</span><br><span class="line">                keepNum +&#x3D; ch;</span><br><span class="line">                &#x2F;&#x2F;如果ch已经是expression的最后以位,就直接入栈</span><br><span class="line">                if (index &#x3D;&#x3D; expression.length() - 1) &#123;</span><br><span class="line">                    numStack.push(Integer.valueOf(keepNum));</span><br><span class="line">                &#125; else &#123;</span><br><span class="line"></span><br><span class="line">                    &#x2F;&#x2F;判断下一个字符是不是数字,如果是数字,则进行继续扫描，如果是运算符则入栈</span><br><span class="line">                    &#x2F;&#x2F;注意是看后面一位,不是index++</span><br><span class="line">                    &#x2F;&#x2F;如果后一位是操作符,则入栈</span><br><span class="line">                    if (operStack.isOper(expression.substring(index + 1, index + 2).charAt(0))) &#123;</span><br><span class="line">                        numStack.push(Integer.valueOf(keepNum));</span><br><span class="line">                        &#x2F;&#x2F;重要！！！keepNum清空</span><br><span class="line">                        keepNum &#x3D; &quot;&quot;;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F;让Index+1,并判断是否扫描到expression的最后</span><br><span class="line">            index++;</span><br><span class="line">            if (index &gt;&#x3D; expression.length()) &#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;当表达式扫描完毕,就顺序的从数栈和符号栈中pop出相应的符号,并允许</span><br><span class="line">        while (true) &#123;</span><br><span class="line">            &#x2F;&#x2F;如果符号栈为空,则计算到最后的结果,数栈中只有一个数字</span><br><span class="line">            if (operStack.isEmpty()) &#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            num1 &#x3D; numStack.pop();</span><br><span class="line">            num2 &#x3D; numStack.pop();</span><br><span class="line">            oper &#x3D; operStack.pop();</span><br><span class="line">            res &#x3D; numStack.cal(num1, num2, oper);</span><br><span class="line">            numStack.push(res); &#x2F;&#x2F;入栈</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;将数栈中最后数pop出,就是结果</span><br><span class="line">        int res2 &#x3D; numStack.pop();</span><br><span class="line">        System.out.printf(&quot;表达式%s&#x3D;%d&quot;, expression, res2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * Description:创建的一个栈</span><br><span class="line"> * 需要扩展功能</span><br><span class="line"> *</span><br><span class="line"> * @author Todcsw</span><br><span class="line"> * @date</span><br><span class="line"> *&#x2F;</span><br><span class="line">class ArrayStack2 &#123;</span><br><span class="line">    private int maxSize;</span><br><span class="line">    private int[] stack; &#x2F;&#x2F;数组模拟栈,数据放在该数组中</span><br><span class="line">    private int top &#x3D; -1; &#x2F;&#x2F;表示栈顶,初始化为-1</span><br><span class="line"></span><br><span class="line">    public ArrayStack2(int maxSize) &#123;</span><br><span class="line">        this.maxSize &#x3D; maxSize;</span><br><span class="line">        stack &#x3D; new int[this.maxSize];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;返回当前栈顶的值,但是不pop出来</span><br><span class="line">    public int peek() &#123;</span><br><span class="line">        return stack[top];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 栈满</span><br><span class="line">     *</span><br><span class="line">     * @return</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public boolean isFull() &#123;</span><br><span class="line">        return top &#x3D;&#x3D; maxSize - 1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 栈空</span><br><span class="line">     *</span><br><span class="line">     * @return</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public boolean isEmpty() &#123;</span><br><span class="line">        return top &#x3D;&#x3D; -1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 入栈</span><br><span class="line">     *</span><br><span class="line">     * @param value</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public void push(int value) &#123;</span><br><span class="line">        &#x2F;&#x2F;先判断栈是否满</span><br><span class="line">        if (isFull()) &#123;</span><br><span class="line">            System.out.println(&quot;栈满&quot;);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        top++;</span><br><span class="line">        stack[top] &#x3D; value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 出栈,将栈顶的数据返回</span><br><span class="line">     *</span><br><span class="line">     * @return</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public int pop() &#123;</span><br><span class="line">        &#x2F;&#x2F;先判断栈是否空</span><br><span class="line">        if (isEmpty()) &#123;</span><br><span class="line">            throw new RuntimeException(&quot;栈空,没有数据&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        int value &#x3D; stack[top];</span><br><span class="line">        top--;</span><br><span class="line">        return value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 遍历从栈顶遍历数据</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public void list() &#123;</span><br><span class="line">        if (isEmpty()) &#123;</span><br><span class="line">            System.out.println(&quot;栈空,没有数据&quot;);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i &#x3D; top; i &gt;&#x3D; 0; i--) &#123;</span><br><span class="line">            System.out.printf(&quot;stack[%d]&#x3D;%d\n&quot;, i, stack[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 返回运算符的优先级,假定数字越大,优先级就越高</span><br><span class="line">     *</span><br><span class="line">     * @param oper</span><br><span class="line">     * @return</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public int priority(int oper) &#123;</span><br><span class="line">        if (oper &#x3D;&#x3D; &#39;*&#39; || oper &#x3D;&#x3D; &#39;&#x2F;&#39;) &#123;</span><br><span class="line">            return 1;</span><br><span class="line">        &#125; else if (oper &#x3D;&#x3D; &#39;+&#39; || oper &#x3D;&#x3D; &#39;-&#39;) &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return -1; &#x2F;&#x2F;假设目前的表达式只有+,-,*,&#x2F;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 判断是不是运算符</span><br><span class="line">     *</span><br><span class="line">     * @param val</span><br><span class="line">     * @return</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public boolean isOper(char val) &#123;</span><br><span class="line">        return val &#x3D;&#x3D; &#39;+&#39; || val &#x3D;&#x3D; &#39;-&#39; || val &#x3D;&#x3D; &#39;*&#39; || val &#x3D;&#x3D; &#39;&#x2F;&#39;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 计算的方法</span><br><span class="line">     *</span><br><span class="line">     * @param num1</span><br><span class="line">     * @param num2</span><br><span class="line">     * @param oper</span><br><span class="line">     * @return</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public int cal(int num1, int num2, int oper) &#123;</span><br><span class="line">        int res &#x3D; 0;&#x2F;&#x2F;res用于存放计算的结果</span><br><span class="line">        switch (oper) &#123;</span><br><span class="line">            case &#39;+&#39;:</span><br><span class="line">                res &#x3D; num1 + num2;</span><br><span class="line">                break;</span><br><span class="line">            case &#39;-&#39;:</span><br><span class="line">                res &#x3D; num2 - num1; &#x2F;&#x2F;注意顺序</span><br><span class="line">                break;</span><br><span class="line">            case &#39;*&#39;:</span><br><span class="line">                res &#x3D; num1 * num2;</span><br><span class="line">                break;</span><br><span class="line">            case &#39;&#x2F;&#39;:</span><br><span class="line">                res &#x3D; num2 &#x2F; num1;</span><br><span class="line">                break;</span><br><span class="line">            default:</span><br><span class="line">                break;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;java实现栈&quot;&gt;&lt;a href=&quot;#java实现栈&quot; class=&quot;headerlink&quot; title=&quot;java实现栈&quot;&gt;&lt;/a&gt;java实现栈&lt;/h1&gt;&lt;h2 id=&quot;废话不多说-直接上代码&quot;&gt;&lt;a href=&quot;#废话不多说-直接上代码&quot; class=&quot;he
      
    
    </summary>
    
    
      <category term="数据结构" scheme="https://todcsw.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="学习" scheme="https://todcsw.github.io/tags/%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="java" scheme="https://todcsw.github.io/tags/java/"/>
    
      <category term="数据结构" scheme="https://todcsw.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>java实现双向链表</title>
    <link href="https://todcsw.github.io/2020/04/15/java%E5%AE%9E%E7%8E%B0%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8/"/>
    <id>https://todcsw.github.io/2020/04/15/java%E5%AE%9E%E7%8E%B0%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8/</id>
    <published>2020-04-15T06:08:44.000Z</published>
    <updated>2020-04-15T06:12:59.264Z</updated>
    
    <content type="html"><![CDATA[<h1 id="java实现双向链表"><a href="#java实现双向链表" class="headerlink" title="java实现双向链表"></a>java实现双向链表</h1><h2 id="废话不多说-直接上代码"><a href="#废话不多说-直接上代码" class="headerlink" title="废话不多说,直接上代码"></a>废话不多说,直接上代码</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package com.csw.LinkedList;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * @Auther: 行路</span><br><span class="line"> * @Date: Created on 2020&#x2F;4&#x2F;15 13:11 星期三</span><br><span class="line"> * @Description: com.csw.LinkedList</span><br><span class="line"> * @version: 1.0</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class DoubleLinkedListDemo &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        System.out.println(&quot;双向链表的测试&quot;);</span><br><span class="line">        &#x2F;&#x2F;创建节点</span><br><span class="line">        HeroNode2 hero1 &#x3D; new HeroNode2(1, &quot;松江&quot;, &quot;及时雨&quot;);</span><br><span class="line">        HeroNode2 hero2 &#x3D; new HeroNode2(2, &quot;卢&quot;, &quot;玉&quot;);</span><br><span class="line">        HeroNode2 hero3 &#x3D; new HeroNode2(3, &quot;无用&quot;, &quot;智多星&quot;);</span><br><span class="line">        HeroNode2 hero4 &#x3D; new HeroNode2(4, &quot;林冲&quot;, &quot;豹子头&quot;);</span><br><span class="line">        &#x2F;&#x2F;创建一个双向链表</span><br><span class="line">        DoubleLinkedList linkedList&#x3D;new DoubleLinkedList();</span><br><span class="line">        &#x2F;&#x2F;添加</span><br><span class="line">        linkedList.add(hero1);</span><br><span class="line">        linkedList.add(hero2);</span><br><span class="line">        linkedList.add(hero3);</span><br><span class="line">        linkedList.add(hero4);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;显示</span><br><span class="line">        linkedList.list();</span><br><span class="line">        &#x2F;&#x2F;修改</span><br><span class="line">        HeroNode2 node2&#x3D;new HeroNode2(4,&quot;公孙胜&quot;,&quot;入云龙&quot;);</span><br><span class="line">        linkedList.update(node2);</span><br><span class="line">        &#x2F;&#x2F;显示</span><br><span class="line">        System.out.println(&quot;修改后的链表&quot;);</span><br><span class="line">        linkedList.list();</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;删除</span><br><span class="line">        linkedList.del(3);</span><br><span class="line">        System.out.println(&quot;删除后的链表&quot;);</span><br><span class="line">        linkedList.list();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;创建一个双向链表的类</span><br><span class="line">class DoubleLinkedList &#123;</span><br><span class="line">    &#x2F;&#x2F;初始化一个头节点,头节点不动,不存放具体的数据</span><br><span class="line">    private HeroNode2 head &#x3D; new HeroNode2(0, &quot;&quot;, &quot;&quot;);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;返回头节点</span><br><span class="line">    public HeroNode2 getHead() &#123;</span><br><span class="line">        return head;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 遍历双向链表的方法</span><br><span class="line">     * 显示链表[遍历]</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public void list() &#123;</span><br><span class="line">        &#x2F;&#x2F;判断链表是否为空</span><br><span class="line">        if (head.next &#x3D;&#x3D; null) &#123;</span><br><span class="line">            System.out.println(&quot;链表为空&quot;);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;因为头节点,不能动,因次需要一个辅助变量来遍历</span><br><span class="line">        HeroNode2 temp &#x3D; head.next;</span><br><span class="line">        while (true) &#123;</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F;判断链表是否到最后</span><br><span class="line">            if (temp &#x3D;&#x3D; null) &#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F;输出节点的信息</span><br><span class="line">            System.out.println(temp.toString());</span><br><span class="line">            &#x2F;&#x2F;将temp后移</span><br><span class="line">            temp &#x3D; temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 添加一个节点到双向链表的最后</span><br><span class="line">     *</span><br><span class="line">     * @param heroNode</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public void add(HeroNode2 heroNode) &#123;</span><br><span class="line">        &#x2F;&#x2F;因为head节点不能动,因此我们需要一个辅助遍历temp</span><br><span class="line">        HeroNode2 temp &#x3D; head;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;遍历链表,找到最后</span><br><span class="line">        while (true) &#123;</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F;找到链表的最后</span><br><span class="line">            if (temp.next &#x3D;&#x3D; null) &#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F;如果没有找到最后,就将temp后移</span><br><span class="line">            temp &#x3D; temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;当退出while循环时,temp就指向了链表的最后</span><br><span class="line">        &#x2F;&#x2F;形成一个双向链表</span><br><span class="line">        temp.next &#x3D; heroNode;</span><br><span class="line">        heroNode.pre &#x3D; temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 修改一个节点的内容,可以看到几乎和单链表一样</span><br><span class="line">     * 节点的类型</span><br><span class="line">     *</span><br><span class="line">     * @param newHeroNode</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public void update(HeroNode2 newHeroNode) &#123;</span><br><span class="line">        &#x2F;&#x2F;判断是否为空</span><br><span class="line">        if (head.next &#x3D;&#x3D; null) &#123;</span><br><span class="line">            System.out.println(&quot;链表为空&quot;);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;找到需要修改的链表,根据no编号</span><br><span class="line">        &#x2F;&#x2F;定义一个辅助变量</span><br><span class="line">        HeroNode2 temp &#x3D; head.next;</span><br><span class="line">        boolean flag &#x3D; false; &#x2F;&#x2F;表示是否找到改节点</span><br><span class="line">        while (true) &#123;</span><br><span class="line">            if (temp &#x3D;&#x3D; null) &#123;</span><br><span class="line">                break;&#x2F;&#x2F;到链表的最后的下一个(表示链表已经遍历完)</span><br><span class="line">            &#125;</span><br><span class="line">            if (temp.no &#x3D;&#x3D; newHeroNode.no) &#123;</span><br><span class="line">                &#x2F;&#x2F;找到了</span><br><span class="line">                flag &#x3D; true;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            temp &#x3D; temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;根据flag判断是否找到要修改的节点</span><br><span class="line">        if (flag) &#123;</span><br><span class="line">            temp.name &#x3D; newHeroNode.name;</span><br><span class="line">            temp.nickname &#x3D; newHeroNode.nickname;</span><br><span class="line"></span><br><span class="line">        &#125; else &#123; &#x2F;&#x2F;没有找到</span><br><span class="line">            System.out.printf(&quot;没有找到编号%d的节点\n&quot;, newHeroNode.no);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 从双向链表中删除一个节点</span><br><span class="line">     * 对于双向链表,可以直接找到要删除的节点,找到后自我删除</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public void del(int no) &#123;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;判断当前链表是否为空</span><br><span class="line">        if (head.next &#x3D;&#x3D; null) &#123;</span><br><span class="line">            System.out.println(&quot;链表为空,无法删除&quot;);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        HeroNode2 temp &#x3D; head.next; &#x2F;&#x2F;辅助变量</span><br><span class="line">        boolean flag &#x3D; false; &#x2F;&#x2F;标识是否找到待删除节点</span><br><span class="line">        while (true) &#123;</span><br><span class="line">            if (temp &#x3D;&#x3D; null) &#123;</span><br><span class="line">                &#x2F;&#x2F;已经到链表的最后</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            if (temp.no &#x3D;&#x3D; no) &#123;</span><br><span class="line">                &#x2F;&#x2F;找到待删除节点的前一个节点</span><br><span class="line">                flag &#x3D; true;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            temp &#x3D; temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;判断flag</span><br><span class="line">        if (flag) &#123; &#x2F;&#x2F;找到节点,可以删除</span><br><span class="line">            temp.pre.next &#x3D; temp.next;</span><br><span class="line">            &#x2F;&#x2F;如果是最后一个节点,就不需要指向</span><br><span class="line">            if (temp.next !&#x3D; null) &#123;</span><br><span class="line">                temp.next.pre &#x3D; temp.pre;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            System.out.printf(&quot;要删除的%d节点,不存在\n&quot;, no);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;定义一个heroNode,每个heroNode对象就是一个节点</span><br><span class="line">class HeroNode2 &#123;</span><br><span class="line"></span><br><span class="line">    public int no;</span><br><span class="line">    public String name;</span><br><span class="line">    public String nickname;</span><br><span class="line">    public HeroNode2 next; &#x2F;&#x2F;指向下一个节点,默认为null</span><br><span class="line">    public HeroNode2 pre;  &#x2F;&#x2F;指向前一个节点,默认为null</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;构造器</span><br><span class="line"></span><br><span class="line">    public HeroNode2(int no, String name, String nickname) &#123;</span><br><span class="line">        this.no &#x3D; no;</span><br><span class="line">        this.name &#x3D; name;</span><br><span class="line">        this.nickname &#x3D; nickname;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return &quot;HeroNode2&#123;&quot; +</span><br><span class="line">                &quot;no&#x3D;&quot; + no +</span><br><span class="line">                &quot;, name&#x3D;&#39;&quot; + name + &#39;\&#39;&#39; +</span><br><span class="line">                &quot;, nickname&#x3D;&#39;&quot; + nickname + &#39;\&#39;&#39; +</span><br><span class="line">                &quot;, next&#x3D;&quot; + next +</span><br><span class="line">                &#39;&#125;&#39;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="约瑟夫环问题-单向循环链表"><a href="#约瑟夫环问题-单向循环链表" class="headerlink" title="约瑟夫环问题(单向循环链表)"></a>约瑟夫环问题(单向循环链表)</h1><h2 id="废话不多说-直接上代码-1"><a href="#废话不多说-直接上代码-1" class="headerlink" title="废话不多说,直接上代码"></a>废话不多说,直接上代码</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package com.csw.LinkedList;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * @Auther: 行路</span><br><span class="line"> * @Date: Created on 2020&#x2F;4&#x2F;14 21:59 星期二</span><br><span class="line"> * @Description: com.csw.LinkedList</span><br><span class="line"> * @version: 1.0</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class Josephu &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        &#x2F;&#x2F;测试一把看看构建环形链表,和遍历是否ok</span><br><span class="line">        CircleSingleLinkedList circleSingleLinkedList &#x3D; new CircleSingleLinkedList();</span><br><span class="line">        circleSingleLinkedList.addBoy(5); &#x2F;&#x2F;加入5个小孩节点</span><br><span class="line">        circleSingleLinkedList.showBoy();</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;测试小孩出圈是否正确&quot;);</span><br><span class="line">        circleSingleLinkedList.countBoy(1,2,5);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;创建环形的单向链表</span><br><span class="line">class CircleSingleLinkedList &#123;</span><br><span class="line">    &#x2F;&#x2F;创建一个first节点,当前没有编号</span><br><span class="line">    private Boy first &#x3D; new Boy(-1);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;添加小孩,构建成一个环形的链表</span><br><span class="line">    public void addBoy(int nums) &#123;</span><br><span class="line">        &#x2F;&#x2F;nums做一个数据校验</span><br><span class="line">        if (nums &lt; 1) &#123;</span><br><span class="line">            System.out.println(&quot;nums的值不正确&quot;);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        Boy curBoy &#x3D; null; &#x2F;&#x2F;辅助指针,帮助构建环形链表</span><br><span class="line">        &#x2F;&#x2F;使用for循环创建环形链表</span><br><span class="line">        for (int i &#x3D; 1; i &lt;&#x3D; nums; i++) &#123;</span><br><span class="line">            &#x2F;&#x2F;根据编号,创建小孩节点</span><br><span class="line">            Boy boy &#x3D; new Boy(i);</span><br><span class="line">            &#x2F;&#x2F;如果是第一个小孩</span><br><span class="line">            if (i &#x3D;&#x3D; 1) &#123;</span><br><span class="line">                first &#x3D; boy;</span><br><span class="line">                first.setNext(first); &#x2F;&#x2F;构成环</span><br><span class="line">                curBoy &#x3D; first; &#x2F;&#x2F;让curBoy指向</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                curBoy.setNext(boy); &#x2F;&#x2F;</span><br><span class="line">                boy.setNext(first);</span><br><span class="line">                curBoy &#x3D; boy;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;遍历当前的环形链表</span><br><span class="line">    public void showBoy() &#123;</span><br><span class="line">        &#x2F;&#x2F;判断链表是否为空</span><br><span class="line">        if (first &#x3D;&#x3D; null) &#123;</span><br><span class="line">            System.out.println(&quot;链表为空&quot;);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;因为first不能动,因此我们仍然使用一个辅助指针完成遍历</span><br><span class="line">        Boy curBoy &#x3D; first;</span><br><span class="line">        while (true) &#123;</span><br><span class="line">            System.out.printf(&quot;小孩的编号%d\n&quot;, curBoy.getNo());</span><br><span class="line">            if (curBoy.getNext() &#x3D;&#x3D; first) &#123; &#x2F;&#x2F;说明已经遍历完毕</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            curBoy &#x3D; curBoy.getNext();&#x2F;&#x2F;curBoy后移</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 根据用户的输入,计算出小孩出圈的概率</span><br><span class="line">     *</span><br><span class="line">     * @param startNo  表示第几个小孩楷书数数</span><br><span class="line">     * @param countNum 表示数几下</span><br><span class="line">     * @param nums     表示最初有多少小孩在圈中</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public void countBoy(int startNo, int countNum, int nums) &#123;</span><br><span class="line">        &#x2F;&#x2F;先对数据进行校验</span><br><span class="line">        if (first &#x3D;&#x3D; null || startNo &lt; 1 || startNo &gt; nums) &#123;</span><br><span class="line">            System.out.println(&quot;参数输入有问题,请重新输入&quot;);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;创建一个辅助节点,帮助完成小孩出圈</span><br><span class="line">        Boy helper &#x3D; first;</span><br><span class="line">        &#x2F;&#x2F;需要创建一个辅助指针(变量helper),事先应该指向环形链表最后这个节点</span><br><span class="line">        while (true) &#123;</span><br><span class="line">            if (helper.getNext() &#x3D;&#x3D; first) &#123; &#x2F;&#x2F;说明hepler指向最后小孩节点</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            helper &#x3D; helper.getNext();</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;小孩报数,先让first和helper移动k-1次</span><br><span class="line">        for (int j&#x3D;0;j&lt;startNo-1;j++)&#123;</span><br><span class="line">            first&#x3D;first.getNext();</span><br><span class="line">            helper&#x3D;helper.getNext();</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;当小孩报数时,让first和helper指针同时移动m-1次,然后出圈</span><br><span class="line">        &#x2F;&#x2F;这里是一个循环操作,直到圈中只有一个节点</span><br><span class="line">        while (true)&#123;</span><br><span class="line">            if(helper&#x3D;&#x3D;first)&#123; &#x2F;&#x2F;说明圈中只有一个节点</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F;让first和helper指针同时移动countNum-1</span><br><span class="line">            for (int j&#x3D;0;j&lt;countNum-1;j++)&#123;</span><br><span class="line">                first&#x3D;first.getNext();</span><br><span class="line">                helper&#x3D;helper.getNext();</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F;这时first指向的节点,就是要出圈的小孩节点</span><br><span class="line">            System.out.printf(&quot;小孩%d出圈\n&quot;,first.getNo());</span><br><span class="line">            &#x2F;&#x2F;这时将first指向小孩节点出圈</span><br><span class="line">            first&#x3D;first.getNext();</span><br><span class="line">            helper.setNext(first);&#x2F;&#x2F;相当于再次构建环形链表</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.printf(&quot;最后留在圈中的小孩编号%d\n&quot;,first.getNo());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;创建一个Boy类,表示一个节点</span><br><span class="line">class Boy &#123;</span><br><span class="line">    private int no;&#x2F;&#x2F;编号</span><br><span class="line">    private Boy next; &#x2F;&#x2F;指向下一个节点</span><br><span class="line"></span><br><span class="line">    public Boy(int no) &#123;</span><br><span class="line">        this.no &#x3D; no;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int getNo() &#123;</span><br><span class="line">        return no;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setNo(int no) &#123;</span><br><span class="line">        this.no &#x3D; no;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Boy getNext() &#123;</span><br><span class="line">        return next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setNext(Boy next) &#123;</span><br><span class="line">        this.next &#x3D; next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;java实现双向链表&quot;&gt;&lt;a href=&quot;#java实现双向链表&quot; class=&quot;headerlink&quot; title=&quot;java实现双向链表&quot;&gt;&lt;/a&gt;java实现双向链表&lt;/h1&gt;&lt;h2 id=&quot;废话不多说-直接上代码&quot;&gt;&lt;a href=&quot;#废话不多说-直接上代
      
    
    </summary>
    
    
      <category term="数据结构" scheme="https://todcsw.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="学习" scheme="https://todcsw.github.io/tags/%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="java" scheme="https://todcsw.github.io/tags/java/"/>
    
      <category term="数据结构" scheme="https://todcsw.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>java实现单链表</title>
    <link href="https://todcsw.github.io/2020/04/14/java%E5%AE%9E%E7%8E%B0%E5%8D%95%E9%93%BE%E8%A1%A8/"/>
    <id>https://todcsw.github.io/2020/04/14/java%E5%AE%9E%E7%8E%B0%E5%8D%95%E9%93%BE%E8%A1%A8/</id>
    <published>2020-04-14T13:03:26.000Z</published>
    <updated>2020-04-14T13:05:23.506Z</updated>
    
    <content type="html"><![CDATA[<h1 id="java实现单链表"><a href="#java实现单链表" class="headerlink" title="java实现单链表"></a>java实现单链表</h1><h2 id="废话不多说-直接上代码"><a href="#废话不多说-直接上代码" class="headerlink" title="废话不多说,直接上代码"></a>废话不多说,直接上代码</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package com.csw.LinkedList;</span><br><span class="line"></span><br><span class="line">import jdk.nashorn.internal.ir.Flags;</span><br><span class="line"></span><br><span class="line">import java.util.Stack;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * @Auther: 行路</span><br><span class="line"> * @Date: Created on 2020&#x2F;4&#x2F;14 20:03:24</span><br><span class="line"> * @Description: com.csw.LinkedList 该链表按照添加顺序存储。</span><br><span class="line"> * @version: 1.0</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class SIngleLinkedListDemo &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        &#x2F;&#x2F;测试代码</span><br><span class="line">        &#x2F;&#x2F;创建节点</span><br><span class="line">        HeroNode hero1 &#x3D; new HeroNode(1, &quot;松江&quot;, &quot;及时雨&quot;);</span><br><span class="line">        HeroNode hero2 &#x3D; new HeroNode(2, &quot;卢&quot;, &quot;玉&quot;);</span><br><span class="line">        HeroNode hero3 &#x3D; new HeroNode(3, &quot;无用&quot;, &quot;智多星&quot;);</span><br><span class="line">        HeroNode hero4 &#x3D; new HeroNode(4, &quot;林冲&quot;, &quot;豹子头&quot;);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;创建链表</span><br><span class="line">        SingleLinkedList singleLinkedList&#x3D;new SingleLinkedList();</span><br><span class="line">        &#x2F;&#x2F;加入按照编号的顺序</span><br><span class="line">&#x2F;&#x2F;        singleLinkedList.add(hero1);</span><br><span class="line">&#x2F;&#x2F;        singleLinkedList.add(hero2);</span><br><span class="line">&#x2F;&#x2F;        singleLinkedList.add(hero3);</span><br><span class="line">&#x2F;&#x2F;        singleLinkedList.add(hero4);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        singleLinkedList.addByOrder(hero2);</span><br><span class="line">        singleLinkedList.addByOrder(hero1);</span><br><span class="line">        singleLinkedList.addByOrder(hero4);</span><br><span class="line">        singleLinkedList.addByOrder(hero3);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;修改前</span><br><span class="line"></span><br><span class="line">        singleLinkedList.list();</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;测试修改节点的代码</span><br><span class="line">        HeroNode hero5&#x3D;new HeroNode(2,&quot;骁龙&quot;,&quot;855&quot;);</span><br><span class="line">        singleLinkedList.update(hero5);</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;~~~~~~~~&quot;);</span><br><span class="line">        &#x2F;&#x2F;显示</span><br><span class="line">        singleLinkedList.del(4);</span><br><span class="line">        singleLinkedList.list();</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;有效节点的个数&quot;+getLength(singleLinkedList.getHead()));</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;测试得到倒数第k个&quot;);</span><br><span class="line">        HeroNode res&#x3D;findLastIndexNode(singleLinkedList.getHead(),3);</span><br><span class="line">        System.out.println(res);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;逆序打印&quot;);</span><br><span class="line">        reversePrint(singleLinkedList.getHead()); &#x2F;&#x2F;没有改变链表的本身结构</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;测试反转&quot;);</span><br><span class="line">        reversetList(singleLinkedList.getHead());</span><br><span class="line">        singleLinkedList.list();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * &#x2F;&#x2F;方法,获取单链表的节点个数(如果带头节点的链表,需求不统计头节点)</span><br><span class="line">     *这是一个方法,返回单链表的有效的节点个数</span><br><span class="line">     * @param head 链表的头节点</span><br><span class="line">     * @return 返回的是有效节点的个数</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public static int getLength(HeroNode head)&#123;</span><br><span class="line">        if(head.next&#x3D;&#x3D;null)&#123; &#x2F;&#x2F;空链表</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        int length&#x3D;0;</span><br><span class="line">        &#x2F;&#x2F;定义一个辅助变量</span><br><span class="line">        HeroNode cur&#x3D;head.next;</span><br><span class="line">        while(cur!&#x3D;null)&#123;</span><br><span class="line">            length++;</span><br><span class="line">            cur&#x3D;cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        return length;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * &#x2F;&#x2F;查找单链表中的倒数第k个结点(新浪面试题)</span><br><span class="line">     *     &#x2F;&#x2F;思路</span><br><span class="line">     *     &#x2F;&#x2F;1.编写一个方法,接收head节点,同时接收一个index</span><br><span class="line">     *     &#x2F;&#x2F;2.index 表示是倒数第Index个节点</span><br><span class="line">     *     &#x2F;&#x2F;3.先把链表从头到尾遍历,得到链表的总长度,getLength</span><br><span class="line">     *     &#x2F;&#x2F;4.得到size后,我们从链表的第一个开始遍历(size-index)个,就可以得到</span><br><span class="line">     *     &#x2F;&#x2F;5,如果找到了,则返回该节点,否则返回null</span><br><span class="line">     * @param head</span><br><span class="line">     * @param index</span><br><span class="line">     * @return</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public static HeroNode findLastIndexNode(HeroNode head,int index)&#123;</span><br><span class="line">        &#x2F;&#x2F;判断如果链表为空,返回null</span><br><span class="line">        if(head.next&#x3D;&#x3D;null)&#123;</span><br><span class="line">            return null; &#x2F;&#x2F;没有找到</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;第一次遍历得到的链表的长度(节点的个数)</span><br><span class="line">        int size&#x3D;getLength(head);</span><br><span class="line">        &#x2F;&#x2F;第二次遍历 size-index位置,就是我们倒数的第k个节点</span><br><span class="line">        &#x2F;&#x2F;先做一个(index)数据的校验</span><br><span class="line">        if(index&lt;&#x3D;0||index&gt;size)&#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;定义一个辅助变量,for循环定位到倒数的Index</span><br><span class="line">        HeroNode cur&#x3D;head.next;</span><br><span class="line">        for(int i&#x3D;0;i&lt;size-index;i++)&#123;</span><br><span class="line">            cur&#x3D;cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        return cur;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;将单链表进行反转</span><br><span class="line">    public static void  reversetList(HeroNode head)&#123;</span><br><span class="line">        &#x2F;&#x2F;如果链表为空,或者只有一个节点,无需反转,直接返回</span><br><span class="line">        if(head.next&#x3D;&#x3D;null||head.next.next&#x3D;&#x3D;null)&#123;</span><br><span class="line">            return ;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;先定义一个辅助的变量,帮助我们遍历原来的链表</span><br><span class="line">        HeroNode cur&#x3D;head.next;</span><br><span class="line">        HeroNode next&#x3D;null; &#x2F;&#x2F;指向当前节点[cur]的下一个节点</span><br><span class="line">        HeroNode reverseHead&#x3D;new HeroNode(0,&quot;&quot;,&quot;&quot;);</span><br><span class="line">        &#x2F;&#x2F;遍历原来的链表,并从点到尾遍历原来的链表,每遍历一个节点,就将其取出,并放在新的链表reverseHead的最前端</span><br><span class="line">        while(cur!&#x3D;null)&#123;</span><br><span class="line">            next&#x3D;cur.next;&#x2F;&#x2F;先暂时保存当前节点的下一个节点</span><br><span class="line">            cur.next&#x3D;reverseHead.next; &#x2F;&#x2F;将cur的下一个节点指向新的链表的最前端</span><br><span class="line">            reverseHead.next&#x3D;cur; &#x2F;&#x2F;将cur连接到新的链表上</span><br><span class="line">            cur&#x3D;next; &#x2F;&#x2F;让cur指向下一个节点,后移一次</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;将head.next指向reverseHead.next,实现单链表的反转</span><br><span class="line">        head.next&#x3D;reverseHead.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;从尾到头打印单链表(逆序打印单链表)</span><br><span class="line">    &#x2F;&#x2F;方式一:先将单链表进行反转,然后再遍历,破坏原来的单链表的结构</span><br><span class="line">    &#x2F;&#x2F;方式二:利用栈,将各个节点压入栈,然后利用栈的先进后厨特点,实现逆序打印的效果。</span><br><span class="line">    &#x2F;&#x2F;使用方式二</span><br><span class="line">    public static void  reversePrint(HeroNode head)&#123;</span><br><span class="line">        if(head.next&#x3D;&#x3D;null)&#123;</span><br><span class="line">            return;&#x2F;&#x2F;空链表不能打印</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;创建一个栈,将各个节点压入栈</span><br><span class="line">        Stack&lt;HeroNode&gt; stack&#x3D;new Stack&lt;&gt;();</span><br><span class="line">        HeroNode cur&#x3D;head.next;</span><br><span class="line">        &#x2F;&#x2F;将链表的所有节点压入栈中</span><br><span class="line">        while (cur!&#x3D;null)&#123;</span><br><span class="line">            stack.push(cur);</span><br><span class="line">            cur&#x3D;cur.next; &#x2F;&#x2F;将cur后移,这样就可以压入下一个节点</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;将栈中的节点进行打印pop出栈</span><br><span class="line">        while (stack.size()&gt;0)&#123;</span><br><span class="line">            System.out.println(stack.pop()); &#x2F;&#x2F;stack的特点是先进后厨</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;定义SingleLinkedList管理我们的英雄</span><br><span class="line">class SingleLinkedList&#123;</span><br><span class="line">    &#x2F;&#x2F;先创建一个头节点,头节点不要动</span><br><span class="line">    private HeroNode head&#x3D;new HeroNode(0,&quot;&quot;,&quot;&quot;);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;返回头节点</span><br><span class="line">    public HeroNode getHead() &#123;</span><br><span class="line">        return head;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setHead(HeroNode head) &#123;</span><br><span class="line">        this.head &#x3D; head;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;添加节点到单向链表</span><br><span class="line">    &#x2F;&#x2F;思路,当不考虑编号顺序</span><br><span class="line">    &#x2F;&#x2F;1.找到当前链表的最后节点</span><br><span class="line">    &#x2F;&#x2F;2.将最后这个节点的next,指向新的链表</span><br><span class="line">    public void add(HeroNode heroNode)&#123;</span><br><span class="line">        &#x2F;&#x2F;因为head节点不能动,因此我们需要一个辅助遍历temp</span><br><span class="line">        HeroNode temp&#x3D;head;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;遍历链表,找到最后</span><br><span class="line">        while (true)&#123;</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F;找到链表的最后</span><br><span class="line">            if(temp.next&#x3D;&#x3D;null)&#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F;如果没有找到最后,就将temp后移</span><br><span class="line">            temp&#x3D;temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;当退出while循环时,temp就指向了链表的最后</span><br><span class="line">        &#x2F;&#x2F;将最后这个 节点的next指向新的节点</span><br><span class="line">        temp.next&#x3D;heroNode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;第二种添加人物按照顺序添加到指定的位置</span><br><span class="line">    public  void  addByOrder(HeroNode heroNode)&#123;</span><br><span class="line">        &#x2F;&#x2F;头节点不能动,因此我们任然需要通过辅助指针</span><br><span class="line">        &#x2F;&#x2F;因为单链表,我们找的temp是位于添加位置的前一个节点,否则加入失败</span><br><span class="line">        HeroNode temp&#x3D;head;</span><br><span class="line"></span><br><span class="line">        boolean flag&#x3D;false; &#x2F;&#x2F;标识添加的编号是否存在,默认为false;</span><br><span class="line">        while (true)&#123;</span><br><span class="line">            if(temp.next&#x3D;&#x3D;null)&#123;</span><br><span class="line">                &#x2F;&#x2F;说明temp已经在链表的最后</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            if(temp.next.no&gt;heroNode.no)&#123; &#x2F;&#x2F;位置找到,就在temp的后面插入</span><br><span class="line">                break;</span><br><span class="line">            &#125;else if(temp.next.no&#x3D;&#x3D;heroNode.no)&#123; &#x2F;&#x2F;说明希望添加的heroNode的编号已经存在</span><br><span class="line">                flag&#x3D;true; &#x2F;&#x2F;说明编号存在</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            temp&#x3D;temp.next; &#x2F;&#x2F;后移,遍历当前链表</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;判断flag的值</span><br><span class="line">        if(flag)&#123; &#x2F;&#x2F;不能添加,说明编号已经存在</span><br><span class="line">            System.out.println(&quot;准备插入的人的编号已经存在,不能加入,&quot;+heroNode.no);</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            &#x2F;&#x2F;插入到链表中,temp的后边</span><br><span class="line">            heroNode.next&#x3D;temp.next;</span><br><span class="line">            temp.next&#x3D;heroNode;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;删除节点</span><br><span class="line">    &#x2F;&#x2F;思路</span><br><span class="line">    &#x2F;&#x2F;1.head节点不能动,因此需要一个temp辅助节点,找到待删除节点的前一个节点</span><br><span class="line">    &#x2F;&#x2F;2.说明我们在比较时,是temp.next.no和要删除的节点的no比较</span><br><span class="line">    public void del(int no)&#123;</span><br><span class="line">        HeroNode temp&#x3D;head;</span><br><span class="line">        boolean flag&#x3D;false; &#x2F;&#x2F;标识是否找到待删除节点</span><br><span class="line">        while(true)&#123;</span><br><span class="line">            if(temp.next&#x3D;&#x3D;null)&#123;</span><br><span class="line">                &#x2F;&#x2F;已经到链表的最后</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            if(temp.next.no&#x3D;&#x3D;no)&#123;</span><br><span class="line">                &#x2F;&#x2F;找到待删除节点的前一个节点</span><br><span class="line">                flag&#x3D;true;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            temp&#x3D;temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;判断flag</span><br><span class="line">        if(flag)&#123; &#x2F;&#x2F;找到节点,可以删除</span><br><span class="line">            temp.next&#x3D;temp.next.next;</span><br><span class="line">        &#125;else &#123;</span><br><span class="line">            System.out.printf(&quot;要删除的%d节点,不存在\n&quot;,no);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;修改节点的信息,根据编号来修改,即no编号不能改</span><br><span class="line">    &#x2F;&#x2F;说明:根据newHeroNode的no来修改</span><br><span class="line">    public void update(HeroNode newHeroNode)&#123;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;判断是否为空</span><br><span class="line">        if(head.next&#x3D;&#x3D;null)&#123;</span><br><span class="line">            System.out.println(&quot;链表为空&quot;);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;找到需要修改的链表,根据no编号</span><br><span class="line">        &#x2F;&#x2F;定义一个辅助变量</span><br><span class="line">        HeroNode temp&#x3D;head.next;</span><br><span class="line">        boolean flag&#x3D;false; &#x2F;&#x2F;表示是否找到改节点</span><br><span class="line">        while(true)&#123;</span><br><span class="line">            if(temp&#x3D;&#x3D;null)&#123;</span><br><span class="line">                break;&#x2F;&#x2F;到链表的最后的下一个(表示链表已经遍历完)</span><br><span class="line">            &#125;</span><br><span class="line">            if(temp.no&#x3D;&#x3D;newHeroNode.no)&#123;</span><br><span class="line">                &#x2F;&#x2F;找到了</span><br><span class="line">                flag&#x3D;true;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            temp&#x3D;temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;根据flag判断是否找到要修改的节点</span><br><span class="line">        if(flag)&#123;</span><br><span class="line">            temp.name&#x3D;newHeroNode.name;</span><br><span class="line">            temp.nickname&#x3D;newHeroNode.nickname;</span><br><span class="line"></span><br><span class="line">        &#125;else&#123; &#x2F;&#x2F;没有找到</span><br><span class="line">            System.out.printf(&quot;没有找到编号%d的节点\n&quot;,newHeroNode.no);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;显示链表[遍历]</span><br><span class="line">    public void list()&#123;</span><br><span class="line">        &#x2F;&#x2F;判断链表是否为空</span><br><span class="line">        if(head.next&#x3D;&#x3D;null)&#123;</span><br><span class="line">            System.out.println(&quot;链表为空&quot;);</span><br><span class="line">            return ;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;因为头节点,不能动,因次需要一个辅助变量来遍历</span><br><span class="line">        HeroNode temp&#x3D;head.next;</span><br><span class="line">        while (true)&#123;</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F;判断链表是否到最后</span><br><span class="line">            if(temp&#x3D;&#x3D;null)&#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F;输出节点的信息</span><br><span class="line">            System.out.println(temp.toString());</span><br><span class="line">            &#x2F;&#x2F;将temp后移</span><br><span class="line">            temp&#x3D;temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;定义一个heroNode,每个heroNode对象就是一个节点</span><br><span class="line">class HeroNode&#123;</span><br><span class="line"></span><br><span class="line">    public int no;</span><br><span class="line">    public String name;</span><br><span class="line">    public String nickname;</span><br><span class="line">    public HeroNode next; &#x2F;&#x2F;指向下一个节点</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;构造器</span><br><span class="line"></span><br><span class="line">    public HeroNode(int no, String name, String nickname) &#123;</span><br><span class="line">        this.no &#x3D; no;</span><br><span class="line">        this.name &#x3D; name;</span><br><span class="line">        this.nickname &#x3D; nickname;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return &quot;HeroNode&#123;&quot; +</span><br><span class="line">                &quot;no&#x3D;&quot; + no +</span><br><span class="line">                &quot;, name&#x3D;&#39;&quot; + name + &#39;\&#39;&#39; +</span><br><span class="line">                &quot;, nickname&#x3D;&#39;&quot; + nickname + &#39;\&#39;&#39; +</span><br><span class="line">                &#39;&#125;&#39;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;java实现单链表&quot;&gt;&lt;a href=&quot;#java实现单链表&quot; class=&quot;headerlink&quot; title=&quot;java实现单链表&quot;&gt;&lt;/a&gt;java实现单链表&lt;/h1&gt;&lt;h2 id=&quot;废话不多说-直接上代码&quot;&gt;&lt;a href=&quot;#废话不多说-直接上代码&quot; c
      
    
    </summary>
    
    
      <category term="数据结构" scheme="https://todcsw.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="学习" scheme="https://todcsw.github.io/tags/%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="java" scheme="https://todcsw.github.io/tags/java/"/>
    
      <category term="数据结构" scheme="https://todcsw.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>猜数游戏作业</title>
    <link href="https://todcsw.github.io/2020/04/13/%E7%8C%9C%E6%95%B0%E6%B8%B8%E6%88%8F/"/>
    <id>https://todcsw.github.io/2020/04/13/%E7%8C%9C%E6%95%B0%E6%B8%B8%E6%88%8F/</id>
    <published>2020-04-13T11:10:36.000Z</published>
    <updated>2020-04-13T12:43:14.679Z</updated>
    
    <content type="html"><![CDATA[<h1 id="jsp的猜数游戏作业"><a href="#jsp的猜数游戏作业" class="headerlink" title="jsp的猜数游戏作业"></a>jsp的猜数游戏作业</h1><h2 id="guess1-jsp"><a href="#guess1-jsp" class="headerlink" title="guess1.jsp"></a>guess1.jsp</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;%@ page import&#x3D;&quot;java.util.Random&quot; %&gt;&lt;%--</span><br><span class="line">  Created by IntelliJ IDEA.</span><br><span class="line">  User: 行路</span><br><span class="line">  Date: 2020&#x2F;4&#x2F;13</span><br><span class="line">  Time: 19:06</span><br><span class="line">  To change this template use File | Settings | File Templates.</span><br><span class="line">--%&gt;</span><br><span class="line">&lt;%@ page contentType&#x3D;&quot;text&#x2F;html;charset&#x3D;UTF-8&quot; language&#x3D;&quot;java&quot; %&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;guess1&lt;&#x2F;title&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;%</span><br><span class="line">    Random random&#x3D;new Random();</span><br><span class="line">   int  i &#x3D; random.nextInt(100) + 1;</span><br><span class="line">    session.setAttribute(&quot;rand&quot;,i);</span><br><span class="line">    int count&#x3D;0;</span><br><span class="line">    session.setAttribute(&quot;count&quot;,count);</span><br><span class="line">    long time &#x3D; System.currentTimeMillis();</span><br><span class="line">    session.setAttribute(&quot;time&quot;,time);</span><br><span class="line">    response.sendRedirect(&quot;Guess.jsp&quot;);</span><br><span class="line">%&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure><h2 id="Guess-jsp"><a href="#Guess-jsp" class="headerlink" title="Guess.jsp"></a>Guess.jsp</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;%@ page import&#x3D;&quot;java.util.Random&quot; %&gt;&lt;%--</span><br><span class="line">  Created by IntelliJ IDEA.</span><br><span class="line">  User: 行路</span><br><span class="line">  Date: 2020&#x2F;4&#x2F;13</span><br><span class="line">  Time: 18:47</span><br><span class="line">  To change this template use File | Settings | File Templates.</span><br><span class="line">--%&gt;</span><br><span class="line">&lt;%@ page contentType&#x3D;&quot;text&#x2F;html;charset&#x3D;UTF-8&quot; language&#x3D;&quot;java&quot; %&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;猜数游戏&lt;&#x2F;title&gt;</span><br><span class="line">&lt;&#x2F;head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;%</span><br><span class="line">    int i &#x3D; (int) session.getAttribute(&quot;rand&quot;);</span><br><span class="line">    int count &#x3D; (int) session.getAttribute(&quot;count&quot;);</span><br><span class="line">    long currentTimeMillis &#x3D; 0;</span><br><span class="line">    System.out.println(i);</span><br><span class="line">    if (request.getParameter(&quot;guess&quot;) !&#x3D; &quot;&quot; &amp;&amp; request.getParameter(&quot;guess&quot;) !&#x3D; null) &#123;</span><br><span class="line">        int guess &#x3D; Integer.parseInt(request.getParameter(&quot;guess&quot;));</span><br><span class="line">        if (guess &gt; i) &#123;</span><br><span class="line">            session.setAttribute(&quot;guess&quot;, &quot;猜大了&quot;);</span><br><span class="line">            count++;</span><br><span class="line">            session.setAttribute(&quot;count&quot;, count);</span><br><span class="line">        &#125; else if (guess &lt; i) &#123;</span><br><span class="line">            session.setAttribute(&quot;guess&quot;, &quot;猜的太小了&quot;);</span><br><span class="line">            count++;</span><br><span class="line">            session.setAttribute(&quot;count&quot;, count);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            session.setAttribute(&quot;guess&quot;, &quot;猜数正确&quot;);</span><br><span class="line">            currentTimeMillis &#x3D; System.currentTimeMillis();</span><br><span class="line">            count++;</span><br><span class="line">            session.setAttribute(&quot;count&quot;, count);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        session.setAttribute(&quot;guess&quot;, &quot;输入的数不能为空&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">%&gt;</span><br><span class="line">&lt;form action&#x3D;&quot;Guess.jsp&quot; method&#x3D;&quot;post&quot; &gt;</span><br><span class="line">    &lt;p&gt;&lt;%</span><br><span class="line">        if (session.getAttribute(&quot;guess&quot;) !&#x3D; null) &#123;</span><br><span class="line">            out.write(session.getAttribute(&quot;guess&quot;).toString());</span><br><span class="line">            if (session.getAttribute(&quot;guess&quot;).toString().equals(&quot;猜数正确&quot;)) &#123;</span><br><span class="line">                out.write(&quot;共猜了&quot; + (int) session.getAttribute(&quot;count&quot;) + &quot;次,耗时&quot; + (currentTimeMillis - (Long) session.getAttribute(&quot;time&quot;)) &#x2F; 1000 + &quot;秒&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    %&gt;</span><br><span class="line">    &lt;&#x2F;p&gt;</span><br><span class="line">    &lt;h2&gt;猜数游戏&lt;&#x2F;h2&gt;</span><br><span class="line">    &lt;p&gt;请输入1-100的数字&lt;&#x2F;p&gt;</span><br><span class="line">    &lt;input type&#x3D;&quot;text&quot; name&#x3D;&quot;guess&quot;&#x2F;&gt;</span><br><span class="line">    &lt;%</span><br><span class="line">        if (session.getAttribute(&quot;guess&quot;) !&#x3D; null &amp;&amp; session.getAttribute(&quot;guess&quot;).toString().equals(&quot;猜数正确&quot;)) &#123;</span><br><span class="line">            session.removeAttribute(&quot;guess&quot;);</span><br><span class="line">    %&gt;</span><br><span class="line">    &lt;button type&#x3D;&quot;submit&quot; disabled&gt;提交&lt;&#x2F;button&gt;</span><br><span class="line">    &lt;% &#125; else &#123;%&gt;</span><br><span class="line">    &lt;button type&#x3D;&quot;submit&quot;&gt;提交&lt;&#x2F;button&gt;</span><br><span class="line">    &lt;%&#125;%&gt;</span><br><span class="line">&lt;&#x2F;form&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;jsp的猜数游戏作业&quot;&gt;&lt;a href=&quot;#jsp的猜数游戏作业&quot; class=&quot;headerlink&quot; title=&quot;jsp的猜数游戏作业&quot;&gt;&lt;/a&gt;jsp的猜数游戏作业&lt;/h1&gt;&lt;h2 id=&quot;guess1-jsp&quot;&gt;&lt;a href=&quot;#guess1-jsp&quot;
      
    
    </summary>
    
    
      <category term="作业" scheme="https://todcsw.github.io/categories/%E4%BD%9C%E4%B8%9A/"/>
    
    
      <category term="作业" scheme="https://todcsw.github.io/tags/%E4%BD%9C%E4%B8%9A/"/>
    
  </entry>
  
  <entry>
    <title>java稀疏数组和普通数组的转换</title>
    <link href="https://todcsw.github.io/2020/04/10/java%E7%A8%80%E7%96%8F%E6%95%B0%E7%BB%84%E5%92%8C%E6%99%AE%E9%80%9A%E6%95%B0%E7%BB%84%E7%9A%84%E8%BD%AC%E6%8D%A2/"/>
    <id>https://todcsw.github.io/2020/04/10/java%E7%A8%80%E7%96%8F%E6%95%B0%E7%BB%84%E5%92%8C%E6%99%AE%E9%80%9A%E6%95%B0%E7%BB%84%E7%9A%84%E8%BD%AC%E6%8D%A2/</id>
    <published>2020-04-10T15:23:20.000Z</published>
    <updated>2020-04-16T05:50:19.070Z</updated>
    
    <content type="html"><![CDATA[<h1 id="java稀疏数组和普通数组的转换"><a href="#java稀疏数组和普通数组的转换" class="headerlink" title="java稀疏数组和普通数组的转换"></a>java稀疏数组和普通数组的转换</h1><h2 id="废话不多说-直接上代码"><a href="#废话不多说-直接上代码" class="headerlink" title="废话不多说,直接上代码"></a>废话不多说,直接上代码</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package com.csw.sparse;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * @Auther: 行路</span><br><span class="line"> * @Date: Created on 2020&#x2F;4&#x2F;2 16:47 星期四</span><br><span class="line"> * @Description: com.csw  稀疏数组和普通数组的转换</span><br><span class="line"> * @version: 1.0</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class Sparsearray &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        &#x2F;&#x2F;创建一个原始的二维数组 11*11</span><br><span class="line">        &#x2F;&#x2F;0:表示没有棋子,1表示黑子,2表示蓝子</span><br><span class="line">        int[][] chessArr&#x3D;new int[11][11];</span><br><span class="line"></span><br><span class="line">        chessArr[1][2]&#x3D;1;</span><br><span class="line">        chessArr[2][3]&#x3D;2;</span><br><span class="line">        chessArr[4][5]&#x3D;2;</span><br><span class="line">        &#x2F;&#x2F;输出原始的二维数组</span><br><span class="line">        System.out.println(&quot;原始的二维数组&quot;);</span><br><span class="line">        for(int [] row:chessArr)&#123;</span><br><span class="line">            for(int a:row)&#123;</span><br><span class="line">                System.out.printf(&quot;%d\t&quot;,a);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(&quot;&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;将二维数组转换为稀疏数组的思想</span><br><span class="line">        &#x2F;&#x2F;1.先遍历二维数组 得到非0数据的个数</span><br><span class="line">        int sum&#x3D;0;</span><br><span class="line">        for(int i&#x3D;0;i&lt;11;i++)&#123;</span><br><span class="line">            for(int j&#x3D;0;j&lt;11;j++)&#123;</span><br><span class="line">                if(chessArr[i][j]!&#x3D;0)&#123;</span><br><span class="line">                    sum++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot;sum&#x3D;&quot;+sum);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;创建一个稀疏数组</span><br><span class="line">        int[][] sparseArray&#x3D;new int[sum+1][3];</span><br><span class="line">        &#x2F;&#x2F;给稀疏数组赋值</span><br><span class="line">        sparseArray[0][0]&#x3D;11;</span><br><span class="line">        sparseArray[0][1]&#x3D;11;</span><br><span class="line">        sparseArray[0][2]&#x3D;sum;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;遍历二维数组 将非0数据存放到稀疏数组</span><br><span class="line">        int count&#x3D;0; &#x2F;&#x2F;用于记录时第几个非0数据</span><br><span class="line">        for(int i&#x3D;0;i&lt;11;i++)&#123;</span><br><span class="line">            for(int j&#x3D;0;j&lt;11;j++)&#123;</span><br><span class="line">                if(chessArr[i][j]!&#x3D;0)&#123;</span><br><span class="line">                    count++;</span><br><span class="line">                   sparseArray[count][0]&#x3D;i;</span><br><span class="line">                   sparseArray[count][1]&#x3D;j;</span><br><span class="line">                   sparseArray[count][2]&#x3D;chessArr[i][j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 输出稀疏数组的形式</span><br><span class="line">        System.out.println(&quot;稀疏数组----&quot;);</span><br><span class="line">        for(int [] row:sparseArray)&#123;</span><br><span class="line">            for(int a:row)&#123;</span><br><span class="line">                System.out.printf(&quot;%d\t&quot;,a);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(&quot;&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;将稀疏数组-》恢复为原来的数组</span><br><span class="line">        &#x2F;**</span><br><span class="line">         * 1.先读取稀疏数组的第一行,根据第一行的数据,创建原始的二维数组</span><br><span class="line">         * 2.在读取稀疏数组后几行数据,并赋给原始的二维数组即可</span><br><span class="line">         *</span><br><span class="line">         *&#x2F;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;1.先读取稀疏数组的第一行,根据第一行的数据,创建原始的二维数组</span><br><span class="line">        int[][] chessArr2&#x3D;new int[sparseArray[0][0]][sparseArray[0][1]];</span><br><span class="line">        &#x2F;&#x2F;2.在读取稀疏数组后几行数据,并赋给原始的二维数组即可</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;从第二行开始</span><br><span class="line">        for(int i&#x3D;1;i&lt;&#x3D;sparseArray[0][2];i++)&#123;</span><br><span class="line">                chessArr2[sparseArray[i][0]][sparseArray[i][1]]&#x3D;sparseArray[i][2];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;输出恢复后的数组</span><br><span class="line">        System.out.println(&quot;恢复后的数组----&quot;);</span><br><span class="line">        for(int [] row:chessArr2)&#123;</span><br><span class="line">            for(int a:row)&#123;</span><br><span class="line">                System.out.printf(&quot;%d\t&quot;,a);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(&quot;&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行效果<br><img src="/" class="lazyload" data-src="/images/array.png"  alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;java稀疏数组和普通数组的转换&quot;&gt;&lt;a href=&quot;#java稀疏数组和普通数组的转换&quot; class=&quot;headerlink&quot; title=&quot;java稀疏数组和普通数组的转换&quot;&gt;&lt;/a&gt;java稀疏数组和普通数组的转换&lt;/h1&gt;&lt;h2 id=&quot;废话不多说-直接上
      
    
    </summary>
    
    
      <category term="数据结构" scheme="https://todcsw.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="学习" scheme="https://todcsw.github.io/tags/%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="java" scheme="https://todcsw.github.io/tags/java/"/>
    
      <category term="数据结构" scheme="https://todcsw.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
</feed>
