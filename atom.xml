<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>圣文のblog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://todcsw.github.io/"/>
  <updated>2020-04-19T14:08:08.531Z</updated>
  <id>https://todcsw.github.io/</id>
  
  <author>
    <name>Todcsw</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>java实现冒泡排序和选择排序</title>
    <link href="https://todcsw.github.io/2020/04/19/java%E5%AE%9E%E7%8E%B0%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%E5%92%8C%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F/"/>
    <id>https://todcsw.github.io/2020/04/19/java%E5%AE%9E%E7%8E%B0%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%E5%92%8C%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F/</id>
    <published>2020-04-19T14:01:55.000Z</published>
    <updated>2020-04-19T14:08:08.531Z</updated>
    
    <content type="html"><![CDATA[<h1 id="java实现冒泡排序和选择排序"><a href="#java实现冒泡排序和选择排序" class="headerlink" title="java实现冒泡排序和选择排序"></a>java实现冒泡排序和选择排序</h1><h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package com.csw.sort;</span><br><span class="line"></span><br><span class="line">import java.text.SimpleDateFormat;</span><br><span class="line">import java.util.Arrays;</span><br><span class="line">import java.util.Date;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * @Auther: 行路</span><br><span class="line"> * @Date: Created on 2020&#x2F;4&#x2F;19 13:55 星期日</span><br><span class="line"> * @Description: com.csw.sort 冒泡排序 时间复杂度(n^2)</span><br><span class="line"> * @version: 1.0</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class BubbleSort &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int[] arr &#x3D; &#123;3, 9, -1, 10, 20&#125;;</span><br><span class="line">        sort1(arr);</span><br><span class="line">        sort2(arr);</span><br><span class="line">        testTime();&#x2F;&#x2F;80000个数据排序测试时间</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 冒泡排序</span><br><span class="line">     *</span><br><span class="line">     * @param arr</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public static void sort1(int arr[]) &#123;</span><br><span class="line">        System.out.println(&quot;初代冒泡排序--------&quot;);</span><br><span class="line">        int temp &#x3D; 0; &#x2F;&#x2F;临时变量</span><br><span class="line">        &#x2F;&#x2F;将最大的数排到最后</span><br><span class="line">        for (int i &#x3D; 0; i &lt; arr.length - 1; i++) &#123;</span><br><span class="line">            for (int j &#x3D; 0; j &lt; arr.length - i - 1; j++) &#123;</span><br><span class="line">                if (arr[j] &gt; arr[j + 1]) &#123;</span><br><span class="line">                    temp &#x3D; arr[j + 1];</span><br><span class="line">                    arr[j + 1] &#x3D; arr[j];</span><br><span class="line">                    arr[j] &#x3D; temp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F; System.out.println(&quot;第&quot;+(i+1)+&quot;趟排序&quot;);</span><br><span class="line">            &#x2F;&#x2F; System.out.println(Arrays.toString(arr));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 优化冒泡排序</span><br><span class="line">     *</span><br><span class="line">     * @param arr</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public static void sort2(int arr[]) &#123;</span><br><span class="line">        System.out.println(&quot;优化冒泡排序--------&quot;);</span><br><span class="line">        int temp &#x3D; 0; &#x2F;&#x2F;临时变量</span><br><span class="line">        boolean flag &#x3D; false;  &#x2F;&#x2F;表示变量,表示是否进行交换</span><br><span class="line">        &#x2F;&#x2F;将最大的数排到最后</span><br><span class="line">        for (int i &#x3D; 0; i &lt; arr.length - 1; i++) &#123;</span><br><span class="line"></span><br><span class="line">            for (int j &#x3D; 0; j &lt; arr.length - i - 1; j++) &#123;</span><br><span class="line">                if (arr[j] &gt; arr[j + 1]) &#123;</span><br><span class="line">                    flag &#x3D; true;</span><br><span class="line">                    temp &#x3D; arr[j + 1];</span><br><span class="line">                    arr[j + 1] &#x3D; arr[j];</span><br><span class="line">                    arr[j] &#x3D; temp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F;   System.out.println(&quot;第&quot;+(i+1)+&quot;趟排序&quot;);</span><br><span class="line">            &#x2F;&#x2F;  System.out.println(Arrays.toString(arr));</span><br><span class="line">            if (!flag) &#123; &#x2F;&#x2F;在一趟排序中,一次交换也没有发生过</span><br><span class="line">                break;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                flag &#x3D; false; &#x2F;&#x2F;重置false ,进行下次判断</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 80000个数据排序测试时间</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public static void testTime() &#123;</span><br><span class="line"></span><br><span class="line">        int[] arr &#x3D; new int[80000];</span><br><span class="line">        for (int i &#x3D; 0; i &lt; 80000; i++) &#123;</span><br><span class="line">            arr[i] &#x3D; (int) (Math.random() * 80000);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Date date1 &#x3D; new Date();</span><br><span class="line">        SimpleDateFormat simpleDateFormatter &#x3D; new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);</span><br><span class="line">        String date1Str &#x3D; simpleDateFormatter.format(date1);</span><br><span class="line">        System.out.println(&quot;排序前的时间是&#x3D;&quot; + date1Str);</span><br><span class="line"></span><br><span class="line">        sort1(arr);</span><br><span class="line"></span><br><span class="line">        Date date2 &#x3D; new Date();</span><br><span class="line">        &#x2F;&#x2F;   SimpleDateFormat simpleDateFormatter &#x3D; new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);</span><br><span class="line">        String date2Str &#x3D; simpleDateFormatter.format(date2);</span><br><span class="line">        System.out.println(&quot;排序后的时间是&#x3D;&quot; + date2Str);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package com.csw.sort;</span><br><span class="line"></span><br><span class="line">import java.text.SimpleDateFormat;</span><br><span class="line">import java.util.Arrays;</span><br><span class="line">import java.util.Date;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * @Auther: 行路</span><br><span class="line"> * @Date: Created on 2020&#x2F;4&#x2F;19 14:46 星期日</span><br><span class="line"> * @Description: com.csw.sort 选择排序</span><br><span class="line"> * @version: 1.0</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class SelectSort &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int[] arr &#x3D; &#123;101, 34, 119, 1&#125;;</span><br><span class="line">        selectSort(arr);</span><br><span class="line">        testTime(); &#x2F;&#x2F;80000个数据排序测试时间</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 使用逐步指导的方式来,讲解选择排序</span><br><span class="line">     * 第一轮</span><br><span class="line">     * 原始初始值 101,34,119,1</span><br><span class="line">     * 第一轮排序 :1,34,119,101</span><br><span class="line">     * 算法,先简单后复杂,就是可以把一个复杂的算法，拆分成简单的问题,逐步解决</span><br><span class="line">     * &lt;p&gt;</span><br><span class="line">     * 自己的理解：将每一次排序的第一个元素假定为最小值,定义俩变量一个记录值,一个记录下标用于交换</span><br><span class="line">     *</span><br><span class="line">     * @param arr</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public static void selectSort(int[] arr) &#123;</span><br><span class="line">        System.out.println(&quot;选择排序~~~~~&quot;);</span><br><span class="line">        &#x2F;&#x2F;在推导过程中</span><br><span class="line">        for (int i &#x3D; 0; i &lt; arr.length - 1; i++) &#123;</span><br><span class="line">            int minIndex &#x3D; i;</span><br><span class="line">            int min &#x3D; arr[minIndex];</span><br><span class="line">            for (int j &#x3D; i + 1; j &lt; arr.length; j++) &#123;</span><br><span class="line">                if (min &gt; arr[j]) &#123;</span><br><span class="line">                    min &#x3D; arr[j];</span><br><span class="line">                    minIndex &#x3D; j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F;当for循环结束时,将最小值放在arr[0]，即交换</span><br><span class="line">            if (minIndex !&#x3D; i) &#123;</span><br><span class="line">                arr[minIndex] &#x3D; arr[i];</span><br><span class="line">                arr[i] &#x3D; min;</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F; System.out.println(&quot;第&quot;+(i+1)+&quot;轮后~~&quot;);</span><br><span class="line">            &#x2F;&#x2F; System.out.println(Arrays.toString(arr));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void testTime() &#123;</span><br><span class="line">        int[] arr &#x3D; new int[80000];</span><br><span class="line">        for (int i &#x3D; 0; i &lt; 80000; i++) &#123;</span><br><span class="line">            arr[i] &#x3D; (int) (Math.random() * 80000);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Date date1 &#x3D; new Date();</span><br><span class="line">        SimpleDateFormat simpleDateFormatter &#x3D; new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);</span><br><span class="line">        String date1Str &#x3D; simpleDateFormatter.format(date1);</span><br><span class="line">        System.out.println(&quot;排序前的时间是&#x3D;&quot; + date1Str);</span><br><span class="line"></span><br><span class="line">        selectSort(arr);</span><br><span class="line"></span><br><span class="line">        Date date2 &#x3D; new Date();</span><br><span class="line">        &#x2F;&#x2F;   SimpleDateFormat simpleDateFormatter &#x3D; new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);</span><br><span class="line">        String date2Str &#x3D; simpleDateFormatter.format(date2);</span><br><span class="line">        System.out.println(&quot;排序后的时间是&#x3D;&quot; + date2Str);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;java实现冒泡排序和选择排序&quot;&gt;&lt;a href=&quot;#java实现冒泡排序和选择排序&quot; class=&quot;headerlink&quot; title=&quot;java实现冒泡排序和选择排序&quot;&gt;&lt;/a&gt;java实现冒泡排序和选择排序&lt;/h1&gt;&lt;h2 id=&quot;冒泡排序&quot;&gt;&lt;a href
      
    
    </summary>
    
    
      <category term="数据结构" scheme="https://todcsw.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="学习" scheme="https://todcsw.github.io/tags/%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="java" scheme="https://todcsw.github.io/tags/java/"/>
    
      <category term="数据结构" scheme="https://todcsw.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>java使用递归实现走出迷宫和八皇后问题</title>
    <link href="https://todcsw.github.io/2020/04/18/java%E4%BD%BF%E7%94%A8%E9%80%92%E5%BD%92%E5%AE%9E%E7%8E%B0%E8%B5%B0%E5%87%BA%E8%BF%B7%E5%AE%AB%E5%92%8C%E5%85%AB%E7%9A%87%E5%90%8E%E9%97%AE%E9%A2%98/"/>
    <id>https://todcsw.github.io/2020/04/18/java%E4%BD%BF%E7%94%A8%E9%80%92%E5%BD%92%E5%AE%9E%E7%8E%B0%E8%B5%B0%E5%87%BA%E8%BF%B7%E5%AE%AB%E5%92%8C%E5%85%AB%E7%9A%87%E5%90%8E%E9%97%AE%E9%A2%98/</id>
    <published>2020-04-18T04:51:05.000Z</published>
    <updated>2020-04-18T07:17:07.102Z</updated>
    
    <content type="html"><![CDATA[<h1 id="java使用递归实现走出迷宫"><a href="#java使用递归实现走出迷宫" class="headerlink" title="java使用递归实现走出迷宫"></a>java使用递归实现走出迷宫</h1><h2 id="废话不多说-直接上代码和运行结果"><a href="#废话不多说-直接上代码和运行结果" class="headerlink" title="废话不多说,直接上代码和运行结果"></a>废话不多说,直接上代码和运行结果</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package com.csw.recursion;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * @Auther: 行路</span><br><span class="line"> * @Date: Created on 2020&#x2F;4&#x2F;17 23:11 星期五</span><br><span class="line"> * @Description: com.csw.recursion 迷宫回溯问题</span><br><span class="line"> * @version: 1.0</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class MiGong &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        &#x2F;&#x2F;先创建一个二维数组,模拟迷宫</span><br><span class="line">        &#x2F;&#x2F;地图</span><br><span class="line">        int[][] map&#x3D;new int[8][7];</span><br><span class="line">        &#x2F;&#x2F;使用1表示强</span><br><span class="line">        &#x2F;&#x2F;上下全部置为1</span><br><span class="line">        for(int i&#x3D;0;i&lt;7;i++)&#123;</span><br><span class="line">            map[0][i]&#x3D;1;</span><br><span class="line">            map[7][i]&#x3D;1;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;左右全部置为1</span><br><span class="line">        for(int i&#x3D;0;i&lt;8;i++)&#123;</span><br><span class="line">            map[i][0]&#x3D;1;</span><br><span class="line">            map[i][6]&#x3D;1;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;设置挡板</span><br><span class="line">        map[3][1]&#x3D;1;</span><br><span class="line">        map[3][2]&#x3D;1;</span><br><span class="line">        &#x2F;&#x2F;map[1][2]&#x3D;1;</span><br><span class="line">        map[2][2]&#x3D;1;</span><br><span class="line">        &#x2F;&#x2F;输出地图</span><br><span class="line">        System.out.println(&quot;地图&quot;);</span><br><span class="line">        for(int i&#x3D;0;i&lt;8;i++)&#123;</span><br><span class="line">            for(int j&#x3D;0;j&lt;7;j++)&#123;</span><br><span class="line">                System.out.print(map[i][j]+&quot; &quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(&quot;&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;使用递归回溯来给小球找路</span><br><span class="line">        &#x2F;&#x2F;使用递归回溯</span><br><span class="line">        setWay(map,1,1);</span><br><span class="line">        &#x2F;&#x2F;输出新的地图</span><br><span class="line">        System.out.println(&quot;新的地图&quot;);</span><br><span class="line">        for(int i&#x3D;0;i&lt;8;i++)&#123;</span><br><span class="line">            for(int j&#x3D;0;j&lt;7;j++)&#123;</span><br><span class="line">                System.out.print(map[i][j]+&quot; &quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(&quot;&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 说明 map表示地图,i,j白澳式地图从那个位置开始触发(1,1)</span><br><span class="line">     * 如果小球能到map[6][5] 位置,则说明通路找到</span><br><span class="line">     * 约定:当map[i][j]&#x3D;0 表示没走过,当为1表示强 2为通路可以走,3表示已经走过</span><br><span class="line">     * 在走迷宫需要确定一个策略(方法)先走下-&gt;右-&gt;上-&gt;左,如果走不通就回溯</span><br><span class="line">     * @param map 表示地图</span><br><span class="line">     * @param i 从按个位置开始找</span><br><span class="line">     * @param j</span><br><span class="line">     * @return  如果找到通路,就返回true 否则返回false</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public static boolean setWay(int[][] map,int i,int j)&#123;</span><br><span class="line">        if(map[6][5]&#x3D;&#x3D;2)&#123;</span><br><span class="line">            &#x2F;&#x2F;通路已经找到</span><br><span class="line">            return true;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            if(map[i][j]&#x3D;&#x3D;0)&#123; &#x2F;&#x2F;如果当前这个点还没有走过</span><br><span class="line">                &#x2F;&#x2F;下-&gt;右-&gt;上-&gt;左 按照策略走</span><br><span class="line">                map[i][j]&#x3D;2; &#x2F;&#x2F;假定该点是可以走通的.</span><br><span class="line">                if(setWay(map,i+1,j))&#123;</span><br><span class="line">                    &#x2F;&#x2F;向下走,</span><br><span class="line">                    return true;</span><br><span class="line">                &#125;else if(setWay(map,i,j+1))&#123;</span><br><span class="line">                    &#x2F;&#x2F;向右走</span><br><span class="line">                    return true;</span><br><span class="line">                &#125;else if(setWay(map,i-1,j))&#123;</span><br><span class="line">                    &#x2F;&#x2F;向上走</span><br><span class="line">                    return true;</span><br><span class="line">                &#125;else if(setWay(map,i,j-1)) &#123;</span><br><span class="line">                    &#x2F;&#x2F;向左走</span><br><span class="line">                    return true;</span><br><span class="line">                &#125;else&#123;</span><br><span class="line">                    &#x2F;&#x2F;说明该点是走不通的</span><br><span class="line">                    map[i][j]&#x3D;3;</span><br><span class="line">                    return false;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                &#x2F;&#x2F;如果map[i][j]!&#x3D;0 可能是1，2，3</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h2><p><img src="/" class="lazyload" data-src="/images/%E8%BF%B7%E5%AE%AB.jpg"  alt=""></p><ul><li>0代表未走过的点</li><li>1代表迷宫的围墙</li><li>2代表走出迷宫的路线</li><li>3代表尝试走过,但走不通的点,进行回溯</li></ul><h1 id="java使用递归解决八皇后问题"><a href="#java使用递归解决八皇后问题" class="headerlink" title="java使用递归解决八皇后问题"></a>java使用递归解决八皇后问题</h1><h2 id="废话不多说-直接上代码"><a href="#废话不多说-直接上代码" class="headerlink" title="废话不多说,直接上代码"></a>废话不多说,直接上代码</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package com.csw.recursion;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * @Auther: 行路</span><br><span class="line"> * @Date: Created on 2020&#x2F;4&#x2F;18 13:31 星期六</span><br><span class="line"> * @Description: com.csw.recursion 八皇后问题</span><br><span class="line"> * @version: 1.0</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class Queen8 &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;定义一个max表示有多少皇后</span><br><span class="line">    int max&#x3D;8;</span><br><span class="line">    &#x2F;&#x2F;定义数组array 保存皇后放置的位置的结果</span><br><span class="line">    &#x2F;&#x2F;比如arr&#x3D;&#123;0,4,7,5,2,6,1,3&#125;</span><br><span class="line">    int[] array&#x3D;new int[max];</span><br><span class="line">    static int count&#x3D;0;</span><br><span class="line">    static int judgeCount&#x3D;0;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        &#x2F;&#x2F;测试8皇后是否正确</span><br><span class="line">        Queen8 queen8&#x3D;new Queen8();</span><br><span class="line">        queen8.check(0);</span><br><span class="line">        System.out.println(&quot;一共有&quot;+count+&quot;种解法&quot;);</span><br><span class="line">        System.out.println(&quot;共判断了多少次&quot;+judgeCount);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;编写一个方法,放置第n个皇后</span><br><span class="line">    &#x2F;&#x2F;特别注意：check是每一次递归,进入到check中都有for(int i&#x3D;0;i&lt;max;i++)因此会有回溯</span><br><span class="line">    private void check(int n)&#123;</span><br><span class="line">        if(n&#x3D;&#x3D;max)&#123; &#x2F;&#x2F;n&#x3D;8 ,其实8个皇后已然放好了</span><br><span class="line">            print();</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;依次放入皇后,并判断是否冲突</span><br><span class="line">        for (int i&#x3D;0;i&lt;max;i++)&#123;</span><br><span class="line">            &#x2F;&#x2F;先把当前这个皇后n,放到该行的1列</span><br><span class="line">            array[n]&#x3D;i;</span><br><span class="line">            &#x2F;&#x2F;判断当放置第n个皇后到i列时,是否冲突</span><br><span class="line">            if(judge(n))&#123;</span><br><span class="line">                &#x2F;&#x2F;不冲突</span><br><span class="line">                &#x2F;&#x2F;接着放n+1个皇后,即开始递归</span><br><span class="line">                check(n+1); &#x2F;&#x2F;</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F;如果冲突,就继续执行array[n]&#x3D;i;即将第n个皇后放置在本行的后移一个位置</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 查看当我们放置第n个皇后,就去检测该皇后是否和前面已经摆放的皇后冲突</span><br><span class="line">     * @param n 表示第n个皇后</span><br><span class="line">     * @return</span><br><span class="line">     *&#x2F;</span><br><span class="line">    private boolean judge(int n)&#123;</span><br><span class="line">        judgeCount++;</span><br><span class="line">        for(int i&#x3D;0;i&lt;n;i++)&#123;</span><br><span class="line">            &#x2F;&#x2F;1.array[i]&#x3D;&#x3D;array[n]表示判断第n个皇后是否和前面n-1个皇后在同一列</span><br><span class="line">            &#x2F;&#x2F;2.表示判断Math.abs(n-i)&#x3D;&#x3D;Math.abs(array[n]-array[i])第n个皇后和第i个皇后是否在同一斜线</span><br><span class="line">            &#x2F;&#x2F;n&#x3D;1 放在第二列 n&#x3D;1 array[1]&#x3D;1</span><br><span class="line">            &#x2F;&#x2F;Math.abs(1-0)&#x3D;&#x3D;1 Math.abs(1)</span><br><span class="line">            &#x2F;&#x2F;判断是否在同一行,没有必要,n每次都在递增</span><br><span class="line">            if(array[i]&#x3D;&#x3D;array[n]|| Math.abs(n-i)&#x3D;&#x3D;Math.abs(array[n]-array[i]))&#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     *写一个方法,可以将皇后摆放的位置打印出来</span><br><span class="line">     *&#x2F;</span><br><span class="line">    private void print()&#123;</span><br><span class="line">        count++;</span><br><span class="line">        for(int i&#x3D;0;i&lt;array.length;i++)&#123;</span><br><span class="line">            System.out.print(array[i]+&quot; &quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot;&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;java使用递归实现走出迷宫&quot;&gt;&lt;a href=&quot;#java使用递归实现走出迷宫&quot; class=&quot;headerlink&quot; title=&quot;java使用递归实现走出迷宫&quot;&gt;&lt;/a&gt;java使用递归实现走出迷宫&lt;/h1&gt;&lt;h2 id=&quot;废话不多说-直接上代码和运行结果&quot;
      
    
    </summary>
    
    
      <category term="数据结构" scheme="https://todcsw.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="学习" scheme="https://todcsw.github.io/tags/%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="java" scheme="https://todcsw.github.io/tags/java/"/>
    
      <category term="数据结构" scheme="https://todcsw.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>java实现中缀表达式转后缀表达式并使用栈计算逆波兰表达式</title>
    <link href="https://todcsw.github.io/2020/04/17/java%E5%AE%9E%E7%8E%B0%E4%B8%AD%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%BD%AC%E5%90%8E%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%B9%B6%E4%BD%BF%E7%94%A8%E6%A0%88%E8%AE%A1%E7%AE%97%E9%80%86%E6%B3%A2%E5%85%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    <id>https://todcsw.github.io/2020/04/17/java%E5%AE%9E%E7%8E%B0%E4%B8%AD%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%BD%AC%E5%90%8E%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%B9%B6%E4%BD%BF%E7%94%A8%E6%A0%88%E8%AE%A1%E7%AE%97%E9%80%86%E6%B3%A2%E5%85%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F/</id>
    <published>2020-04-17T14:10:01.000Z</published>
    <updated>2020-04-17T14:11:30.783Z</updated>
    
    <content type="html"><![CDATA[<h1 id="java实现中缀表达式转后缀表达式并使用栈计算逆波兰表达式"><a href="#java实现中缀表达式转后缀表达式并使用栈计算逆波兰表达式" class="headerlink" title="java实现中缀表达式转后缀表达式并使用栈计算逆波兰表达式"></a>java实现中缀表达式转后缀表达式并使用栈计算逆波兰表达式</h1><h2 id="废话不多说-直接上代码"><a href="#废话不多说-直接上代码" class="headerlink" title="废话不多说,直接上代码"></a>废话不多说,直接上代码</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package com.csw.stack;</span><br><span class="line"></span><br><span class="line">import javax.security.auth.Subject;</span><br><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.List;</span><br><span class="line">import java.util.Stack;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * @Auther: 行路</span><br><span class="line"> * @Date: Created on 2020&#x2F;4&#x2F;17 13:58 星期五</span><br><span class="line"> * @Description: com.csw.stack 中缀表达式转后缀表达式  再使用栈计算逆波兰表达式(后缀表达式)</span><br><span class="line"> * @version: 1.0</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class PolandNotation &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        &#x2F;&#x2F;完成将一个中缀表达式转成后缀表达式的功能</span><br><span class="line">        &#x2F;&#x2F;说明</span><br><span class="line">        &#x2F;&#x2F;1. 1+((2+3)*4)-5 &#x3D;&gt; 转成1 2 3 + 4 * + 5 -</span><br><span class="line">        &#x2F;&#x2F;2. 因为直接对str进行操作不方便,先将字符串装成对应的List;</span><br><span class="line">        &#x2F;&#x2F;即 ArrayList[1,+,(,]</span><br><span class="line">        &#x2F;&#x2F;3.得到的中缀表达式对应的List-&gt;后缀表达式对应的List</span><br><span class="line">        &#x2F;&#x2F;即ArrayList[12, +, (, (, 20, +, 3, ), *, 4, ), -, 5] &#x3D;&gt; ArrayList[1 ,2, 3, +, 4, *, +, 5 ,-]</span><br><span class="line">        String expression &#x3D; &quot;1+((2+3)*4)-5&quot;;</span><br><span class="line">        List&lt;String&gt; list &#x3D; toInfixExpressionList(expression);</span><br><span class="line">        System.out.println(&quot;中缀表达式:&quot;+list);</span><br><span class="line">        &#x2F;&#x2F;后缀表达式</span><br><span class="line">        List&lt;String&gt; list1 &#x3D; parseSuffixExpressionList(list);</span><br><span class="line">        System.out.println(&quot;后缀表达式:&quot;+list1);</span><br><span class="line">        System.out.printf(&quot;expressioon&#x3D;%d&quot;,calculate(list1));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;先定义一个逆波兰表达式</span><br><span class="line">        &#x2F;&#x2F;(3+4)*5-6 -&gt; 3 4 + 5 * 6 -</span><br><span class="line">        &#x2F;&#x2F;为了方便,数字和符号用空格隔开</span><br><span class="line">&#x2F;&#x2F;        String suffixExpression &#x3D; &quot;30 4 + 5 * 6 -&quot;;</span><br><span class="line">        &#x2F;&#x2F;思路</span><br><span class="line">        &#x2F;&#x2F;1.先将3 4 + 5 * 6 - 放到ArrayList中</span><br><span class="line">        &#x2F;&#x2F;2. 将ArrayList传递给一个方法,遍历arrayList配合栈,完成计算</span><br><span class="line">&#x2F;&#x2F;        List&lt;String&gt; rpnList &#x3D; getListString(suffixExpression);</span><br><span class="line">&#x2F;&#x2F;        System.out.println(rpnList);</span><br><span class="line">&#x2F;&#x2F;        int res &#x3D; calculate(rpnList);</span><br><span class="line">&#x2F;&#x2F;        System.out.println(&quot;计算结果:&quot; + res);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 将第一个逆波兰表达式,依次将数据和运算符放入到arrayList中</span><br><span class="line">     *</span><br><span class="line">     * @param suffixExpression</span><br><span class="line">     * @return</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public static List&lt;String&gt; getListString(String suffixExpression) &#123;</span><br><span class="line">        &#x2F;&#x2F;将suffixExpression分割</span><br><span class="line">        String[] split &#x3D; suffixExpression.split(&quot; &quot;);</span><br><span class="line">        List&lt;String&gt; list &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">        for (String ele : split) &#123;</span><br><span class="line">            list.add(ele);</span><br><span class="line">        &#125;</span><br><span class="line">        return list;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 将中缀表达式转成对应的List</span><br><span class="line">     * s&#x3D;&quot;1+((2+3)*4)-5&quot;</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public static List&lt;String&gt; toInfixExpressionList(String s) &#123;</span><br><span class="line">        &#x2F;&#x2F;定义一个List,存放中缀表达式对应的内容</span><br><span class="line">        List&lt;String&gt; ls &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">        int i &#x3D; 0; &#x2F;&#x2F;这时一个指针,用于遍历中缀表达式字符串</span><br><span class="line">        String str; &#x2F;&#x2F;对多位数的拼接</span><br><span class="line">        char c; &#x2F;&#x2F;每遍历到一个字符,就放入到c</span><br><span class="line">        do &#123;</span><br><span class="line">            &#x2F;&#x2F;如果c是一个非数字,我们就需要加入到ls中</span><br><span class="line"></span><br><span class="line">            if ((c &#x3D; s.charAt(i)) &lt; 48 || (c &#x3D; s.charAt(i)) &gt; 57) &#123;</span><br><span class="line">                ls.add(&quot;&quot; + c);</span><br><span class="line">                i++; &#x2F;&#x2F;i需要后移</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                &#x2F;&#x2F;如果是一个数,需要考虑多为数</span><br><span class="line">                str &#x3D; &quot;&quot;;&#x2F;&#x2F;先将str置成&quot;&quot;</span><br><span class="line">                while (i &lt; s.length() &amp;&amp; (c &#x3D; s.charAt(i)) &gt;&#x3D; 48 &amp;&amp; (c &#x3D; s.charAt(i)) &lt;&#x3D; 57) &#123;</span><br><span class="line">                    str +&#x3D; c;&#x2F;&#x2F;拼接</span><br><span class="line">                    i++;</span><br><span class="line">                &#125;</span><br><span class="line">                ls.add(str);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; while (i &lt; s.length());</span><br><span class="line">        return ls;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * &#x2F;&#x2F;即ArrayList[12, +, (, (, 20, +, 3, ), *, 4, ), -, 5] &#x3D;&gt; ArrayList[1 ,2, 3, +, 4, *, +, 5 ,-]</span><br><span class="line">     *</span><br><span class="line">     * @param ls</span><br><span class="line">     * @return</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public static List&lt;String&gt; parseSuffixExpressionList(List&lt;String&gt; ls) &#123;</span><br><span class="line">        &#x2F;&#x2F;定义两个栈</span><br><span class="line">        Stack&lt;String&gt; s1 &#x3D; new Stack&lt;String&gt;(); &#x2F;&#x2F;符号栈</span><br><span class="line">        &#x2F;&#x2F;说明s2这个栈,在整个转换过程中，没有pop操作,而且后面我们还需要逆序输出</span><br><span class="line">        &#x2F;&#x2F;因此我们直接使用List&lt;String&gt; s2</span><br><span class="line">        List&lt;String&gt; s2 &#x3D; new ArrayList&lt;&gt;();&#x2F;&#x2F;存储中间结果的list</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;遍历ls</span><br><span class="line">        for (String item : ls) &#123;</span><br><span class="line">            &#x2F;&#x2F;如果是一个数,加入到s2</span><br><span class="line">            if (item.matches(&quot;\\d+&quot;)) &#123;</span><br><span class="line">                s2.add(item);</span><br><span class="line">            &#125; else if (item.equals(&quot;(&quot;)) &#123;</span><br><span class="line">                s1.push(item);</span><br><span class="line">            &#125; else if (item.equals(&quot;)&quot;)) &#123;</span><br><span class="line">                &#x2F;&#x2F;如果是右括号“）”,则依次弹出s1栈顶的运算符,并压入s2，直到遇到左括号位置,此时将一对括号丢弃</span><br><span class="line">                while (!s1.peek().equals(&quot;(&quot;)) &#123;</span><br><span class="line">                    s2.add(s1.pop());</span><br><span class="line">                &#125;</span><br><span class="line">                s1.pop();&#x2F;&#x2F;将“（”弹出s1这个栈</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                &#x2F;&#x2F;当item的优先级小于等于s1栈顶运算符，将s1栈顶的运算符弹出并加入到s2中,再次转到4,1与s1中新的栈顶运算符比较</span><br><span class="line">                &#x2F;&#x2F;问题:缺少一个比较优先级高低的方法</span><br><span class="line">                while (s1.size() !&#x3D; 0 &amp;&amp; Operation.getValue(s1.peek())&gt;&#x3D;Operation.getValue(item))&#123;</span><br><span class="line">                    s2.add(s1.pop());</span><br><span class="line">                &#125;</span><br><span class="line">                &#x2F;&#x2F;还需要将item压入栈中</span><br><span class="line">                s1.push(item);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;将s1中剩余的运算符依次弹出并加入到s2</span><br><span class="line">        while (s1.size()!&#x3D;0)&#123;</span><br><span class="line">            s2.add(s1.pop());</span><br><span class="line">        &#125;</span><br><span class="line">        return s2; &#x2F;&#x2F;因为存放到list，因此按照顺序输出就是顺序的</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 3 4 + 5 * 6 -</span><br><span class="line">     * 完成对逆波兰表达式的运算</span><br><span class="line">     * 1.从左至右扫描,将3和4压入堆栈中</span><br><span class="line">     * 2.遇到+运算符,因此弹出4和3(4为栈顶元素,3为次顶元素,)计算出3+4的值,得7再将7入栈;</span><br><span class="line">     * 3.将5入栈</span><br><span class="line">     * 4.接下来是x运算,因此弹出5和7计算5*7&#x3D;35,将35入栈,将6入栈</span><br><span class="line">     * 最后是-运算符,计算出35-6的值,即29由此得出结果</span><br><span class="line">     *</span><br><span class="line">     * @param ls</span><br><span class="line">     * @return</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public static int calculate(List&lt;String&gt; ls) &#123;</span><br><span class="line">        &#x2F;&#x2F;创建一个栈,只需要一个栈</span><br><span class="line">        Stack&lt;String&gt; stack &#x3D; new Stack&lt;&gt;();</span><br><span class="line">        &#x2F;&#x2F;遍历ls</span><br><span class="line">        for (String item : ls) &#123;</span><br><span class="line">            &#x2F;&#x2F;使用正则表达式来取出数</span><br><span class="line">            if (item.matches(&quot;\\d+&quot;)) &#123;</span><br><span class="line">                &#x2F;&#x2F;匹配的是多位数</span><br><span class="line">                stack.push(item);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                &#x2F;&#x2F;pop出两个数,并运算,再入栈</span><br><span class="line">                int num2 &#x3D; Integer.parseInt(stack.pop());</span><br><span class="line">                int num1 &#x3D; Integer.parseInt(stack.pop());</span><br><span class="line">                int res &#x3D; 0;</span><br><span class="line">                if (item.equals(&quot;+&quot;)) &#123;</span><br><span class="line">                    res &#x3D; num1 + num2;</span><br><span class="line">                &#125; else if (item.equals(&quot;-&quot;)) &#123;</span><br><span class="line">                    res &#x3D; num1 - num2;</span><br><span class="line">                &#125; else if (item.equals(&quot;*&quot;)) &#123;</span><br><span class="line">                    res &#x3D; num1 * num2;</span><br><span class="line">                &#125; else if (item.equals(&quot;&#x2F;&quot;)) &#123;</span><br><span class="line">                    res &#x3D; num1 &#x2F; num2;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    throw new RuntimeException(&quot;运算符有误&quot;);</span><br><span class="line">                &#125;</span><br><span class="line">                &#x2F;&#x2F;把res入栈</span><br><span class="line">                stack.push(res + &quot;&quot;);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;最后留在stack中的数据就是运算结果</span><br><span class="line">        return Integer.parseInt(stack.pop());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * Description:编写一个类Operation可以返回一个运算符对应的优先级</span><br><span class="line"> *</span><br><span class="line"> * @author Todcsw</span><br><span class="line"> * @date</span><br><span class="line"> *&#x2F;</span><br><span class="line">class Operation &#123;</span><br><span class="line">    private static int ADD &#x3D; 1;</span><br><span class="line">    private static int SUB &#x3D; 1;</span><br><span class="line">    private static int MUL &#x3D; 2;</span><br><span class="line">    private static int DIV &#x3D; 2;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;写一个方法,返回对应的优先级数字</span><br><span class="line">    public static int getValue(String operation) &#123;</span><br><span class="line">        int result &#x3D; 0;</span><br><span class="line">        switch (operation) &#123;</span><br><span class="line">            case &quot;+&quot;:</span><br><span class="line">                result &#x3D;ADD;</span><br><span class="line">            break;</span><br><span class="line">            case &quot;-&quot;:</span><br><span class="line">                result &#x3D; SUB;</span><br><span class="line">                break;</span><br><span class="line">            case &quot;*&quot;:</span><br><span class="line">                result &#x3D;MUL;</span><br><span class="line">                break;</span><br><span class="line">            case &quot;&#x2F;&quot;:</span><br><span class="line">                result &#x3D;DIV;</span><br><span class="line">                break;</span><br><span class="line">            default:</span><br><span class="line">                &#x2F;&#x2F;result&#x3D;0;</span><br><span class="line">                &#x2F;&#x2F;System.out.println(&quot;不存在该运算符&quot;);</span><br><span class="line">                break;</span><br><span class="line">        &#125;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;java实现中缀表达式转后缀表达式并使用栈计算逆波兰表达式&quot;&gt;&lt;a href=&quot;#java实现中缀表达式转后缀表达式并使用栈计算逆波兰表达式&quot; class=&quot;headerlink&quot; title=&quot;java实现中缀表达式转后缀表达式并使用栈计算逆波兰表达式&quot;&gt;&lt;/a
      
    
    </summary>
    
    
      <category term="数据结构" scheme="https://todcsw.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="学习" scheme="https://todcsw.github.io/tags/%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="java" scheme="https://todcsw.github.io/tags/java/"/>
    
      <category term="数据结构" scheme="https://todcsw.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>java实现栈</title>
    <link href="https://todcsw.github.io/2020/04/16/java%E5%AE%9E%E7%8E%B0%E6%A0%88/"/>
    <id>https://todcsw.github.io/2020/04/16/java%E5%AE%9E%E7%8E%B0%E6%A0%88/</id>
    <published>2020-04-16T05:47:25.000Z</published>
    <updated>2020-04-16T05:49:37.319Z</updated>
    
    <content type="html"><![CDATA[<h1 id="java实现栈"><a href="#java实现栈" class="headerlink" title="java实现栈"></a>java实现栈</h1><h2 id="废话不多说-直接上代码"><a href="#废话不多说-直接上代码" class="headerlink" title="废话不多说,直接上代码"></a>废话不多说,直接上代码</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package com.csw.stack;</span><br><span class="line"></span><br><span class="line">import java.util.Scanner;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * @Auther: 行路</span><br><span class="line"> * @Date: Created on 2020&#x2F;4&#x2F;15 13:36 星期三</span><br><span class="line"> * @Description: com.csw.stack</span><br><span class="line"> * @version: 1.0</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class ArrayStackDemo &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        &#x2F;&#x2F;测试以下ArrayStack是否正确</span><br><span class="line">        &#x2F;&#x2F;先创建一个ArrayStack对象-&gt;表示栈</span><br><span class="line">        ArrayStack stack&#x3D;new ArrayStack(4);</span><br><span class="line">        String key&#x3D;&quot;&quot;;</span><br><span class="line">        boolean loop&#x3D;true;&#x2F;&#x2F;控制是否退出菜单</span><br><span class="line">        Scanner scanner&#x3D;new Scanner(System.in);</span><br><span class="line"></span><br><span class="line">        while (loop)&#123;</span><br><span class="line">            System.out.println(&quot;show :表示显示栈&quot;);</span><br><span class="line">            System.out.println(&quot;exit :退出程序&quot;);</span><br><span class="line">            System.out.println(&quot;push :表示添加数据到栈&quot;);</span><br><span class="line">            System.out.println(&quot;pop :表示从栈取出数据(出栈)&quot;);</span><br><span class="line">            System.out.println(&quot;请输入你的选择:&quot;);</span><br><span class="line">            key&#x3D;scanner.next();</span><br><span class="line">            switch (key)&#123;</span><br><span class="line">                case &quot;show&quot;:</span><br><span class="line">                    stack.list();</span><br><span class="line">                    break;</span><br><span class="line">                case &quot;push&quot;:</span><br><span class="line">                    System.out.println(&quot;请输入一个数&quot;);</span><br><span class="line">                    int value&#x3D;scanner.nextInt();</span><br><span class="line">                    stack.push(value);</span><br><span class="line">                    break;</span><br><span class="line">                case &quot;pop&quot;:</span><br><span class="line">                    try &#123;</span><br><span class="line">                        int res&#x3D;stack.pop();</span><br><span class="line">                        System.out.println(res);</span><br><span class="line">                    &#125;catch (Exception e)&#123;</span><br><span class="line">                        System.out.println(e.getMessage());</span><br><span class="line">                    &#125;</span><br><span class="line">                    break;</span><br><span class="line">                case &quot;exit&quot;:</span><br><span class="line">                    scanner.close();</span><br><span class="line">                    loop&#x3D;false;</span><br><span class="line">                    break;</span><br><span class="line">                default:</span><br><span class="line">                    break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot;程序退出&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;定义一个ArrayStacke 栈</span><br><span class="line">class ArrayStack&#123;</span><br><span class="line">    private int maxSize;</span><br><span class="line">    private int[] stack; &#x2F;&#x2F;数组模拟栈,数据放在该数组中</span><br><span class="line">    private int top&#x3D;-1; &#x2F;&#x2F;表示栈顶,初始化为-1</span><br><span class="line"></span><br><span class="line">    public ArrayStack(int maxSize) &#123;</span><br><span class="line">        this.maxSize &#x3D; maxSize;</span><br><span class="line">        stack&#x3D;new int[this.maxSize];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 栈满</span><br><span class="line">     * @return</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public boolean isFull()&#123;</span><br><span class="line">        return top&#x3D;&#x3D;maxSize-1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 栈空</span><br><span class="line">     * @return</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public boolean isEmpty()&#123;</span><br><span class="line">        return top&#x3D;&#x3D;-1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 入栈</span><br><span class="line">     * @param value</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public void push(int value)&#123;</span><br><span class="line">        &#x2F;&#x2F;先判断栈是否满</span><br><span class="line">        if(isFull())&#123;</span><br><span class="line">            System.out.println(&quot;栈满&quot;);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        top++;</span><br><span class="line">        stack[top]&#x3D;value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 出栈,将栈顶的数据返回</span><br><span class="line">     * @return</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public int pop()&#123;</span><br><span class="line">        &#x2F;&#x2F;先判断栈是否空</span><br><span class="line">        if(isEmpty())&#123;</span><br><span class="line">            throw new RuntimeException(&quot;栈空,没有数据&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        int value&#x3D;stack[top];</span><br><span class="line">        top--;</span><br><span class="line">        return value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 遍历从栈顶遍历数据</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public void list()&#123;</span><br><span class="line">        if(isEmpty())&#123;</span><br><span class="line">            System.out.println(&quot;栈空,没有数据&quot;);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i&#x3D;top;i&gt;&#x3D;0;i--)&#123;</span><br><span class="line">            System.out.printf(&quot;stack[%d]&#x3D;%d\n&quot;,i,stack[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="java用栈实现计算器"><a href="#java用栈实现计算器" class="headerlink" title="java用栈实现计算器"></a>java用栈实现计算器</h1><h2 id="废话不多说-直接上代码-1"><a href="#废话不多说-直接上代码-1" class="headerlink" title="废话不多说,直接上代码"></a>废话不多说,直接上代码</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package com.csw.stack;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * @Auther: 行路</span><br><span class="line"> * @Date: Created on 2020&#x2F;4&#x2F;15 20:25 星期三</span><br><span class="line"> * @Description: com.csw.stack</span><br><span class="line"> * @version: 1.0</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class Calculator &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        &#x2F;&#x2F;根据思路</span><br><span class="line">        String expression &#x3D; &quot;70+40*4-2&quot;;</span><br><span class="line">        &#x2F;&#x2F;先创建两个栈,数栈和符号栈</span><br><span class="line">        ArrayStack2 numStack &#x3D; new ArrayStack2(10);</span><br><span class="line">        ArrayStack2 operStack &#x3D; new ArrayStack2(10);</span><br><span class="line">        &#x2F;&#x2F;定义需要扫描的相关变量</span><br><span class="line">        int index &#x3D; 0;&#x2F;&#x2F;用于扫描</span><br><span class="line">        int num1 &#x3D; 0;</span><br><span class="line">        int num2 &#x3D; 0;</span><br><span class="line">        int oper &#x3D; 0;</span><br><span class="line">        int res &#x3D; 0;</span><br><span class="line">        char ch &#x3D; &#39; &#39;; &#x2F;&#x2F;将没次扫描得到的char保存到ch</span><br><span class="line">        String keepNum &#x3D; &quot;&quot;;</span><br><span class="line">        &#x2F;&#x2F;开始while循环的扫描expression</span><br><span class="line">        while (true) &#123;</span><br><span class="line">            &#x2F;&#x2F;一次得到experession的每一个字符</span><br><span class="line">            ch &#x3D; expression.substring(index, index + 1).charAt(0);</span><br><span class="line">            &#x2F;&#x2F;判断ch是什么做响应的处理</span><br><span class="line">            if (operStack.isOper(ch)) &#123; &#x2F;&#x2F;如果是运算符</span><br><span class="line">                &#x2F;&#x2F;判断当前的符号栈是否为空</span><br><span class="line">                if (!operStack.isEmpty()) &#123;</span><br><span class="line">                    &#x2F;&#x2F;如果符号栈有操作符,就进行比较,如果当前的操作符优先级,小于火等于栈中的操作符,就需要从数栈</span><br><span class="line">                    &#x2F;&#x2F;中pop出两个数,再从符号栈中pop出一个符号,进行运算,将得到结果,入数栈后,然后将当前的操作符入符号栈</span><br><span class="line">                    if (operStack.priority(ch) &lt;&#x3D; operStack.priority(operStack.peek())) &#123;</span><br><span class="line">                        &#x2F;&#x2F;从数栈中pop出两个数</span><br><span class="line">                        num1 &#x3D; numStack.pop();</span><br><span class="line">                        num2 &#x3D; numStack.pop();</span><br><span class="line">                        oper &#x3D; operStack.pop();</span><br><span class="line">                        res &#x3D; numStack.cal(num1, num2, oper);</span><br><span class="line">                        &#x2F;&#x2F;把运算的结果入数栈</span><br><span class="line">                        numStack.push(res);</span><br><span class="line">                        &#x2F;&#x2F;然后把当前的操作符入符号栈</span><br><span class="line">                        operStack.push(ch);</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        &#x2F;&#x2F;如果当前的操作符优先级大于,直接入符号栈</span><br><span class="line">                        operStack.push(ch);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    &#x2F;&#x2F;如果为空,直接入符号栈</span><br><span class="line">                    operStack.push(ch);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                &#x2F;&#x2F;如果是数就直接用数栈</span><br><span class="line">                &#x2F;&#x2F; numStack.push(ch-48);&#x2F;&#x2F;? &quot;1+3&quot;</span><br><span class="line">                &#x2F;&#x2F;1.当处理多位数时,不能发现一个数就立即入栈,因为可能是多位数</span><br><span class="line">                &#x2F;&#x2F;2.在处理数,需要想expression的表达式index后再看一位,如果是数</span><br><span class="line">                &#x2F;&#x2F;3.因此需要定义字符串变量,用于拼接</span><br><span class="line">                &#x2F;&#x2F;处理多位数</span><br><span class="line">                keepNum +&#x3D; ch;</span><br><span class="line">                &#x2F;&#x2F;如果ch已经是expression的最后以位,就直接入栈</span><br><span class="line">                if (index &#x3D;&#x3D; expression.length() - 1) &#123;</span><br><span class="line">                    numStack.push(Integer.valueOf(keepNum));</span><br><span class="line">                &#125; else &#123;</span><br><span class="line"></span><br><span class="line">                    &#x2F;&#x2F;判断下一个字符是不是数字,如果是数字,则进行继续扫描，如果是运算符则入栈</span><br><span class="line">                    &#x2F;&#x2F;注意是看后面一位,不是index++</span><br><span class="line">                    &#x2F;&#x2F;如果后一位是操作符,则入栈</span><br><span class="line">                    if (operStack.isOper(expression.substring(index + 1, index + 2).charAt(0))) &#123;</span><br><span class="line">                        numStack.push(Integer.valueOf(keepNum));</span><br><span class="line">                        &#x2F;&#x2F;重要！！！keepNum清空</span><br><span class="line">                        keepNum &#x3D; &quot;&quot;;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F;让Index+1,并判断是否扫描到expression的最后</span><br><span class="line">            index++;</span><br><span class="line">            if (index &gt;&#x3D; expression.length()) &#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;当表达式扫描完毕,就顺序的从数栈和符号栈中pop出相应的符号,并允许</span><br><span class="line">        while (true) &#123;</span><br><span class="line">            &#x2F;&#x2F;如果符号栈为空,则计算到最后的结果,数栈中只有一个数字</span><br><span class="line">            if (operStack.isEmpty()) &#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            num1 &#x3D; numStack.pop();</span><br><span class="line">            num2 &#x3D; numStack.pop();</span><br><span class="line">            oper &#x3D; operStack.pop();</span><br><span class="line">            res &#x3D; numStack.cal(num1, num2, oper);</span><br><span class="line">            numStack.push(res); &#x2F;&#x2F;入栈</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;将数栈中最后数pop出,就是结果</span><br><span class="line">        int res2 &#x3D; numStack.pop();</span><br><span class="line">        System.out.printf(&quot;表达式%s&#x3D;%d&quot;, expression, res2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * Description:创建的一个栈</span><br><span class="line"> * 需要扩展功能</span><br><span class="line"> *</span><br><span class="line"> * @author Todcsw</span><br><span class="line"> * @date</span><br><span class="line"> *&#x2F;</span><br><span class="line">class ArrayStack2 &#123;</span><br><span class="line">    private int maxSize;</span><br><span class="line">    private int[] stack; &#x2F;&#x2F;数组模拟栈,数据放在该数组中</span><br><span class="line">    private int top &#x3D; -1; &#x2F;&#x2F;表示栈顶,初始化为-1</span><br><span class="line"></span><br><span class="line">    public ArrayStack2(int maxSize) &#123;</span><br><span class="line">        this.maxSize &#x3D; maxSize;</span><br><span class="line">        stack &#x3D; new int[this.maxSize];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;返回当前栈顶的值,但是不pop出来</span><br><span class="line">    public int peek() &#123;</span><br><span class="line">        return stack[top];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 栈满</span><br><span class="line">     *</span><br><span class="line">     * @return</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public boolean isFull() &#123;</span><br><span class="line">        return top &#x3D;&#x3D; maxSize - 1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 栈空</span><br><span class="line">     *</span><br><span class="line">     * @return</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public boolean isEmpty() &#123;</span><br><span class="line">        return top &#x3D;&#x3D; -1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 入栈</span><br><span class="line">     *</span><br><span class="line">     * @param value</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public void push(int value) &#123;</span><br><span class="line">        &#x2F;&#x2F;先判断栈是否满</span><br><span class="line">        if (isFull()) &#123;</span><br><span class="line">            System.out.println(&quot;栈满&quot;);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        top++;</span><br><span class="line">        stack[top] &#x3D; value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 出栈,将栈顶的数据返回</span><br><span class="line">     *</span><br><span class="line">     * @return</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public int pop() &#123;</span><br><span class="line">        &#x2F;&#x2F;先判断栈是否空</span><br><span class="line">        if (isEmpty()) &#123;</span><br><span class="line">            throw new RuntimeException(&quot;栈空,没有数据&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        int value &#x3D; stack[top];</span><br><span class="line">        top--;</span><br><span class="line">        return value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 遍历从栈顶遍历数据</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public void list() &#123;</span><br><span class="line">        if (isEmpty()) &#123;</span><br><span class="line">            System.out.println(&quot;栈空,没有数据&quot;);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i &#x3D; top; i &gt;&#x3D; 0; i--) &#123;</span><br><span class="line">            System.out.printf(&quot;stack[%d]&#x3D;%d\n&quot;, i, stack[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 返回运算符的优先级,假定数字越大,优先级就越高</span><br><span class="line">     *</span><br><span class="line">     * @param oper</span><br><span class="line">     * @return</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public int priority(int oper) &#123;</span><br><span class="line">        if (oper &#x3D;&#x3D; &#39;*&#39; || oper &#x3D;&#x3D; &#39;&#x2F;&#39;) &#123;</span><br><span class="line">            return 1;</span><br><span class="line">        &#125; else if (oper &#x3D;&#x3D; &#39;+&#39; || oper &#x3D;&#x3D; &#39;-&#39;) &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return -1; &#x2F;&#x2F;假设目前的表达式只有+,-,*,&#x2F;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 判断是不是运算符</span><br><span class="line">     *</span><br><span class="line">     * @param val</span><br><span class="line">     * @return</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public boolean isOper(char val) &#123;</span><br><span class="line">        return val &#x3D;&#x3D; &#39;+&#39; || val &#x3D;&#x3D; &#39;-&#39; || val &#x3D;&#x3D; &#39;*&#39; || val &#x3D;&#x3D; &#39;&#x2F;&#39;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 计算的方法</span><br><span class="line">     *</span><br><span class="line">     * @param num1</span><br><span class="line">     * @param num2</span><br><span class="line">     * @param oper</span><br><span class="line">     * @return</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public int cal(int num1, int num2, int oper) &#123;</span><br><span class="line">        int res &#x3D; 0;&#x2F;&#x2F;res用于存放计算的结果</span><br><span class="line">        switch (oper) &#123;</span><br><span class="line">            case &#39;+&#39;:</span><br><span class="line">                res &#x3D; num1 + num2;</span><br><span class="line">                break;</span><br><span class="line">            case &#39;-&#39;:</span><br><span class="line">                res &#x3D; num2 - num1; &#x2F;&#x2F;注意顺序</span><br><span class="line">                break;</span><br><span class="line">            case &#39;*&#39;:</span><br><span class="line">                res &#x3D; num1 * num2;</span><br><span class="line">                break;</span><br><span class="line">            case &#39;&#x2F;&#39;:</span><br><span class="line">                res &#x3D; num2 &#x2F; num1;</span><br><span class="line">                break;</span><br><span class="line">            default:</span><br><span class="line">                break;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;java实现栈&quot;&gt;&lt;a href=&quot;#java实现栈&quot; class=&quot;headerlink&quot; title=&quot;java实现栈&quot;&gt;&lt;/a&gt;java实现栈&lt;/h1&gt;&lt;h2 id=&quot;废话不多说-直接上代码&quot;&gt;&lt;a href=&quot;#废话不多说-直接上代码&quot; class=&quot;he
      
    
    </summary>
    
    
      <category term="数据结构" scheme="https://todcsw.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="学习" scheme="https://todcsw.github.io/tags/%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="java" scheme="https://todcsw.github.io/tags/java/"/>
    
      <category term="数据结构" scheme="https://todcsw.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>java实现双向链表</title>
    <link href="https://todcsw.github.io/2020/04/15/java%E5%AE%9E%E7%8E%B0%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8/"/>
    <id>https://todcsw.github.io/2020/04/15/java%E5%AE%9E%E7%8E%B0%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8/</id>
    <published>2020-04-15T06:08:44.000Z</published>
    <updated>2020-04-15T06:12:59.264Z</updated>
    
    <content type="html"><![CDATA[<h1 id="java实现双向链表"><a href="#java实现双向链表" class="headerlink" title="java实现双向链表"></a>java实现双向链表</h1><h2 id="废话不多说-直接上代码"><a href="#废话不多说-直接上代码" class="headerlink" title="废话不多说,直接上代码"></a>废话不多说,直接上代码</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package com.csw.LinkedList;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * @Auther: 行路</span><br><span class="line"> * @Date: Created on 2020&#x2F;4&#x2F;15 13:11 星期三</span><br><span class="line"> * @Description: com.csw.LinkedList</span><br><span class="line"> * @version: 1.0</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class DoubleLinkedListDemo &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        System.out.println(&quot;双向链表的测试&quot;);</span><br><span class="line">        &#x2F;&#x2F;创建节点</span><br><span class="line">        HeroNode2 hero1 &#x3D; new HeroNode2(1, &quot;松江&quot;, &quot;及时雨&quot;);</span><br><span class="line">        HeroNode2 hero2 &#x3D; new HeroNode2(2, &quot;卢&quot;, &quot;玉&quot;);</span><br><span class="line">        HeroNode2 hero3 &#x3D; new HeroNode2(3, &quot;无用&quot;, &quot;智多星&quot;);</span><br><span class="line">        HeroNode2 hero4 &#x3D; new HeroNode2(4, &quot;林冲&quot;, &quot;豹子头&quot;);</span><br><span class="line">        &#x2F;&#x2F;创建一个双向链表</span><br><span class="line">        DoubleLinkedList linkedList&#x3D;new DoubleLinkedList();</span><br><span class="line">        &#x2F;&#x2F;添加</span><br><span class="line">        linkedList.add(hero1);</span><br><span class="line">        linkedList.add(hero2);</span><br><span class="line">        linkedList.add(hero3);</span><br><span class="line">        linkedList.add(hero4);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;显示</span><br><span class="line">        linkedList.list();</span><br><span class="line">        &#x2F;&#x2F;修改</span><br><span class="line">        HeroNode2 node2&#x3D;new HeroNode2(4,&quot;公孙胜&quot;,&quot;入云龙&quot;);</span><br><span class="line">        linkedList.update(node2);</span><br><span class="line">        &#x2F;&#x2F;显示</span><br><span class="line">        System.out.println(&quot;修改后的链表&quot;);</span><br><span class="line">        linkedList.list();</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;删除</span><br><span class="line">        linkedList.del(3);</span><br><span class="line">        System.out.println(&quot;删除后的链表&quot;);</span><br><span class="line">        linkedList.list();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;创建一个双向链表的类</span><br><span class="line">class DoubleLinkedList &#123;</span><br><span class="line">    &#x2F;&#x2F;初始化一个头节点,头节点不动,不存放具体的数据</span><br><span class="line">    private HeroNode2 head &#x3D; new HeroNode2(0, &quot;&quot;, &quot;&quot;);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;返回头节点</span><br><span class="line">    public HeroNode2 getHead() &#123;</span><br><span class="line">        return head;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 遍历双向链表的方法</span><br><span class="line">     * 显示链表[遍历]</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public void list() &#123;</span><br><span class="line">        &#x2F;&#x2F;判断链表是否为空</span><br><span class="line">        if (head.next &#x3D;&#x3D; null) &#123;</span><br><span class="line">            System.out.println(&quot;链表为空&quot;);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;因为头节点,不能动,因次需要一个辅助变量来遍历</span><br><span class="line">        HeroNode2 temp &#x3D; head.next;</span><br><span class="line">        while (true) &#123;</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F;判断链表是否到最后</span><br><span class="line">            if (temp &#x3D;&#x3D; null) &#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F;输出节点的信息</span><br><span class="line">            System.out.println(temp.toString());</span><br><span class="line">            &#x2F;&#x2F;将temp后移</span><br><span class="line">            temp &#x3D; temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 添加一个节点到双向链表的最后</span><br><span class="line">     *</span><br><span class="line">     * @param heroNode</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public void add(HeroNode2 heroNode) &#123;</span><br><span class="line">        &#x2F;&#x2F;因为head节点不能动,因此我们需要一个辅助遍历temp</span><br><span class="line">        HeroNode2 temp &#x3D; head;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;遍历链表,找到最后</span><br><span class="line">        while (true) &#123;</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F;找到链表的最后</span><br><span class="line">            if (temp.next &#x3D;&#x3D; null) &#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F;如果没有找到最后,就将temp后移</span><br><span class="line">            temp &#x3D; temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;当退出while循环时,temp就指向了链表的最后</span><br><span class="line">        &#x2F;&#x2F;形成一个双向链表</span><br><span class="line">        temp.next &#x3D; heroNode;</span><br><span class="line">        heroNode.pre &#x3D; temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 修改一个节点的内容,可以看到几乎和单链表一样</span><br><span class="line">     * 节点的类型</span><br><span class="line">     *</span><br><span class="line">     * @param newHeroNode</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public void update(HeroNode2 newHeroNode) &#123;</span><br><span class="line">        &#x2F;&#x2F;判断是否为空</span><br><span class="line">        if (head.next &#x3D;&#x3D; null) &#123;</span><br><span class="line">            System.out.println(&quot;链表为空&quot;);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;找到需要修改的链表,根据no编号</span><br><span class="line">        &#x2F;&#x2F;定义一个辅助变量</span><br><span class="line">        HeroNode2 temp &#x3D; head.next;</span><br><span class="line">        boolean flag &#x3D; false; &#x2F;&#x2F;表示是否找到改节点</span><br><span class="line">        while (true) &#123;</span><br><span class="line">            if (temp &#x3D;&#x3D; null) &#123;</span><br><span class="line">                break;&#x2F;&#x2F;到链表的最后的下一个(表示链表已经遍历完)</span><br><span class="line">            &#125;</span><br><span class="line">            if (temp.no &#x3D;&#x3D; newHeroNode.no) &#123;</span><br><span class="line">                &#x2F;&#x2F;找到了</span><br><span class="line">                flag &#x3D; true;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            temp &#x3D; temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;根据flag判断是否找到要修改的节点</span><br><span class="line">        if (flag) &#123;</span><br><span class="line">            temp.name &#x3D; newHeroNode.name;</span><br><span class="line">            temp.nickname &#x3D; newHeroNode.nickname;</span><br><span class="line"></span><br><span class="line">        &#125; else &#123; &#x2F;&#x2F;没有找到</span><br><span class="line">            System.out.printf(&quot;没有找到编号%d的节点\n&quot;, newHeroNode.no);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 从双向链表中删除一个节点</span><br><span class="line">     * 对于双向链表,可以直接找到要删除的节点,找到后自我删除</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public void del(int no) &#123;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;判断当前链表是否为空</span><br><span class="line">        if (head.next &#x3D;&#x3D; null) &#123;</span><br><span class="line">            System.out.println(&quot;链表为空,无法删除&quot;);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        HeroNode2 temp &#x3D; head.next; &#x2F;&#x2F;辅助变量</span><br><span class="line">        boolean flag &#x3D; false; &#x2F;&#x2F;标识是否找到待删除节点</span><br><span class="line">        while (true) &#123;</span><br><span class="line">            if (temp &#x3D;&#x3D; null) &#123;</span><br><span class="line">                &#x2F;&#x2F;已经到链表的最后</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            if (temp.no &#x3D;&#x3D; no) &#123;</span><br><span class="line">                &#x2F;&#x2F;找到待删除节点的前一个节点</span><br><span class="line">                flag &#x3D; true;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            temp &#x3D; temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;判断flag</span><br><span class="line">        if (flag) &#123; &#x2F;&#x2F;找到节点,可以删除</span><br><span class="line">            temp.pre.next &#x3D; temp.next;</span><br><span class="line">            &#x2F;&#x2F;如果是最后一个节点,就不需要指向</span><br><span class="line">            if (temp.next !&#x3D; null) &#123;</span><br><span class="line">                temp.next.pre &#x3D; temp.pre;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            System.out.printf(&quot;要删除的%d节点,不存在\n&quot;, no);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;定义一个heroNode,每个heroNode对象就是一个节点</span><br><span class="line">class HeroNode2 &#123;</span><br><span class="line"></span><br><span class="line">    public int no;</span><br><span class="line">    public String name;</span><br><span class="line">    public String nickname;</span><br><span class="line">    public HeroNode2 next; &#x2F;&#x2F;指向下一个节点,默认为null</span><br><span class="line">    public HeroNode2 pre;  &#x2F;&#x2F;指向前一个节点,默认为null</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;构造器</span><br><span class="line"></span><br><span class="line">    public HeroNode2(int no, String name, String nickname) &#123;</span><br><span class="line">        this.no &#x3D; no;</span><br><span class="line">        this.name &#x3D; name;</span><br><span class="line">        this.nickname &#x3D; nickname;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return &quot;HeroNode2&#123;&quot; +</span><br><span class="line">                &quot;no&#x3D;&quot; + no +</span><br><span class="line">                &quot;, name&#x3D;&#39;&quot; + name + &#39;\&#39;&#39; +</span><br><span class="line">                &quot;, nickname&#x3D;&#39;&quot; + nickname + &#39;\&#39;&#39; +</span><br><span class="line">                &quot;, next&#x3D;&quot; + next +</span><br><span class="line">                &#39;&#125;&#39;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="约瑟夫环问题-单向循环链表"><a href="#约瑟夫环问题-单向循环链表" class="headerlink" title="约瑟夫环问题(单向循环链表)"></a>约瑟夫环问题(单向循环链表)</h1><h2 id="废话不多说-直接上代码-1"><a href="#废话不多说-直接上代码-1" class="headerlink" title="废话不多说,直接上代码"></a>废话不多说,直接上代码</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package com.csw.LinkedList;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * @Auther: 行路</span><br><span class="line"> * @Date: Created on 2020&#x2F;4&#x2F;14 21:59 星期二</span><br><span class="line"> * @Description: com.csw.LinkedList</span><br><span class="line"> * @version: 1.0</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class Josephu &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        &#x2F;&#x2F;测试一把看看构建环形链表,和遍历是否ok</span><br><span class="line">        CircleSingleLinkedList circleSingleLinkedList &#x3D; new CircleSingleLinkedList();</span><br><span class="line">        circleSingleLinkedList.addBoy(5); &#x2F;&#x2F;加入5个小孩节点</span><br><span class="line">        circleSingleLinkedList.showBoy();</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;测试小孩出圈是否正确&quot;);</span><br><span class="line">        circleSingleLinkedList.countBoy(1,2,5);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;创建环形的单向链表</span><br><span class="line">class CircleSingleLinkedList &#123;</span><br><span class="line">    &#x2F;&#x2F;创建一个first节点,当前没有编号</span><br><span class="line">    private Boy first &#x3D; new Boy(-1);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;添加小孩,构建成一个环形的链表</span><br><span class="line">    public void addBoy(int nums) &#123;</span><br><span class="line">        &#x2F;&#x2F;nums做一个数据校验</span><br><span class="line">        if (nums &lt; 1) &#123;</span><br><span class="line">            System.out.println(&quot;nums的值不正确&quot;);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        Boy curBoy &#x3D; null; &#x2F;&#x2F;辅助指针,帮助构建环形链表</span><br><span class="line">        &#x2F;&#x2F;使用for循环创建环形链表</span><br><span class="line">        for (int i &#x3D; 1; i &lt;&#x3D; nums; i++) &#123;</span><br><span class="line">            &#x2F;&#x2F;根据编号,创建小孩节点</span><br><span class="line">            Boy boy &#x3D; new Boy(i);</span><br><span class="line">            &#x2F;&#x2F;如果是第一个小孩</span><br><span class="line">            if (i &#x3D;&#x3D; 1) &#123;</span><br><span class="line">                first &#x3D; boy;</span><br><span class="line">                first.setNext(first); &#x2F;&#x2F;构成环</span><br><span class="line">                curBoy &#x3D; first; &#x2F;&#x2F;让curBoy指向</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                curBoy.setNext(boy); &#x2F;&#x2F;</span><br><span class="line">                boy.setNext(first);</span><br><span class="line">                curBoy &#x3D; boy;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;遍历当前的环形链表</span><br><span class="line">    public void showBoy() &#123;</span><br><span class="line">        &#x2F;&#x2F;判断链表是否为空</span><br><span class="line">        if (first &#x3D;&#x3D; null) &#123;</span><br><span class="line">            System.out.println(&quot;链表为空&quot;);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;因为first不能动,因此我们仍然使用一个辅助指针完成遍历</span><br><span class="line">        Boy curBoy &#x3D; first;</span><br><span class="line">        while (true) &#123;</span><br><span class="line">            System.out.printf(&quot;小孩的编号%d\n&quot;, curBoy.getNo());</span><br><span class="line">            if (curBoy.getNext() &#x3D;&#x3D; first) &#123; &#x2F;&#x2F;说明已经遍历完毕</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            curBoy &#x3D; curBoy.getNext();&#x2F;&#x2F;curBoy后移</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 根据用户的输入,计算出小孩出圈的概率</span><br><span class="line">     *</span><br><span class="line">     * @param startNo  表示第几个小孩楷书数数</span><br><span class="line">     * @param countNum 表示数几下</span><br><span class="line">     * @param nums     表示最初有多少小孩在圈中</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public void countBoy(int startNo, int countNum, int nums) &#123;</span><br><span class="line">        &#x2F;&#x2F;先对数据进行校验</span><br><span class="line">        if (first &#x3D;&#x3D; null || startNo &lt; 1 || startNo &gt; nums) &#123;</span><br><span class="line">            System.out.println(&quot;参数输入有问题,请重新输入&quot;);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;创建一个辅助节点,帮助完成小孩出圈</span><br><span class="line">        Boy helper &#x3D; first;</span><br><span class="line">        &#x2F;&#x2F;需要创建一个辅助指针(变量helper),事先应该指向环形链表最后这个节点</span><br><span class="line">        while (true) &#123;</span><br><span class="line">            if (helper.getNext() &#x3D;&#x3D; first) &#123; &#x2F;&#x2F;说明hepler指向最后小孩节点</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            helper &#x3D; helper.getNext();</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;小孩报数,先让first和helper移动k-1次</span><br><span class="line">        for (int j&#x3D;0;j&lt;startNo-1;j++)&#123;</span><br><span class="line">            first&#x3D;first.getNext();</span><br><span class="line">            helper&#x3D;helper.getNext();</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;当小孩报数时,让first和helper指针同时移动m-1次,然后出圈</span><br><span class="line">        &#x2F;&#x2F;这里是一个循环操作,直到圈中只有一个节点</span><br><span class="line">        while (true)&#123;</span><br><span class="line">            if(helper&#x3D;&#x3D;first)&#123; &#x2F;&#x2F;说明圈中只有一个节点</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F;让first和helper指针同时移动countNum-1</span><br><span class="line">            for (int j&#x3D;0;j&lt;countNum-1;j++)&#123;</span><br><span class="line">                first&#x3D;first.getNext();</span><br><span class="line">                helper&#x3D;helper.getNext();</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F;这时first指向的节点,就是要出圈的小孩节点</span><br><span class="line">            System.out.printf(&quot;小孩%d出圈\n&quot;,first.getNo());</span><br><span class="line">            &#x2F;&#x2F;这时将first指向小孩节点出圈</span><br><span class="line">            first&#x3D;first.getNext();</span><br><span class="line">            helper.setNext(first);&#x2F;&#x2F;相当于再次构建环形链表</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.printf(&quot;最后留在圈中的小孩编号%d\n&quot;,first.getNo());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;创建一个Boy类,表示一个节点</span><br><span class="line">class Boy &#123;</span><br><span class="line">    private int no;&#x2F;&#x2F;编号</span><br><span class="line">    private Boy next; &#x2F;&#x2F;指向下一个节点</span><br><span class="line"></span><br><span class="line">    public Boy(int no) &#123;</span><br><span class="line">        this.no &#x3D; no;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int getNo() &#123;</span><br><span class="line">        return no;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setNo(int no) &#123;</span><br><span class="line">        this.no &#x3D; no;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Boy getNext() &#123;</span><br><span class="line">        return next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setNext(Boy next) &#123;</span><br><span class="line">        this.next &#x3D; next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;java实现双向链表&quot;&gt;&lt;a href=&quot;#java实现双向链表&quot; class=&quot;headerlink&quot; title=&quot;java实现双向链表&quot;&gt;&lt;/a&gt;java实现双向链表&lt;/h1&gt;&lt;h2 id=&quot;废话不多说-直接上代码&quot;&gt;&lt;a href=&quot;#废话不多说-直接上代
      
    
    </summary>
    
    
      <category term="数据结构" scheme="https://todcsw.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="学习" scheme="https://todcsw.github.io/tags/%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="java" scheme="https://todcsw.github.io/tags/java/"/>
    
      <category term="数据结构" scheme="https://todcsw.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>java实现单链表</title>
    <link href="https://todcsw.github.io/2020/04/14/java%E5%AE%9E%E7%8E%B0%E5%8D%95%E9%93%BE%E8%A1%A8/"/>
    <id>https://todcsw.github.io/2020/04/14/java%E5%AE%9E%E7%8E%B0%E5%8D%95%E9%93%BE%E8%A1%A8/</id>
    <published>2020-04-14T13:03:26.000Z</published>
    <updated>2020-04-14T13:05:23.506Z</updated>
    
    <content type="html"><![CDATA[<h1 id="java实现单链表"><a href="#java实现单链表" class="headerlink" title="java实现单链表"></a>java实现单链表</h1><h2 id="废话不多说-直接上代码"><a href="#废话不多说-直接上代码" class="headerlink" title="废话不多说,直接上代码"></a>废话不多说,直接上代码</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package com.csw.LinkedList;</span><br><span class="line"></span><br><span class="line">import jdk.nashorn.internal.ir.Flags;</span><br><span class="line"></span><br><span class="line">import java.util.Stack;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * @Auther: 行路</span><br><span class="line"> * @Date: Created on 2020&#x2F;4&#x2F;14 20:03:24</span><br><span class="line"> * @Description: com.csw.LinkedList 该链表按照添加顺序存储。</span><br><span class="line"> * @version: 1.0</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class SIngleLinkedListDemo &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        &#x2F;&#x2F;测试代码</span><br><span class="line">        &#x2F;&#x2F;创建节点</span><br><span class="line">        HeroNode hero1 &#x3D; new HeroNode(1, &quot;松江&quot;, &quot;及时雨&quot;);</span><br><span class="line">        HeroNode hero2 &#x3D; new HeroNode(2, &quot;卢&quot;, &quot;玉&quot;);</span><br><span class="line">        HeroNode hero3 &#x3D; new HeroNode(3, &quot;无用&quot;, &quot;智多星&quot;);</span><br><span class="line">        HeroNode hero4 &#x3D; new HeroNode(4, &quot;林冲&quot;, &quot;豹子头&quot;);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;创建链表</span><br><span class="line">        SingleLinkedList singleLinkedList&#x3D;new SingleLinkedList();</span><br><span class="line">        &#x2F;&#x2F;加入按照编号的顺序</span><br><span class="line">&#x2F;&#x2F;        singleLinkedList.add(hero1);</span><br><span class="line">&#x2F;&#x2F;        singleLinkedList.add(hero2);</span><br><span class="line">&#x2F;&#x2F;        singleLinkedList.add(hero3);</span><br><span class="line">&#x2F;&#x2F;        singleLinkedList.add(hero4);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        singleLinkedList.addByOrder(hero2);</span><br><span class="line">        singleLinkedList.addByOrder(hero1);</span><br><span class="line">        singleLinkedList.addByOrder(hero4);</span><br><span class="line">        singleLinkedList.addByOrder(hero3);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;修改前</span><br><span class="line"></span><br><span class="line">        singleLinkedList.list();</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;测试修改节点的代码</span><br><span class="line">        HeroNode hero5&#x3D;new HeroNode(2,&quot;骁龙&quot;,&quot;855&quot;);</span><br><span class="line">        singleLinkedList.update(hero5);</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;~~~~~~~~&quot;);</span><br><span class="line">        &#x2F;&#x2F;显示</span><br><span class="line">        singleLinkedList.del(4);</span><br><span class="line">        singleLinkedList.list();</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;有效节点的个数&quot;+getLength(singleLinkedList.getHead()));</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;测试得到倒数第k个&quot;);</span><br><span class="line">        HeroNode res&#x3D;findLastIndexNode(singleLinkedList.getHead(),3);</span><br><span class="line">        System.out.println(res);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;逆序打印&quot;);</span><br><span class="line">        reversePrint(singleLinkedList.getHead()); &#x2F;&#x2F;没有改变链表的本身结构</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;测试反转&quot;);</span><br><span class="line">        reversetList(singleLinkedList.getHead());</span><br><span class="line">        singleLinkedList.list();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * &#x2F;&#x2F;方法,获取单链表的节点个数(如果带头节点的链表,需求不统计头节点)</span><br><span class="line">     *这是一个方法,返回单链表的有效的节点个数</span><br><span class="line">     * @param head 链表的头节点</span><br><span class="line">     * @return 返回的是有效节点的个数</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public static int getLength(HeroNode head)&#123;</span><br><span class="line">        if(head.next&#x3D;&#x3D;null)&#123; &#x2F;&#x2F;空链表</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        int length&#x3D;0;</span><br><span class="line">        &#x2F;&#x2F;定义一个辅助变量</span><br><span class="line">        HeroNode cur&#x3D;head.next;</span><br><span class="line">        while(cur!&#x3D;null)&#123;</span><br><span class="line">            length++;</span><br><span class="line">            cur&#x3D;cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        return length;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * &#x2F;&#x2F;查找单链表中的倒数第k个结点(新浪面试题)</span><br><span class="line">     *     &#x2F;&#x2F;思路</span><br><span class="line">     *     &#x2F;&#x2F;1.编写一个方法,接收head节点,同时接收一个index</span><br><span class="line">     *     &#x2F;&#x2F;2.index 表示是倒数第Index个节点</span><br><span class="line">     *     &#x2F;&#x2F;3.先把链表从头到尾遍历,得到链表的总长度,getLength</span><br><span class="line">     *     &#x2F;&#x2F;4.得到size后,我们从链表的第一个开始遍历(size-index)个,就可以得到</span><br><span class="line">     *     &#x2F;&#x2F;5,如果找到了,则返回该节点,否则返回null</span><br><span class="line">     * @param head</span><br><span class="line">     * @param index</span><br><span class="line">     * @return</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public static HeroNode findLastIndexNode(HeroNode head,int index)&#123;</span><br><span class="line">        &#x2F;&#x2F;判断如果链表为空,返回null</span><br><span class="line">        if(head.next&#x3D;&#x3D;null)&#123;</span><br><span class="line">            return null; &#x2F;&#x2F;没有找到</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;第一次遍历得到的链表的长度(节点的个数)</span><br><span class="line">        int size&#x3D;getLength(head);</span><br><span class="line">        &#x2F;&#x2F;第二次遍历 size-index位置,就是我们倒数的第k个节点</span><br><span class="line">        &#x2F;&#x2F;先做一个(index)数据的校验</span><br><span class="line">        if(index&lt;&#x3D;0||index&gt;size)&#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;定义一个辅助变量,for循环定位到倒数的Index</span><br><span class="line">        HeroNode cur&#x3D;head.next;</span><br><span class="line">        for(int i&#x3D;0;i&lt;size-index;i++)&#123;</span><br><span class="line">            cur&#x3D;cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        return cur;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;将单链表进行反转</span><br><span class="line">    public static void  reversetList(HeroNode head)&#123;</span><br><span class="line">        &#x2F;&#x2F;如果链表为空,或者只有一个节点,无需反转,直接返回</span><br><span class="line">        if(head.next&#x3D;&#x3D;null||head.next.next&#x3D;&#x3D;null)&#123;</span><br><span class="line">            return ;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;先定义一个辅助的变量,帮助我们遍历原来的链表</span><br><span class="line">        HeroNode cur&#x3D;head.next;</span><br><span class="line">        HeroNode next&#x3D;null; &#x2F;&#x2F;指向当前节点[cur]的下一个节点</span><br><span class="line">        HeroNode reverseHead&#x3D;new HeroNode(0,&quot;&quot;,&quot;&quot;);</span><br><span class="line">        &#x2F;&#x2F;遍历原来的链表,并从点到尾遍历原来的链表,每遍历一个节点,就将其取出,并放在新的链表reverseHead的最前端</span><br><span class="line">        while(cur!&#x3D;null)&#123;</span><br><span class="line">            next&#x3D;cur.next;&#x2F;&#x2F;先暂时保存当前节点的下一个节点</span><br><span class="line">            cur.next&#x3D;reverseHead.next; &#x2F;&#x2F;将cur的下一个节点指向新的链表的最前端</span><br><span class="line">            reverseHead.next&#x3D;cur; &#x2F;&#x2F;将cur连接到新的链表上</span><br><span class="line">            cur&#x3D;next; &#x2F;&#x2F;让cur指向下一个节点,后移一次</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;将head.next指向reverseHead.next,实现单链表的反转</span><br><span class="line">        head.next&#x3D;reverseHead.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;从尾到头打印单链表(逆序打印单链表)</span><br><span class="line">    &#x2F;&#x2F;方式一:先将单链表进行反转,然后再遍历,破坏原来的单链表的结构</span><br><span class="line">    &#x2F;&#x2F;方式二:利用栈,将各个节点压入栈,然后利用栈的先进后厨特点,实现逆序打印的效果。</span><br><span class="line">    &#x2F;&#x2F;使用方式二</span><br><span class="line">    public static void  reversePrint(HeroNode head)&#123;</span><br><span class="line">        if(head.next&#x3D;&#x3D;null)&#123;</span><br><span class="line">            return;&#x2F;&#x2F;空链表不能打印</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;创建一个栈,将各个节点压入栈</span><br><span class="line">        Stack&lt;HeroNode&gt; stack&#x3D;new Stack&lt;&gt;();</span><br><span class="line">        HeroNode cur&#x3D;head.next;</span><br><span class="line">        &#x2F;&#x2F;将链表的所有节点压入栈中</span><br><span class="line">        while (cur!&#x3D;null)&#123;</span><br><span class="line">            stack.push(cur);</span><br><span class="line">            cur&#x3D;cur.next; &#x2F;&#x2F;将cur后移,这样就可以压入下一个节点</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;将栈中的节点进行打印pop出栈</span><br><span class="line">        while (stack.size()&gt;0)&#123;</span><br><span class="line">            System.out.println(stack.pop()); &#x2F;&#x2F;stack的特点是先进后厨</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;定义SingleLinkedList管理我们的英雄</span><br><span class="line">class SingleLinkedList&#123;</span><br><span class="line">    &#x2F;&#x2F;先创建一个头节点,头节点不要动</span><br><span class="line">    private HeroNode head&#x3D;new HeroNode(0,&quot;&quot;,&quot;&quot;);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;返回头节点</span><br><span class="line">    public HeroNode getHead() &#123;</span><br><span class="line">        return head;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setHead(HeroNode head) &#123;</span><br><span class="line">        this.head &#x3D; head;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;添加节点到单向链表</span><br><span class="line">    &#x2F;&#x2F;思路,当不考虑编号顺序</span><br><span class="line">    &#x2F;&#x2F;1.找到当前链表的最后节点</span><br><span class="line">    &#x2F;&#x2F;2.将最后这个节点的next,指向新的链表</span><br><span class="line">    public void add(HeroNode heroNode)&#123;</span><br><span class="line">        &#x2F;&#x2F;因为head节点不能动,因此我们需要一个辅助遍历temp</span><br><span class="line">        HeroNode temp&#x3D;head;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;遍历链表,找到最后</span><br><span class="line">        while (true)&#123;</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F;找到链表的最后</span><br><span class="line">            if(temp.next&#x3D;&#x3D;null)&#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F;如果没有找到最后,就将temp后移</span><br><span class="line">            temp&#x3D;temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;当退出while循环时,temp就指向了链表的最后</span><br><span class="line">        &#x2F;&#x2F;将最后这个 节点的next指向新的节点</span><br><span class="line">        temp.next&#x3D;heroNode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;第二种添加人物按照顺序添加到指定的位置</span><br><span class="line">    public  void  addByOrder(HeroNode heroNode)&#123;</span><br><span class="line">        &#x2F;&#x2F;头节点不能动,因此我们任然需要通过辅助指针</span><br><span class="line">        &#x2F;&#x2F;因为单链表,我们找的temp是位于添加位置的前一个节点,否则加入失败</span><br><span class="line">        HeroNode temp&#x3D;head;</span><br><span class="line"></span><br><span class="line">        boolean flag&#x3D;false; &#x2F;&#x2F;标识添加的编号是否存在,默认为false;</span><br><span class="line">        while (true)&#123;</span><br><span class="line">            if(temp.next&#x3D;&#x3D;null)&#123;</span><br><span class="line">                &#x2F;&#x2F;说明temp已经在链表的最后</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            if(temp.next.no&gt;heroNode.no)&#123; &#x2F;&#x2F;位置找到,就在temp的后面插入</span><br><span class="line">                break;</span><br><span class="line">            &#125;else if(temp.next.no&#x3D;&#x3D;heroNode.no)&#123; &#x2F;&#x2F;说明希望添加的heroNode的编号已经存在</span><br><span class="line">                flag&#x3D;true; &#x2F;&#x2F;说明编号存在</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            temp&#x3D;temp.next; &#x2F;&#x2F;后移,遍历当前链表</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;判断flag的值</span><br><span class="line">        if(flag)&#123; &#x2F;&#x2F;不能添加,说明编号已经存在</span><br><span class="line">            System.out.println(&quot;准备插入的人的编号已经存在,不能加入,&quot;+heroNode.no);</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            &#x2F;&#x2F;插入到链表中,temp的后边</span><br><span class="line">            heroNode.next&#x3D;temp.next;</span><br><span class="line">            temp.next&#x3D;heroNode;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;删除节点</span><br><span class="line">    &#x2F;&#x2F;思路</span><br><span class="line">    &#x2F;&#x2F;1.head节点不能动,因此需要一个temp辅助节点,找到待删除节点的前一个节点</span><br><span class="line">    &#x2F;&#x2F;2.说明我们在比较时,是temp.next.no和要删除的节点的no比较</span><br><span class="line">    public void del(int no)&#123;</span><br><span class="line">        HeroNode temp&#x3D;head;</span><br><span class="line">        boolean flag&#x3D;false; &#x2F;&#x2F;标识是否找到待删除节点</span><br><span class="line">        while(true)&#123;</span><br><span class="line">            if(temp.next&#x3D;&#x3D;null)&#123;</span><br><span class="line">                &#x2F;&#x2F;已经到链表的最后</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            if(temp.next.no&#x3D;&#x3D;no)&#123;</span><br><span class="line">                &#x2F;&#x2F;找到待删除节点的前一个节点</span><br><span class="line">                flag&#x3D;true;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            temp&#x3D;temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;判断flag</span><br><span class="line">        if(flag)&#123; &#x2F;&#x2F;找到节点,可以删除</span><br><span class="line">            temp.next&#x3D;temp.next.next;</span><br><span class="line">        &#125;else &#123;</span><br><span class="line">            System.out.printf(&quot;要删除的%d节点,不存在\n&quot;,no);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;修改节点的信息,根据编号来修改,即no编号不能改</span><br><span class="line">    &#x2F;&#x2F;说明:根据newHeroNode的no来修改</span><br><span class="line">    public void update(HeroNode newHeroNode)&#123;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;判断是否为空</span><br><span class="line">        if(head.next&#x3D;&#x3D;null)&#123;</span><br><span class="line">            System.out.println(&quot;链表为空&quot;);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;找到需要修改的链表,根据no编号</span><br><span class="line">        &#x2F;&#x2F;定义一个辅助变量</span><br><span class="line">        HeroNode temp&#x3D;head.next;</span><br><span class="line">        boolean flag&#x3D;false; &#x2F;&#x2F;表示是否找到改节点</span><br><span class="line">        while(true)&#123;</span><br><span class="line">            if(temp&#x3D;&#x3D;null)&#123;</span><br><span class="line">                break;&#x2F;&#x2F;到链表的最后的下一个(表示链表已经遍历完)</span><br><span class="line">            &#125;</span><br><span class="line">            if(temp.no&#x3D;&#x3D;newHeroNode.no)&#123;</span><br><span class="line">                &#x2F;&#x2F;找到了</span><br><span class="line">                flag&#x3D;true;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            temp&#x3D;temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;根据flag判断是否找到要修改的节点</span><br><span class="line">        if(flag)&#123;</span><br><span class="line">            temp.name&#x3D;newHeroNode.name;</span><br><span class="line">            temp.nickname&#x3D;newHeroNode.nickname;</span><br><span class="line"></span><br><span class="line">        &#125;else&#123; &#x2F;&#x2F;没有找到</span><br><span class="line">            System.out.printf(&quot;没有找到编号%d的节点\n&quot;,newHeroNode.no);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;显示链表[遍历]</span><br><span class="line">    public void list()&#123;</span><br><span class="line">        &#x2F;&#x2F;判断链表是否为空</span><br><span class="line">        if(head.next&#x3D;&#x3D;null)&#123;</span><br><span class="line">            System.out.println(&quot;链表为空&quot;);</span><br><span class="line">            return ;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;因为头节点,不能动,因次需要一个辅助变量来遍历</span><br><span class="line">        HeroNode temp&#x3D;head.next;</span><br><span class="line">        while (true)&#123;</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F;判断链表是否到最后</span><br><span class="line">            if(temp&#x3D;&#x3D;null)&#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F;输出节点的信息</span><br><span class="line">            System.out.println(temp.toString());</span><br><span class="line">            &#x2F;&#x2F;将temp后移</span><br><span class="line">            temp&#x3D;temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;定义一个heroNode,每个heroNode对象就是一个节点</span><br><span class="line">class HeroNode&#123;</span><br><span class="line"></span><br><span class="line">    public int no;</span><br><span class="line">    public String name;</span><br><span class="line">    public String nickname;</span><br><span class="line">    public HeroNode next; &#x2F;&#x2F;指向下一个节点</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;构造器</span><br><span class="line"></span><br><span class="line">    public HeroNode(int no, String name, String nickname) &#123;</span><br><span class="line">        this.no &#x3D; no;</span><br><span class="line">        this.name &#x3D; name;</span><br><span class="line">        this.nickname &#x3D; nickname;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return &quot;HeroNode&#123;&quot; +</span><br><span class="line">                &quot;no&#x3D;&quot; + no +</span><br><span class="line">                &quot;, name&#x3D;&#39;&quot; + name + &#39;\&#39;&#39; +</span><br><span class="line">                &quot;, nickname&#x3D;&#39;&quot; + nickname + &#39;\&#39;&#39; +</span><br><span class="line">                &#39;&#125;&#39;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;java实现单链表&quot;&gt;&lt;a href=&quot;#java实现单链表&quot; class=&quot;headerlink&quot; title=&quot;java实现单链表&quot;&gt;&lt;/a&gt;java实现单链表&lt;/h1&gt;&lt;h2 id=&quot;废话不多说-直接上代码&quot;&gt;&lt;a href=&quot;#废话不多说-直接上代码&quot; c
      
    
    </summary>
    
    
      <category term="数据结构" scheme="https://todcsw.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="学习" scheme="https://todcsw.github.io/tags/%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="java" scheme="https://todcsw.github.io/tags/java/"/>
    
      <category term="数据结构" scheme="https://todcsw.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>猜数游戏作业</title>
    <link href="https://todcsw.github.io/2020/04/13/%E7%8C%9C%E6%95%B0%E6%B8%B8%E6%88%8F/"/>
    <id>https://todcsw.github.io/2020/04/13/%E7%8C%9C%E6%95%B0%E6%B8%B8%E6%88%8F/</id>
    <published>2020-04-13T11:10:36.000Z</published>
    <updated>2020-04-13T12:43:14.679Z</updated>
    
    <content type="html"><![CDATA[<h1 id="jsp的猜数游戏作业"><a href="#jsp的猜数游戏作业" class="headerlink" title="jsp的猜数游戏作业"></a>jsp的猜数游戏作业</h1><h2 id="guess1-jsp"><a href="#guess1-jsp" class="headerlink" title="guess1.jsp"></a>guess1.jsp</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;%@ page import&#x3D;&quot;java.util.Random&quot; %&gt;&lt;%--</span><br><span class="line">  Created by IntelliJ IDEA.</span><br><span class="line">  User: 行路</span><br><span class="line">  Date: 2020&#x2F;4&#x2F;13</span><br><span class="line">  Time: 19:06</span><br><span class="line">  To change this template use File | Settings | File Templates.</span><br><span class="line">--%&gt;</span><br><span class="line">&lt;%@ page contentType&#x3D;&quot;text&#x2F;html;charset&#x3D;UTF-8&quot; language&#x3D;&quot;java&quot; %&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;guess1&lt;&#x2F;title&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;%</span><br><span class="line">    Random random&#x3D;new Random();</span><br><span class="line">   int  i &#x3D; random.nextInt(100) + 1;</span><br><span class="line">    session.setAttribute(&quot;rand&quot;,i);</span><br><span class="line">    int count&#x3D;0;</span><br><span class="line">    session.setAttribute(&quot;count&quot;,count);</span><br><span class="line">    long time &#x3D; System.currentTimeMillis();</span><br><span class="line">    session.setAttribute(&quot;time&quot;,time);</span><br><span class="line">    response.sendRedirect(&quot;Guess.jsp&quot;);</span><br><span class="line">%&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure><h2 id="Guess-jsp"><a href="#Guess-jsp" class="headerlink" title="Guess.jsp"></a>Guess.jsp</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;%@ page import&#x3D;&quot;java.util.Random&quot; %&gt;&lt;%--</span><br><span class="line">  Created by IntelliJ IDEA.</span><br><span class="line">  User: 行路</span><br><span class="line">  Date: 2020&#x2F;4&#x2F;13</span><br><span class="line">  Time: 18:47</span><br><span class="line">  To change this template use File | Settings | File Templates.</span><br><span class="line">--%&gt;</span><br><span class="line">&lt;%@ page contentType&#x3D;&quot;text&#x2F;html;charset&#x3D;UTF-8&quot; language&#x3D;&quot;java&quot; %&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;猜数游戏&lt;&#x2F;title&gt;</span><br><span class="line">&lt;&#x2F;head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;%</span><br><span class="line">    int i &#x3D; (int) session.getAttribute(&quot;rand&quot;);</span><br><span class="line">    int count &#x3D; (int) session.getAttribute(&quot;count&quot;);</span><br><span class="line">    long currentTimeMillis &#x3D; 0;</span><br><span class="line">    System.out.println(i);</span><br><span class="line">    if (request.getParameter(&quot;guess&quot;) !&#x3D; &quot;&quot; &amp;&amp; request.getParameter(&quot;guess&quot;) !&#x3D; null) &#123;</span><br><span class="line">        int guess &#x3D; Integer.parseInt(request.getParameter(&quot;guess&quot;));</span><br><span class="line">        if (guess &gt; i) &#123;</span><br><span class="line">            session.setAttribute(&quot;guess&quot;, &quot;猜大了&quot;);</span><br><span class="line">            count++;</span><br><span class="line">            session.setAttribute(&quot;count&quot;, count);</span><br><span class="line">        &#125; else if (guess &lt; i) &#123;</span><br><span class="line">            session.setAttribute(&quot;guess&quot;, &quot;猜的太小了&quot;);</span><br><span class="line">            count++;</span><br><span class="line">            session.setAttribute(&quot;count&quot;, count);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            session.setAttribute(&quot;guess&quot;, &quot;猜数正确&quot;);</span><br><span class="line">            currentTimeMillis &#x3D; System.currentTimeMillis();</span><br><span class="line">            count++;</span><br><span class="line">            session.setAttribute(&quot;count&quot;, count);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        session.setAttribute(&quot;guess&quot;, &quot;输入的数不能为空&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">%&gt;</span><br><span class="line">&lt;form action&#x3D;&quot;Guess.jsp&quot; method&#x3D;&quot;post&quot; &gt;</span><br><span class="line">    &lt;p&gt;&lt;%</span><br><span class="line">        if (session.getAttribute(&quot;guess&quot;) !&#x3D; null) &#123;</span><br><span class="line">            out.write(session.getAttribute(&quot;guess&quot;).toString());</span><br><span class="line">            if (session.getAttribute(&quot;guess&quot;).toString().equals(&quot;猜数正确&quot;)) &#123;</span><br><span class="line">                out.write(&quot;共猜了&quot; + (int) session.getAttribute(&quot;count&quot;) + &quot;次,耗时&quot; + (currentTimeMillis - (Long) session.getAttribute(&quot;time&quot;)) &#x2F; 1000 + &quot;秒&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    %&gt;</span><br><span class="line">    &lt;&#x2F;p&gt;</span><br><span class="line">    &lt;h2&gt;猜数游戏&lt;&#x2F;h2&gt;</span><br><span class="line">    &lt;p&gt;请输入1-100的数字&lt;&#x2F;p&gt;</span><br><span class="line">    &lt;input type&#x3D;&quot;text&quot; name&#x3D;&quot;guess&quot;&#x2F;&gt;</span><br><span class="line">    &lt;%</span><br><span class="line">        if (session.getAttribute(&quot;guess&quot;) !&#x3D; null &amp;&amp; session.getAttribute(&quot;guess&quot;).toString().equals(&quot;猜数正确&quot;)) &#123;</span><br><span class="line">            session.removeAttribute(&quot;guess&quot;);</span><br><span class="line">    %&gt;</span><br><span class="line">    &lt;button type&#x3D;&quot;submit&quot; disabled&gt;提交&lt;&#x2F;button&gt;</span><br><span class="line">    &lt;% &#125; else &#123;%&gt;</span><br><span class="line">    &lt;button type&#x3D;&quot;submit&quot;&gt;提交&lt;&#x2F;button&gt;</span><br><span class="line">    &lt;%&#125;%&gt;</span><br><span class="line">&lt;&#x2F;form&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;jsp的猜数游戏作业&quot;&gt;&lt;a href=&quot;#jsp的猜数游戏作业&quot; class=&quot;headerlink&quot; title=&quot;jsp的猜数游戏作业&quot;&gt;&lt;/a&gt;jsp的猜数游戏作业&lt;/h1&gt;&lt;h2 id=&quot;guess1-jsp&quot;&gt;&lt;a href=&quot;#guess1-jsp&quot;
      
    
    </summary>
    
    
      <category term="作业" scheme="https://todcsw.github.io/categories/%E4%BD%9C%E4%B8%9A/"/>
    
    
      <category term="作业" scheme="https://todcsw.github.io/tags/%E4%BD%9C%E4%B8%9A/"/>
    
  </entry>
  
  <entry>
    <title>java稀疏数组和普通数组的转换</title>
    <link href="https://todcsw.github.io/2020/04/10/java%E7%A8%80%E7%96%8F%E6%95%B0%E7%BB%84%E5%92%8C%E6%99%AE%E9%80%9A%E6%95%B0%E7%BB%84%E7%9A%84%E8%BD%AC%E6%8D%A2/"/>
    <id>https://todcsw.github.io/2020/04/10/java%E7%A8%80%E7%96%8F%E6%95%B0%E7%BB%84%E5%92%8C%E6%99%AE%E9%80%9A%E6%95%B0%E7%BB%84%E7%9A%84%E8%BD%AC%E6%8D%A2/</id>
    <published>2020-04-10T15:23:20.000Z</published>
    <updated>2020-04-16T05:50:19.070Z</updated>
    
    <content type="html"><![CDATA[<h1 id="java稀疏数组和普通数组的转换"><a href="#java稀疏数组和普通数组的转换" class="headerlink" title="java稀疏数组和普通数组的转换"></a>java稀疏数组和普通数组的转换</h1><h2 id="废话不多说-直接上代码"><a href="#废话不多说-直接上代码" class="headerlink" title="废话不多说,直接上代码"></a>废话不多说,直接上代码</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package com.csw.sparse;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * @Auther: 行路</span><br><span class="line"> * @Date: Created on 2020&#x2F;4&#x2F;2 16:47 星期四</span><br><span class="line"> * @Description: com.csw  稀疏数组和普通数组的转换</span><br><span class="line"> * @version: 1.0</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class Sparsearray &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        &#x2F;&#x2F;创建一个原始的二维数组 11*11</span><br><span class="line">        &#x2F;&#x2F;0:表示没有棋子,1表示黑子,2表示蓝子</span><br><span class="line">        int[][] chessArr&#x3D;new int[11][11];</span><br><span class="line"></span><br><span class="line">        chessArr[1][2]&#x3D;1;</span><br><span class="line">        chessArr[2][3]&#x3D;2;</span><br><span class="line">        chessArr[4][5]&#x3D;2;</span><br><span class="line">        &#x2F;&#x2F;输出原始的二维数组</span><br><span class="line">        System.out.println(&quot;原始的二维数组&quot;);</span><br><span class="line">        for(int [] row:chessArr)&#123;</span><br><span class="line">            for(int a:row)&#123;</span><br><span class="line">                System.out.printf(&quot;%d\t&quot;,a);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(&quot;&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;将二维数组转换为稀疏数组的思想</span><br><span class="line">        &#x2F;&#x2F;1.先遍历二维数组 得到非0数据的个数</span><br><span class="line">        int sum&#x3D;0;</span><br><span class="line">        for(int i&#x3D;0;i&lt;11;i++)&#123;</span><br><span class="line">            for(int j&#x3D;0;j&lt;11;j++)&#123;</span><br><span class="line">                if(chessArr[i][j]!&#x3D;0)&#123;</span><br><span class="line">                    sum++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot;sum&#x3D;&quot;+sum);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;创建一个稀疏数组</span><br><span class="line">        int[][] sparseArray&#x3D;new int[sum+1][3];</span><br><span class="line">        &#x2F;&#x2F;给稀疏数组赋值</span><br><span class="line">        sparseArray[0][0]&#x3D;11;</span><br><span class="line">        sparseArray[0][1]&#x3D;11;</span><br><span class="line">        sparseArray[0][2]&#x3D;sum;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;遍历二维数组 将非0数据存放到稀疏数组</span><br><span class="line">        int count&#x3D;0; &#x2F;&#x2F;用于记录时第几个非0数据</span><br><span class="line">        for(int i&#x3D;0;i&lt;11;i++)&#123;</span><br><span class="line">            for(int j&#x3D;0;j&lt;11;j++)&#123;</span><br><span class="line">                if(chessArr[i][j]!&#x3D;0)&#123;</span><br><span class="line">                    count++;</span><br><span class="line">                   sparseArray[count][0]&#x3D;i;</span><br><span class="line">                   sparseArray[count][1]&#x3D;j;</span><br><span class="line">                   sparseArray[count][2]&#x3D;chessArr[i][j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 输出稀疏数组的形式</span><br><span class="line">        System.out.println(&quot;稀疏数组----&quot;);</span><br><span class="line">        for(int [] row:sparseArray)&#123;</span><br><span class="line">            for(int a:row)&#123;</span><br><span class="line">                System.out.printf(&quot;%d\t&quot;,a);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(&quot;&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;将稀疏数组-》恢复为原来的数组</span><br><span class="line">        &#x2F;**</span><br><span class="line">         * 1.先读取稀疏数组的第一行,根据第一行的数据,创建原始的二维数组</span><br><span class="line">         * 2.在读取稀疏数组后几行数据,并赋给原始的二维数组即可</span><br><span class="line">         *</span><br><span class="line">         *&#x2F;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;1.先读取稀疏数组的第一行,根据第一行的数据,创建原始的二维数组</span><br><span class="line">        int[][] chessArr2&#x3D;new int[sparseArray[0][0]][sparseArray[0][1]];</span><br><span class="line">        &#x2F;&#x2F;2.在读取稀疏数组后几行数据,并赋给原始的二维数组即可</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;从第二行开始</span><br><span class="line">        for(int i&#x3D;1;i&lt;&#x3D;sparseArray[0][2];i++)&#123;</span><br><span class="line">                chessArr2[sparseArray[i][0]][sparseArray[i][1]]&#x3D;sparseArray[i][2];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;输出恢复后的数组</span><br><span class="line">        System.out.println(&quot;恢复后的数组----&quot;);</span><br><span class="line">        for(int [] row:chessArr2)&#123;</span><br><span class="line">            for(int a:row)&#123;</span><br><span class="line">                System.out.printf(&quot;%d\t&quot;,a);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(&quot;&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行效果<br><img src="/" class="lazyload" data-src="/images/array.png"  alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;java稀疏数组和普通数组的转换&quot;&gt;&lt;a href=&quot;#java稀疏数组和普通数组的转换&quot; class=&quot;headerlink&quot; title=&quot;java稀疏数组和普通数组的转换&quot;&gt;&lt;/a&gt;java稀疏数组和普通数组的转换&lt;/h1&gt;&lt;h2 id=&quot;废话不多说-直接上
      
    
    </summary>
    
    
      <category term="数据结构" scheme="https://todcsw.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="学习" scheme="https://todcsw.github.io/tags/%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="java" scheme="https://todcsw.github.io/tags/java/"/>
    
      <category term="数据结构" scheme="https://todcsw.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>写实日记1</title>
    <link href="https://todcsw.github.io/2020/04/09/%E5%86%99%E5%AE%9E%E6%97%A5%E8%AE%B01/"/>
    <id>https://todcsw.github.io/2020/04/09/%E5%86%99%E5%AE%9E%E6%97%A5%E8%AE%B01/</id>
    <published>2020-04-09T15:05:36.000Z</published>
    <updated>2020-04-09T15:17:59.157Z</updated>
    
    <content type="html"><![CDATA[<h1 id="累且枯燥"><a href="#累且枯燥" class="headerlink" title="累且枯燥"></a>累且枯燥</h1><p>算了,活着挺好的<br><img src="/" class="lazyload" data-src="/images/1.jpg"  alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;累且枯燥&quot;&gt;&lt;a href=&quot;#累且枯燥&quot; class=&quot;headerlink&quot; title=&quot;累且枯燥&quot;&gt;&lt;/a&gt;累且枯燥&lt;/h1&gt;&lt;p&gt;算了,活着挺好的&lt;br&gt;&lt;img src=&quot;/&quot; class=&quot;lazyload&quot; data-src=&quot;/images/1.
      
    
    </summary>
    
    
      <category term="生活" scheme="https://todcsw.github.io/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="生活" scheme="https://todcsw.github.io/tags/%E7%94%9F%E6%B4%BB/"/>
    
  </entry>
  
  <entry>
    <title>java实现循环队列</title>
    <link href="https://todcsw.github.io/2020/04/09/java%E5%AE%9E%E7%8E%B0%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%88%97/"/>
    <id>https://todcsw.github.io/2020/04/09/java%E5%AE%9E%E7%8E%B0%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%88%97/</id>
    <published>2020-04-09T14:40:36.000Z</published>
    <updated>2020-04-09T15:03:55.420Z</updated>
    
    <content type="html"><![CDATA[<h1 id="数据结构之队列"><a href="#数据结构之队列" class="headerlink" title="数据结构之队列"></a>数据结构之队列</h1><h2 id="队列介绍"><a href="#队列介绍" class="headerlink" title="队列介绍"></a>队列介绍</h2><h3 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h3><p>队列是一种特殊的线性表，特殊之处在于它只允许在表的前端（front）进行删除操作，而在表的后端（rear）进行插入操作，和栈一样，队列是一种操作受限制的线性表。进行插入操作的端称为队尾，进行删除操作的端称为队头。队列中没有元素时，称为空队列。<br>队列的数据元素又称为队列元素。在队列中插入一个队列元素称为入队，从队列中删除一个队列元素称为出队。因为队列只允许在一端插入，在另一端删除，所以只有最早进入队列的元素才能最先从队列中删除，故队列又称为先进先出（FIFO—first in first out）线性表。</p><h3 id="顺序队列"><a href="#顺序队列" class="headerlink" title="顺序队列"></a>顺序队列</h3><p>建立顺序队列结构必须为其静态分配或动态申请一片连续的存储空间，并设置两个指针进行管理。一个是队头指针front，它指向队头元素；另一个是队尾指针rear，它指向下一个入队元素的存储位置，如图所示<br>每次在队尾插入一个元素是，rear增1；每次在队头删除一个元素时，front增1。随着插入和删除操作的进行，队列元素的个数不断变化，队列所占的存储空间也在为队列结构所分配的连续空间中移动。当front=rear时，队列中没有任何元素，称为空队列。当rear增加到指向分配的连续空间之外时，队列无法再插入新元素，但这时往往还有大量可用空间未被占用，这些空间是已经出队的队列元素曾经占用过得存储单元。</p><h3 id="循环队列"><a href="#循环队列" class="headerlink" title="循环队列"></a>循环队列</h3><p>在实际使用队列时，为了使队列空间能重复使用，往往对队列的使用方法稍加改进：无论插入或删除，一旦rear指针增1或front指针增1 时超出了所分配的队列空间，就让它指向这片连续空间的起始位置。自己真从MaxSize-1增1变到0，可用取余运算rear%MaxSize和front%MaxSize来实现。这实际上是把队列空间想象成一个环形空间，环形空间中的存储单元循环使用，用这种方法管理的队列也就称为循环队列。除了一些简单应用之外，真正实用的队列是循环队列。<br><img src="/" class="lazyload" data-src="/images/queue.png"  alt=""></p><h2 id="普通顺序队列"><a href="#普通顺序队列" class="headerlink" title="普通顺序队列"></a>普通顺序队列</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package com.csw.queue;</span><br><span class="line"></span><br><span class="line">import java.util.Scanner;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * @Auther: 行路</span><br><span class="line"> * @Date: Created on 2020&#x2F;4&#x2F;2 19:16 星期四</span><br><span class="line"> * @Description: com.csw.queue 使用数组模拟队列</span><br><span class="line"> * @version: 1.0</span><br><span class="line"> *&#x2F;</span><br><span class="line"></span><br><span class="line">public class ArrayQueueDemo &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        &#x2F;&#x2F;创建一个队列</span><br><span class="line">       ArrayQueue queue&#x3D; new ArrayQueue(3);</span><br><span class="line">        char key&#x3D;&#39; &#39;;&#x2F;&#x2F;接收用户输入</span><br><span class="line">        Scanner scanner &#x3D; new Scanner(System.in);</span><br><span class="line">        boolean loop&#x3D;true;</span><br><span class="line">        &#x2F;&#x2F;输出一个菜单</span><br><span class="line">        while(loop)&#123;</span><br><span class="line">            System.out.println(&quot;s(show):显示队列&quot;);</span><br><span class="line">            System.out.println(&quot;e(exit):退出程序&quot;);</span><br><span class="line">            System.out.println(&quot;a(add):添加队列&quot;);</span><br><span class="line">            System.out.println(&quot;g(get):从队列取出数据&quot;);</span><br><span class="line">            System.out.println(&quot;h(head):查看队列头的数据&quot;);</span><br><span class="line">            key&#x3D;scanner.next().charAt(0); &#x2F;&#x2F;接收一个字符</span><br><span class="line">            switch (key)&#123;</span><br><span class="line">                case &#39;s&#39;:</span><br><span class="line">                    queue.showQueue();</span><br><span class="line">                    break;</span><br><span class="line"></span><br><span class="line">                case &#39;a&#39;:</span><br><span class="line">                    System.out.println(&quot;输入一个数字&quot;);</span><br><span class="line">                    int value&#x3D;scanner.nextInt();</span><br><span class="line">                    queue.addQueue(value);</span><br><span class="line">                    break;</span><br><span class="line">                case &#39;g&#39;: &#x2F;&#x2F;出去数据</span><br><span class="line">                    try&#123;</span><br><span class="line">                        int res&#x3D;queue.getQueue();</span><br><span class="line">                        System.out.printf(&quot;取出数据是%d&quot;,res);</span><br><span class="line">                    &#125;catch (Exception e)&#123;</span><br><span class="line">                        System.out.println(e.getMessage());</span><br><span class="line">                    &#125;</span><br><span class="line">                    break;</span><br><span class="line">                case &#39;h&#39;: &#x2F;&#x2F;出去数据</span><br><span class="line">                    try&#123;</span><br><span class="line">                        int res&#x3D;queue.headQueue();</span><br><span class="line">                        System.out.printf(&quot;队列的头数据是%d&quot;,res);</span><br><span class="line">                    &#125;catch (Exception e)&#123;</span><br><span class="line">                        System.out.println(e.getMessage());</span><br><span class="line">                    &#125;</span><br><span class="line">                    break;</span><br><span class="line">                case &#39;e&#39;: &#x2F;&#x2F;退出</span><br><span class="line">                    scanner.close();</span><br><span class="line">                    loop&#x3D;false;</span><br><span class="line">                    break;</span><br><span class="line">                default:</span><br><span class="line">                    break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot;程序退出&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;使用数组模拟队列-编写一个ArrayQueue类</span><br><span class="line">class ArrayQueue &#123;</span><br><span class="line">    private int maxSize;  &#x2F;&#x2F;表示数组的最大容量</span><br><span class="line">    private int front; &#x2F;&#x2F;执行队列头</span><br><span class="line">    private int rear; &#x2F;&#x2F;队列尾</span><br><span class="line">    private int[] arr;&#x2F;&#x2F;该数据用于存放数据,模拟队列</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;创建队列的一个构造器</span><br><span class="line">    public ArrayQueue(int arrMaxSize) &#123;</span><br><span class="line">        maxSize &#x3D; arrMaxSize;</span><br><span class="line">        arr &#x3D; new int[maxSize];</span><br><span class="line">        front &#x3D; -1; &#x2F;&#x2F;执行队列头部,分析出front时这指向队列头的前一个位置</span><br><span class="line">        rear &#x3D; -1; &#x2F;&#x2F;执行队列的尾部,即就是队列最后一个数据</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;判断队列是否慢</span><br><span class="line">    public boolean isFull() &#123;</span><br><span class="line">        return rear &#x3D;&#x3D; maxSize - 1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;判断队列是否为空</span><br><span class="line">    public boolean isEmpty() &#123;</span><br><span class="line">        return rear &#x3D;&#x3D; front;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;添加数据到队列</span><br><span class="line">    public void addQueue(int n) &#123;</span><br><span class="line">        &#x2F;&#x2F;判断队列是否慢</span><br><span class="line">        if (isFull()) &#123;</span><br><span class="line">            System.out.println(&quot;队列满,不能加入数据~&quot;);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        rear++;</span><br><span class="line">        arr[rear] &#x3D; n;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;数据出队列</span><br><span class="line">    public int getQueue() &#123;</span><br><span class="line">        &#x2F;&#x2F;判断是否为空</span><br><span class="line">        if (isEmpty()) &#123;</span><br><span class="line">            &#x2F;&#x2F;通过抛出异常</span><br><span class="line">            throw new RuntimeException(&quot;队列空,不能取数据&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        front++;</span><br><span class="line">        return arr[front];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;显示队列的所有数据</span><br><span class="line">    public void showQueue() &#123;</span><br><span class="line">        &#x2F;&#x2F;遍历数据</span><br><span class="line">        if (isEmpty()) &#123;</span><br><span class="line">            System.out.println(&quot;队列为空,没有数据~~~&quot;);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i &#x3D; 0; i &lt; arr.length; i++) &#123;</span><br><span class="line">            System.out.printf(&quot;arr[%d]&#x3D;%d\n&quot;, i, arr[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;显示队列头部数据,不是取出数据</span><br><span class="line"></span><br><span class="line">    public int headQueue() &#123;</span><br><span class="line">        &#x2F;&#x2F;判断</span><br><span class="line">        if (isEmpty()) &#123;</span><br><span class="line">            throw new RuntimeException(&quot;队列没有数据&quot;);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        return arr[front + 1];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="循环队列-1"><a href="#循环队列-1" class="headerlink" title="循环队列"></a>循环队列</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package com.csw.queue;</span><br><span class="line"></span><br><span class="line">import java.util.Scanner;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * @Auther: 行路</span><br><span class="line"> * @Date: Created on 2020&#x2F;4&#x2F;4 20:07 星期六</span><br><span class="line"> * @Description: com.csw.queue</span><br><span class="line"> * @version: 1.0</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class CircleArrayQueueDemo &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        &#x2F;&#x2F;测试数组模拟环形队列</span><br><span class="line">        CircleQueue queue&#x3D; new CircleQueue(4);</span><br><span class="line">        char key&#x3D;&#39; &#39;; &#x2F;&#x2F;接收用户输入</span><br><span class="line">        Scanner scanner &#x3D; new Scanner(System.in);</span><br><span class="line">        boolean loop&#x3D;true;</span><br><span class="line">        &#x2F;&#x2F;输出一个菜单</span><br><span class="line">        while(loop)&#123;</span><br><span class="line">            System.out.println(&quot;s(show):显示队列&quot;);</span><br><span class="line">            System.out.println(&quot;e(exit):退出程序&quot;);</span><br><span class="line">            System.out.println(&quot;a(add):添加队列&quot;);</span><br><span class="line">            System.out.println(&quot;g(get):从队列取出数据&quot;);</span><br><span class="line">            System.out.println(&quot;h(head):查看队列头的数据&quot;);</span><br><span class="line">            key&#x3D;scanner.next().charAt(0); &#x2F;&#x2F;接收一个字符</span><br><span class="line">            switch (key)&#123;</span><br><span class="line">                case &#39;s&#39;:</span><br><span class="line">                    queue.showQueue();</span><br><span class="line">                    break;</span><br><span class="line">                case &#39;a&#39;:</span><br><span class="line">                    System.out.println(&quot;输入一个数字&quot;);</span><br><span class="line">                    int value&#x3D;scanner.nextInt();</span><br><span class="line">                    queue.addQueue(value);</span><br><span class="line">                    break;</span><br><span class="line">                case &#39;g&#39;: &#x2F;&#x2F;出去数据</span><br><span class="line">                    try&#123;</span><br><span class="line">                        int res&#x3D;queue.getQueue();</span><br><span class="line">                        System.out.printf(&quot;取出数据是%d&quot;,res);</span><br><span class="line">                    &#125;catch (Exception e)&#123;</span><br><span class="line">                        System.out.println(e.getMessage());</span><br><span class="line">                    &#125;</span><br><span class="line">                    break;</span><br><span class="line">                case &#39;h&#39;: &#x2F;&#x2F;出去数据</span><br><span class="line">                    try&#123;</span><br><span class="line">                        int res&#x3D;queue.headQueue();</span><br><span class="line">                        System.out.printf(&quot;队列的头数据是%d&quot;,res);</span><br><span class="line">                    &#125;catch (Exception e)&#123;</span><br><span class="line">                        System.out.println(e.getMessage());</span><br><span class="line">                    &#125;</span><br><span class="line">                    break;</span><br><span class="line">                case &#39;e&#39;: &#x2F;&#x2F;退出</span><br><span class="line">                    scanner.close();</span><br><span class="line">                    loop&#x3D;false;</span><br><span class="line">                    break;</span><br><span class="line">                default:</span><br><span class="line">                    break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot;程序退出&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class CircleQueue&#123;</span><br><span class="line">    private int maxSize;  &#x2F;&#x2F;表示数组的最大容量</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;front 变量的含义做一个调整:front就指向队列的第一个元素,也就是arr[front]</span><br><span class="line">    &#x2F;&#x2F;front 的初始值为&#x3D;0</span><br><span class="line">    private int front; &#x2F;&#x2F;执行队列头</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;rear变量的含义做一个调整,rear指向队列的最后一个元素的后一个位置,因为希望空出一个位置</span><br><span class="line">    &#x2F;&#x2F;rear 的初始值为&#x3D;0</span><br><span class="line">    private int rear; &#x2F;&#x2F;队列尾</span><br><span class="line">    private int[] arr;&#x2F;&#x2F;该数据用于存放数据,模拟队列</span><br><span class="line"></span><br><span class="line">    public CircleQueue(int arrMaxSize) &#123;</span><br><span class="line">        maxSize&#x3D;arrMaxSize;</span><br><span class="line">        arr&#x3D;new int[maxSize];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;判断队列是否满</span><br><span class="line">    public boolean isFull()&#123;</span><br><span class="line">        return (rear+1)%maxSize&#x3D;&#x3D;front;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;判断队列是否为空</span><br><span class="line">    public boolean isEmpty()&#123;</span><br><span class="line">        return rear&#x3D;&#x3D;front;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;填加数据</span><br><span class="line">    public void addQueue(int n)&#123;</span><br><span class="line">        &#x2F;&#x2F;判断队列是否满</span><br><span class="line">        if(isFull())&#123;</span><br><span class="line">            System.out.println(&quot;队列满,不能加入数据~&quot;);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;直接将数据加入</span><br><span class="line">        arr[rear]&#x3D;n;</span><br><span class="line">        &#x2F;&#x2F;将rear后移,这里必须取模</span><br><span class="line">        rear&#x3D;(rear+1)%maxSize;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;获取队列的数据,出队列</span><br><span class="line">    public  int getQueue()&#123;</span><br><span class="line">        &#x2F;&#x2F;判断队列是否为空</span><br><span class="line">        if(isEmpty())&#123;</span><br><span class="line">            &#x2F;&#x2F;通过抛出异常</span><br><span class="line">            throw  new RuntimeException(&quot;队列空,不能取数据&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;这里需要分析front是指向队列的第一个元素</span><br><span class="line">        &#x2F;&#x2F;1.先把front对应的值保留到一个临时变量</span><br><span class="line">        &#x2F;&#x2F;2.将front后移，考虑取余</span><br><span class="line">        &#x2F;&#x2F;3.将零时的变量返回</span><br><span class="line">        int value&#x3D;arr[front];</span><br><span class="line">        front&#x3D;(front+1)%maxSize;</span><br><span class="line">        return value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;显示队列的所有数据</span><br><span class="line">    public void showQueue()&#123;</span><br><span class="line">        &#x2F;&#x2F;遍历</span><br><span class="line">        if(isEmpty())&#123;</span><br><span class="line">            System.out.println(&quot;队列空的,没有数据&quot;);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        for(int i&#x3D;front;i&lt;front+size();i++)&#123;</span><br><span class="line">            System.out.printf(&quot;arr[%d]&#x3D;%d\n&quot;,i%maxSize,arr[i%maxSize]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;求出当前队列的有效数据个数</span><br><span class="line">    public int size()&#123;</span><br><span class="line"></span><br><span class="line">        return (rear+maxSize-front)%maxSize;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;显示队列的头数据</span><br><span class="line">    public int headQueue()&#123;</span><br><span class="line">        &#x2F;&#x2F;判断</span><br><span class="line">        if(isEmpty())&#123;</span><br><span class="line">            throw new RuntimeException(&quot;队列为空,没有数据&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        return arr[front];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;数据结构之队列&quot;&gt;&lt;a href=&quot;#数据结构之队列&quot; class=&quot;headerlink&quot; title=&quot;数据结构之队列&quot;&gt;&lt;/a&gt;数据结构之队列&lt;/h1&gt;&lt;h2 id=&quot;队列介绍&quot;&gt;&lt;a href=&quot;#队列介绍&quot; class=&quot;headerlink&quot; titl
      
    
    </summary>
    
    
      <category term="数据结构" scheme="https://todcsw.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="学习" scheme="https://todcsw.github.io/tags/%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="java" scheme="https://todcsw.github.io/tags/java/"/>
    
      <category term="数据结构" scheme="https://todcsw.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>mysql存储过程</title>
    <link href="https://todcsw.github.io/2020/04/07/mysql%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B/"/>
    <id>https://todcsw.github.io/2020/04/07/mysql%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B/</id>
    <published>2020-04-07T01:22:36.000Z</published>
    <updated>2020-04-07T06:26:06.539Z</updated>
    
    <content type="html"><![CDATA[<h1 id="认识MySQL存储过程"><a href="#认识MySQL存储过程" class="headerlink" title="认识MySQL存储过程"></a>认识MySQL存储过程</h1><p>MySQL 5.0 版本开始支持存储过程。</p><p>存储过程（Stored Procedure）是一种在数据库中存储复杂程序，以便外部程序调用的一种数据库对象。</p><p>存储过程是为了完成特定功能的SQL语句集，经编译创建并保存在数据库中，用户可通过指定存储过程的名字并给定参数(需要时)来调用执行。</p><p>存储过程思想上很简单，就是数据库 SQL 语言层面的代码封装与重用。</p><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><ul><li>存储过程可封装，并隐藏复杂的商业逻辑。</li><li>存储过程可以回传值，并可以接受参数。</li><li>存储过程无法使用 SELECT 指令来运行，因为它是子程序，与查看表，数据表或用户定义函数不同。</li><li>存储过程可以用在数据检验，强制实行商业逻辑等。</li></ul><h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><ul><li>存储过程，往往定制化于特定的数据库上，因为支持的编程语言不同。当切换到其他厂商的数据库系统时，需要重写原有的存储过程。</li><li>存储过程的性能调校与撰写，受限于各种数据库系统。</li></ul><h1 id="存储过程的创建和调用"><a href="#存储过程的创建和调用" class="headerlink" title="存储过程的创建和调用"></a>存储过程的创建和调用</h1><p>存储过程就是具有名字的一段代码，用来完成一个特定的功能。<br>创建的存储过程保存在数据库的数据字典中。</p><h2 id="创建存储过程"><a href="#创建存储过程" class="headerlink" title="创建存储过程"></a>创建存储过程</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DELIMITER $$</span><br><span class="line">CREATE PROCEDURE insert_student(IN id INT,IN name VARCHAR(20),IN sex VARCHAR(3))</span><br><span class="line">BEGIN</span><br><span class="line">INSERT INTO xs VALUES(id,name,sex);</span><br><span class="line">END $$</span><br><span class="line">DELIMITER;</span><br></pre></td></tr></table></figure><p>##掉用存储过程</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CALL insert_student(1,&quot;陈&quot;,&quot;男&quot;);</span><br><span class="line">CALL insert_student(2,&quot;撒&quot;,&quot;女&quot;);</span><br><span class="line">&#x2F;&#x2F;调用完成后向student表插入 了两条数据</span><br></pre></td></tr></table></figure><h1 id="mysql存储过程的关键语法"><a href="#mysql存储过程的关键语法" class="headerlink" title="mysql存储过程的关键语法"></a>mysql存储过程的关键语法</h1><h2 id="声明语句结束符-可以自己定义"><a href="#声明语句结束符-可以自己定义" class="headerlink" title="声明语句结束符,可以自己定义"></a>声明语句结束符,可以自己定义</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DELIMITER $$</span><br><span class="line">或</span><br><span class="line">DELIMITER &#x2F;&#x2F;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;认识MySQL存储过程&quot;&gt;&lt;a href=&quot;#认识MySQL存储过程&quot; class=&quot;headerlink&quot; title=&quot;认识MySQL存储过程&quot;&gt;&lt;/a&gt;认识MySQL存储过程&lt;/h1&gt;&lt;p&gt;MySQL 5.0 版本开始支持存储过程。&lt;/p&gt;
&lt;p&gt;存储过程（
      
    
    </summary>
    
    
      <category term="mysql" scheme="https://todcsw.github.io/categories/mysql/"/>
    
    
      <category term="学习" scheme="https://todcsw.github.io/tags/%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="mysql" scheme="https://todcsw.github.io/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>使用hexo+nodejs+github搭建博客教程</title>
    <link href="https://todcsw.github.io/2020/04/03/%E4%BD%BF%E7%94%A8hexo-nodejs-github%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E6%95%99%E7%A8%8B/"/>
    <id>https://todcsw.github.io/2020/04/03/%E4%BD%BF%E7%94%A8hexo-nodejs-github%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E6%95%99%E7%A8%8B/</id>
    <published>2020-04-03T11:22:36.000Z</published>
    <updated>2020-04-04T05:32:57.538Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>我个人用了差不多一天的时间,搭建出来hexo+nodejs+github的个人博客网站,其中出现了无次数的错误和坑.但也在我的坚持下,不断的百度,思考和请教别人终于完成了。<br>其中也有过无次数的想放弃,但是我都坚持下来了。接下来为许多新手提供一个教程,不管你在后面遇到了什么困难都希望你能够坚持下来。</p><h1 id="安装相应软件"><a href="#安装相应软件" class="headerlink" title="安装相应软件"></a>安装相应软件</h1><h2 id="安装git"><a href="#安装git" class="headerlink" title="安装git"></a>安装git</h2><p>一  .Git是目前世界上最先进的分布式版本控制系统，可以有效、高速的处理从很小到非常大的项目版本管理。也就是用来管理你的hexo博客文章，上传到GitHub的工具。Git非常强大，我觉得建议每个人都去了解一下。<br>二  .windows:到git官网上下载, <a href="https://gitforwindows.org" target="_blank" rel="noopener">download git</a>,下载后会有一个Git Bash的命令行工具，以后就用这个工具来使用git.<a href="https://www.liaoxuefeng.com/wiki/896043488029600" target="_blank" rel="noopener">git教程</a><br>三  .安装好后，用git –version 来查看一下版本</p><h2 id="安装nodejs"><a href="#安装nodejs" class="headerlink" title="安装nodejs"></a>安装nodejs</h2><p>一  .Hexo是基于nodeJS编写的，所以需要安装一下nodeJs和里面的npm工具。<br>二  .windows:<a href="https://nodejs.org/en/download/" target="_blank" rel="noopener">nodejs下载</a>选择LTS版本就行了。<br>三  .安装完后，打开命令行输入如下命令</p><pre><code>node -vnpm -v</code></pre><p>四  .检查一下有没有安装成功,顺便说一下，windows在git安装完后，就可以直接使用git bash来敲命令行了，不用自带的cmd，cmd有点难用。<br>五  .配置一下环境变量,请查看目录2.3 的第八条内容</p><h2 id="安装hexo"><a href="#安装hexo" class="headerlink" title="安装hexo"></a>安装hexo</h2><p>一  .先创建一个文件夹blog，然后cd到这个文件夹下（或者在这个文件夹下直接右键git bash打开）。<br>二  .输入如下命令</p><pre><code>npm install -g hexo-cli</code></pre><p>三  .依旧用hexo -v查看一下版本,如果显示以下内容则代表成功。</p><p><img src="/" class="lazyload" data-src="/images/hexo%E5%AE%89%E8%A3%85%E6%88%90%E5%8A%9F.jpg"  alt=""></p><p>四  .如果上述不显示版本号则可能出现错误,按照以下内容配置</p><pre><code>npm config set prefix (设置全局目录)</code></pre><p>我输入到git中的命令如下:  因为我的blog是创建在d:\陈圣文\ 下的,所以设置如下这样.</p><pre><code>npm config set D:\陈圣文\blog</code></pre><p>并再次安装</p><pre><code>npm install -g hexo-cli</code></pre><p>完成后依旧用hexo -v查看一下版本<br>如果出现其他错误,请自行百度。<br>五  .接下来初始化一下hexo</p><pre><code>hexo init myblog</code></pre><p>六  .这个myblog可以自己取什么名字都行，myblog会生成在blog目录中</p><pre><code>cd myblog //进入这个myblog文件夹npm install</code></pre><p>七  .新建完成后，指定文件夹目录下有：</p><ul><li>node_modules: 依赖包</li><li>public：存放生成的页面</li><li>scaffolds：生成文章的一些模板</li><li>source：用来存放你的文章</li><li>themes：主题</li><li>_config.yml: 博客的配置文件**</li></ul><p>八  .设置如下系统环境变量</p><p><img src="/" class="lazyload" data-src="/images/%E7%B3%BB%E7%BB%9F%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E9%85%8D%E7%BD%AE.jpg"  alt=""></p><p>九  .输入如下命令</p><pre><code>hexo ghexo server</code></pre><p>十  .打开hexo的服务，在浏览器输入localhost:4000就可以看到你生成的博客了。</p><h1 id="github搭建个人仓库"><a href="#github搭建个人仓库" class="headerlink" title="github搭建个人仓库"></a>github搭建个人仓库</h1><h2 id="创建仓库"><a href="#创建仓库" class="headerlink" title="创建仓库"></a>创建仓库</h2><ul><li>首先，你先要有一个GitHub账户，去注册一个吧。</li><li>注册完登录后，在GitHub.com中看到一个New repository，新建仓库</li><li>创建一个和你用户名相同的仓库，后面加.github.io，只有这样，将来要部署到GitHub page的时候，才会被识别，也就是xxxx.github.io，其中xxx就是你注册GitHub的用户名。我这里是已经建过了。</li><li>点击create repository。</li></ul><h2 id="生成SSH添加到GitHub"><a href="#生成SSH添加到GitHub" class="headerlink" title="生成SSH添加到GitHub"></a>生成SSH添加到GitHub</h2><pre><code>git config --global user.name &quot;yourname&quot;git config --global user.email &quot;youremail&quot;</code></pre><p>这里的yourname输入你的GitHub用户名，youremail输入你GitHub的邮箱。这样GitHub才能知道你是不是对应它的账户。<br>可以用以下两条，检查一下你有没有输对</p><pre><code>git config user.namegit config user.email</code></pre><p>然后创建SSH,一路回车</p><pre><code>ssh-keygen -t rsa -C &quot;youremail&quot;</code></pre><p>这个时候它会告诉你已经生成了.ssh的文件夹。在你的电脑中找到这个文件夹。<br>例如我的.ssh文件夹在这个文件夹下 </p><pre><code>C:\Users\行路\.ssh</code></pre><p>ssh,就是一个秘钥，其中，id_rsa是你电脑的私人密钥,不能给别人看。id_rsa.pub是公共秘钥，可以随便给别人看。把这个公钥放在GitHub上，这样当你链接GitHub自己的账户时，它就会根据公钥匹配你的私钥，当能够相互匹配时，才能够顺利的通过git上传你的文件到GitHub上。<br>而后在GitHub的setting中，找到SSH keys的设置选项，点击New SSH key<br>把你的id_rsa.pub里面的信息复制进去。</p><p>在gitbash中，查看是否成功</p><pre><code>ssh -T git@github.com</code></pre><h1 id="将hexo部署到GitHub"><a href="#将hexo部署到GitHub" class="headerlink" title="将hexo部署到GitHub"></a>将hexo部署到GitHub</h1><h2 id="hexo和GitHub关联起来"><a href="#hexo和GitHub关联起来" class="headerlink" title="hexo和GitHub关联起来"></a>hexo和GitHub关联起来</h2><p>将hexo生成的文章部署到GitHub上，打开myblog下的(即站点配置文件)文件 _config.yml，翻到最后，修改为<br>YourgithubName就是你的GitHub账户</p><pre><code>deploy:  type: git  repo: https://github.com/YourgithubName/YourgithubName.github.io.git  branch: master</code></pre><h2 id="命令部署到GitHub"><a href="#命令部署到GitHub" class="headerlink" title="命令部署到GitHub"></a>命令部署到GitHub</h2><p>这个时候需要先安装deploy-git ，也就是部署的命令,这样你才能用命令部署到GitHub。</p><pre><code>npm install hexo-deployer-git --savehexo clean #清除本地myblog下的public文件夹下内容hexo generate #再次生成 public下的内容(包含首页的html)hexo deploy #上传到github上</code></pre><p>其中 hexo clean清除了你之前生成的东西，也可以不加。<br>hexo generate 顾名思义，生成静态文章，可以用 hexo g缩写<br>hexo deploy 部署文章，可以用hexo d缩写<br>注意deploy时可能要你输入username和password。<br>过一会儿就可以在<a href="http://yourname.github.io" target="_blank" rel="noopener">http://yourname.github.io</a> 这个网站看到你的博客了！！如果看到正确的页面显示就代表部署成功。</p><h1 id="设置个人域名"><a href="#设置个人域名" class="headerlink" title="设置个人域名"></a>设置个人域名</h1><p>现在你的个人网站的地址是yourname.github.io，如果觉得这个网址逼格不太够，这就需要你设置个人域名了。但是需要花钱。因为我本人并没有设置个人域名去访问,所以这方面的问题我就不再赘述,请自行百度。</p><h1 id="hexo的基本配置"><a href="#hexo的基本配置" class="headerlink" title="hexo的基本配置"></a>hexo的基本配置</h1><h2 id="下载主题"><a href="#下载主题" class="headerlink" title="下载主题"></a>下载主题</h2><p>在文件根目录(myblog)下的_config.yml,就是整个hexo框架的配置文件了。可以在里面修改大部分的配置。详细可参考<a href="https://hexo.io/zh-cn/docs/configuration" target="_blank" rel="noopener">官方的配置</a>描述.<br><a href="https://hexo.io/zh-cn/" target="_blank" rel="noopener">点击官网选择合适主题</a>进入以后点击主题,然后进入到该主题,该主题的博主在里面提供一个github下载地址(自己找一下地方,因为每一个主题放置下载地址位置不一样)。进入到github下载,点击下载或者clone<br>如果自己觉得下载慢,可以转到码云上下载,具体方法自己百度。主题的文件夹下内容如下</p><p><img src="/" class="lazyload" data-src="/images/config2.jpg"  alt=""></p><h2 id="更换主题"><a href="#更换主题" class="headerlink" title="更换主题"></a>更换主题</h2><p>下载完以后将下载后的文件夹拷贝到 (以我自己举例)myblog\themes\下<br>然后进入到myblog下的_config.yml下,更改如下</p><pre><code>theme: butterfly #(butterfly把这个更改为自己下载的主题文件夹名字)</code></pre><p>Hexo更改主题后启动服务器，</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo clean </span><br><span class="line">hexo g #在本地生成</span><br><span class="line">hexo d #上传到github上去</span><br><span class="line">#然后访问xxx.github.io 可以看到自己的博客了xxx是自己的github账户的名称</span><br></pre></td></tr></table></figure><p>如果界面显如下字符:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">extends includes&#x2F;layout.pug block content include includes&#x2F;recent-posts.pug include includes&#x2F;partial</span><br></pre></td></tr></table></figure><p>执行如下命令</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install --save hexo-renderer-jade hexo-generator-feed hexo-generator-sitemap hexo-browsersync hexo-generator-archive</span><br><span class="line">#然后再执行后查看</span><br><span class="line">hexo clean </span><br><span class="line">hexo g #在本地生成</span><br><span class="line">hexo d #上传到github上去</span><br></pre></td></tr></table></figure><h2 id="修改博客名称"><a href="#修改博客名称" class="headerlink" title="修改博客名称"></a>修改博客名称</h2><p>更改myblog下的_config.yml,更改如下,按照我的配置更改自己的</p><p><img src="/" class="lazyload" data-src="/images/config1.jpg"  alt=""></p><h1 id="博客的基本配置"><a href="#博客的基本配置" class="headerlink" title="博客的基本配置"></a>博客的基本配置</h1><p>站点配置文件_config.yml是hexo工作目录下的主配置文件(还不知道在哪里的自己重新看上面,这是博客下的)<br>以我自己主题为例butterfly.yml是Butterfly的配置文件,它需要你将主题下的_config.yml(主题下的,看清楚)文件 复制到工作目录下(myblog)下的source/_data/butterfly.yml,如果文件或者文件夹,不存在,自己创建。(言简意赅的意思就是把主题下的_config.yml,复制到上述的文件夹,重命名为butterfly.yml)</p><h2 id="更改菜单栏"><a href="#更改菜单栏" class="headerlink" title="更改菜单栏"></a>更改菜单栏</h2><p>butterfly.yml下,当然我觉得如果没有配置这个文件夹,在主题下的_config.yml文件下更改也是没有问题的<br>如果自己不了解yml的文件格式,自行百度。更改butterfly.yml如下内容</p>{% menu:  首页: / || fa fa-home  时间轴: /archives/ || fa fa-archive  标签: /tags/ || fa fa-tags  目录: /categories/ || fa fa-folder-open  友情链接: /link/ || fa fa-link  关于: /about/ || fa fa-heart  清单||fa fa-list:- 音乐 || /music/ || fa fa-music- 电影 || /movies/ || fa fa-film- 照片 || /gallery/ || fa fa-picture-o %}<h2 id="新建与菜单匹配的页面"><a href="#新建与菜单匹配的页面" class="headerlink" title="新建与菜单匹配的页面"></a>新建与菜单匹配的页面</h2><p>在myblog中右键(Git bash here)  (记住以后部署到github上也是在这个地方git bash here)<br>输入</p><pre><code>hexo new page tags</code></pre><p>你会找到source/tags/index.md这个文件<br>修改这个文件如下</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: 标签</span><br><span class="line">date: 2020-04-03 09:45:22</span><br><span class="line">type: &quot;tags&quot;</span><br><span class="line">---</span><br></pre></td></tr></table></figure><p>以此类推</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo new page categories</span><br><span class="line">hexo new page link</span><br><span class="line">hexo new page about</span><br><span class="line">hexo new page music #等,仿照上面的去修改生成的文件,如果运行到网页出现乱码,将这些生成的.md文件编码格式保存为utf-8</span><br></pre></td></tr></table></figure><h2 id="查看blog"><a href="#查看blog" class="headerlink" title="查看blog"></a>查看blog</h2><h3 id="在本地查看"><a href="#在本地查看" class="headerlink" title="在本地查看"></a>在本地查看</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo s --debugger</span><br><span class="line">#然后在网页中访问localhost:4000 </span><br><span class="line">#可以看到自己的blog,如果访问不了自行百度</span><br></pre></td></tr></table></figure><h3 id="部署到github上查看"><a href="#部署到github上查看" class="headerlink" title="部署到github上查看"></a>部署到github上查看</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo g #在本地生成</span><br><span class="line">hexo d #上传到github上去</span><br><span class="line">#其实上面已经介绍到了这些命令,期间可能会让你输入自己的github账号和密码</span><br></pre></td></tr></table></figure><p>然后访问xxx.github.io 可以看到自己的博客了xxx是自己的github账户的名称</p><h1 id="主题的具体样式配置"><a href="#主题的具体样式配置" class="headerlink" title="主题的具体样式配置"></a>主题的具体样式配置</h1><p>主题的具体配置我就不一一列举了<br>详情请访问以我这个主题为例写的说明文档，如果想配置的好看点,请仔细查看<br><a href="https://jerryc.me/posts/4aa8abbe/#%E8%AA%9E%E8%A8%80" target="_blank" rel="noopener">说明文档</a><br>这是这个主题<a href="https://jerryc.me/" target="_blank" rel="noopener">创建者的博客</a><br>这里是整个hexo 的<a href="https://hexo.io/zh-cn/docs/index.html" target="_blank" rel="noopener">说明文档</a><br>里面接收了怎样 使用 操作 部署</p><h1 id="写博客"><a href="#写博客" class="headerlink" title="写博客"></a>写博客</h1><h2 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo new [layout] &lt;title&gt;</span><br><span class="line"></span><br><span class="line">#layout默认是post直接发布</span><br><span class="line">#会在source&#x2F;_posts下生成一个&lt;title&gt;.md命名的博客,采用markdown的语法写作</span><br></pre></td></tr></table></figure><h2 id="写作"><a href="#写作" class="headerlink" title="写作"></a>写作</h2><p>以我的为一个小小的例子</p><p><img src="/" class="lazyload" data-src="/images/config3.jpg"  alt=""></p><h2 id="发布"><a href="#发布" class="headerlink" title="发布"></a>发布</h2><h3 id="本地先查看"><a href="#本地先查看" class="headerlink" title="本地先查看"></a>本地先查看</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo s --debugger</span><br></pre></td></tr></table></figure><p>访问localhost:4000在本地查看,如果再本地写的博客,没有目录,发布到github上访问会显示目录的。</p><h3 id="发布到github上"><a href="#发布到github上" class="headerlink" title="发布到github上"></a>发布到github上</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo g</span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure><p>访问自己的xxx.github.io即可,别人访问的就是这个</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;我个人用了差不多一天的时间,搭建出来hexo+nodejs+github的个人博客网站,其中出现了无次数的错误和坑.但也在我的坚持下,不断的
      
    
    </summary>
    
    
      <category term="教程" scheme="https://todcsw.github.io/categories/%E6%95%99%E7%A8%8B/"/>
    
    
      <category term="教程" scheme="https://todcsw.github.io/tags/%E6%95%99%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="https://todcsw.github.io/2020/04/02/hello-world/"/>
    <id>https://todcsw.github.io/2020/04/02/hello-world/</id>
    <published>2020-04-02T13:39:51.005Z</published>
    <updated>2020-04-02T13:39:51.005Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.
      
    
    </summary>
    
    
    
  </entry>
  
</feed>
