<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>圣文のblog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://todcsw.github.io/"/>
  <updated>2020-04-10T15:27:55.120Z</updated>
  <id>https://todcsw.github.io/</id>
  
  <author>
    <name>Todcsw</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>稀疏数组和普通数组的转换</title>
    <link href="https://todcsw.github.io/2020/04/10/%E7%A8%80%E7%96%8F%E6%95%B0%E7%BB%84%E5%92%8C%E6%99%AE%E9%80%9A%E6%95%B0%E7%BB%84%E7%9A%84%E8%BD%AC%E6%8D%A2/"/>
    <id>https://todcsw.github.io/2020/04/10/%E7%A8%80%E7%96%8F%E6%95%B0%E7%BB%84%E5%92%8C%E6%99%AE%E9%80%9A%E6%95%B0%E7%BB%84%E7%9A%84%E8%BD%AC%E6%8D%A2/</id>
    <published>2020-04-10T15:23:20.000Z</published>
    <updated>2020-04-10T15:27:55.120Z</updated>
    
    <content type="html"><![CDATA[<h1 id="稀疏数组和普通数组的转换"><a href="#稀疏数组和普通数组的转换" class="headerlink" title="稀疏数组和普通数组的转换"></a>稀疏数组和普通数组的转换</h1><h2 id="废话不多说-直接上代码"><a href="#废话不多说-直接上代码" class="headerlink" title="废话不多说,直接上代码"></a>废话不多说,直接上代码</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package com.csw.sparse;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * @Auther: 行路</span><br><span class="line"> * @Date: Created on 2020&#x2F;4&#x2F;2 16:47 星期四</span><br><span class="line"> * @Description: com.csw  稀疏数组和普通数组的转换</span><br><span class="line"> * @version: 1.0</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class Sparsearray &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        &#x2F;&#x2F;创建一个原始的二维数组 11*11</span><br><span class="line">        &#x2F;&#x2F;0:表示没有棋子,1表示黑子,2表示蓝子</span><br><span class="line">        int[][] chessArr&#x3D;new int[11][11];</span><br><span class="line"></span><br><span class="line">        chessArr[1][2]&#x3D;1;</span><br><span class="line">        chessArr[2][3]&#x3D;2;</span><br><span class="line">        chessArr[4][5]&#x3D;2;</span><br><span class="line">        &#x2F;&#x2F;输出原始的二维数组</span><br><span class="line">        System.out.println(&quot;原始的二维数组&quot;);</span><br><span class="line">        for(int [] row:chessArr)&#123;</span><br><span class="line">            for(int a:row)&#123;</span><br><span class="line">                System.out.printf(&quot;%d\t&quot;,a);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(&quot;&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;将二维数组转换为稀疏数组的思想</span><br><span class="line">        &#x2F;&#x2F;1.先遍历二维数组 得到非0数据的个数</span><br><span class="line">        int sum&#x3D;0;</span><br><span class="line">        for(int i&#x3D;0;i&lt;11;i++)&#123;</span><br><span class="line">            for(int j&#x3D;0;j&lt;11;j++)&#123;</span><br><span class="line">                if(chessArr[i][j]!&#x3D;0)&#123;</span><br><span class="line">                    sum++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot;sum&#x3D;&quot;+sum);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;创建一个稀疏数组</span><br><span class="line">        int[][] sparseArray&#x3D;new int[sum+1][3];</span><br><span class="line">        &#x2F;&#x2F;给稀疏数组赋值</span><br><span class="line">        sparseArray[0][0]&#x3D;11;</span><br><span class="line">        sparseArray[0][1]&#x3D;11;</span><br><span class="line">        sparseArray[0][2]&#x3D;sum;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;遍历二维数组 将非0数据存放到稀疏数组</span><br><span class="line">        int count&#x3D;0; &#x2F;&#x2F;用于记录时第几个非0数据</span><br><span class="line">        for(int i&#x3D;0;i&lt;11;i++)&#123;</span><br><span class="line">            for(int j&#x3D;0;j&lt;11;j++)&#123;</span><br><span class="line">                if(chessArr[i][j]!&#x3D;0)&#123;</span><br><span class="line">                    count++;</span><br><span class="line">                   sparseArray[count][0]&#x3D;i;</span><br><span class="line">                   sparseArray[count][1]&#x3D;j;</span><br><span class="line">                   sparseArray[count][2]&#x3D;chessArr[i][j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 输出稀疏数组的形式</span><br><span class="line">        System.out.println(&quot;稀疏数组----&quot;);</span><br><span class="line">        for(int [] row:sparseArray)&#123;</span><br><span class="line">            for(int a:row)&#123;</span><br><span class="line">                System.out.printf(&quot;%d\t&quot;,a);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(&quot;&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;将稀疏数组-》恢复为原来的数组</span><br><span class="line">        &#x2F;**</span><br><span class="line">         * 1.先读取稀疏数组的第一行,根据第一行的数据,创建原始的二维数组</span><br><span class="line">         * 2.在读取稀疏数组后几行数据,并赋给原始的二维数组即可</span><br><span class="line">         *</span><br><span class="line">         *&#x2F;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;1.先读取稀疏数组的第一行,根据第一行的数据,创建原始的二维数组</span><br><span class="line">        int[][] chessArr2&#x3D;new int[sparseArray[0][0]][sparseArray[0][1]];</span><br><span class="line">        &#x2F;&#x2F;2.在读取稀疏数组后几行数据,并赋给原始的二维数组即可</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;从第二行开始</span><br><span class="line">        for(int i&#x3D;1;i&lt;&#x3D;sparseArray[0][2];i++)&#123;</span><br><span class="line">                chessArr2[sparseArray[i][0]][sparseArray[i][1]]&#x3D;sparseArray[i][2];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;输出恢复后的数组</span><br><span class="line">        System.out.println(&quot;恢复后的数组----&quot;);</span><br><span class="line">        for(int [] row:chessArr2)&#123;</span><br><span class="line">            for(int a:row)&#123;</span><br><span class="line">                System.out.printf(&quot;%d\t&quot;,a);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(&quot;&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行效果<br><img src="/" class="lazyload" data-src="/images/array.png"  alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;稀疏数组和普通数组的转换&quot;&gt;&lt;a href=&quot;#稀疏数组和普通数组的转换&quot; class=&quot;headerlink&quot; title=&quot;稀疏数组和普通数组的转换&quot;&gt;&lt;/a&gt;稀疏数组和普通数组的转换&lt;/h1&gt;&lt;h2 id=&quot;废话不多说-直接上代码&quot;&gt;&lt;a href=&quot;#废话
      
    
    </summary>
    
    
      <category term="数据结构" scheme="https://todcsw.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="学习" scheme="https://todcsw.github.io/tags/%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="java" scheme="https://todcsw.github.io/tags/java/"/>
    
      <category term="数据结构" scheme="https://todcsw.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>写实日记1</title>
    <link href="https://todcsw.github.io/2020/04/09/%E5%86%99%E5%AE%9E%E6%97%A5%E8%AE%B01/"/>
    <id>https://todcsw.github.io/2020/04/09/%E5%86%99%E5%AE%9E%E6%97%A5%E8%AE%B01/</id>
    <published>2020-04-09T15:05:36.000Z</published>
    <updated>2020-04-09T15:17:59.157Z</updated>
    
    <content type="html"><![CDATA[<h1 id="累且枯燥"><a href="#累且枯燥" class="headerlink" title="累且枯燥"></a>累且枯燥</h1><p>算了,活着挺好的<br><img src="/" class="lazyload" data-src="/images/1.jpg"  alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;累且枯燥&quot;&gt;&lt;a href=&quot;#累且枯燥&quot; class=&quot;headerlink&quot; title=&quot;累且枯燥&quot;&gt;&lt;/a&gt;累且枯燥&lt;/h1&gt;&lt;p&gt;算了,活着挺好的&lt;br&gt;&lt;img src=&quot;/&quot; class=&quot;lazyload&quot; data-src=&quot;/images/1.
      
    
    </summary>
    
    
      <category term="生活" scheme="https://todcsw.github.io/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="生活" scheme="https://todcsw.github.io/tags/%E7%94%9F%E6%B4%BB/"/>
    
  </entry>
  
  <entry>
    <title>java实现循环队列</title>
    <link href="https://todcsw.github.io/2020/04/09/java%E5%AE%9E%E7%8E%B0%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%88%97/"/>
    <id>https://todcsw.github.io/2020/04/09/java%E5%AE%9E%E7%8E%B0%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%88%97/</id>
    <published>2020-04-09T14:40:36.000Z</published>
    <updated>2020-04-09T15:03:55.420Z</updated>
    
    <content type="html"><![CDATA[<h1 id="数据结构之队列"><a href="#数据结构之队列" class="headerlink" title="数据结构之队列"></a>数据结构之队列</h1><h2 id="队列介绍"><a href="#队列介绍" class="headerlink" title="队列介绍"></a>队列介绍</h2><h3 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h3><p>队列是一种特殊的线性表，特殊之处在于它只允许在表的前端（front）进行删除操作，而在表的后端（rear）进行插入操作，和栈一样，队列是一种操作受限制的线性表。进行插入操作的端称为队尾，进行删除操作的端称为队头。队列中没有元素时，称为空队列。<br>队列的数据元素又称为队列元素。在队列中插入一个队列元素称为入队，从队列中删除一个队列元素称为出队。因为队列只允许在一端插入，在另一端删除，所以只有最早进入队列的元素才能最先从队列中删除，故队列又称为先进先出（FIFO—first in first out）线性表。</p><h3 id="顺序队列"><a href="#顺序队列" class="headerlink" title="顺序队列"></a>顺序队列</h3><p>建立顺序队列结构必须为其静态分配或动态申请一片连续的存储空间，并设置两个指针进行管理。一个是队头指针front，它指向队头元素；另一个是队尾指针rear，它指向下一个入队元素的存储位置，如图所示<br>每次在队尾插入一个元素是，rear增1；每次在队头删除一个元素时，front增1。随着插入和删除操作的进行，队列元素的个数不断变化，队列所占的存储空间也在为队列结构所分配的连续空间中移动。当front=rear时，队列中没有任何元素，称为空队列。当rear增加到指向分配的连续空间之外时，队列无法再插入新元素，但这时往往还有大量可用空间未被占用，这些空间是已经出队的队列元素曾经占用过得存储单元。</p><h3 id="循环队列"><a href="#循环队列" class="headerlink" title="循环队列"></a>循环队列</h3><p>在实际使用队列时，为了使队列空间能重复使用，往往对队列的使用方法稍加改进：无论插入或删除，一旦rear指针增1或front指针增1 时超出了所分配的队列空间，就让它指向这片连续空间的起始位置。自己真从MaxSize-1增1变到0，可用取余运算rear%MaxSize和front%MaxSize来实现。这实际上是把队列空间想象成一个环形空间，环形空间中的存储单元循环使用，用这种方法管理的队列也就称为循环队列。除了一些简单应用之外，真正实用的队列是循环队列。<br><img src="/" class="lazyload" data-src="/images/queue.png"  alt=""></p><h2 id="普通顺序队列"><a href="#普通顺序队列" class="headerlink" title="普通顺序队列"></a>普通顺序队列</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package com.csw.queue;</span><br><span class="line"></span><br><span class="line">import java.util.Scanner;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * @Auther: 行路</span><br><span class="line"> * @Date: Created on 2020&#x2F;4&#x2F;2 19:16 星期四</span><br><span class="line"> * @Description: com.csw.queue 使用数组模拟队列</span><br><span class="line"> * @version: 1.0</span><br><span class="line"> *&#x2F;</span><br><span class="line"></span><br><span class="line">public class ArrayQueueDemo &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        &#x2F;&#x2F;创建一个队列</span><br><span class="line">       ArrayQueue queue&#x3D; new ArrayQueue(3);</span><br><span class="line">        char key&#x3D;&#39; &#39;;&#x2F;&#x2F;接收用户输入</span><br><span class="line">        Scanner scanner &#x3D; new Scanner(System.in);</span><br><span class="line">        boolean loop&#x3D;true;</span><br><span class="line">        &#x2F;&#x2F;输出一个菜单</span><br><span class="line">        while(loop)&#123;</span><br><span class="line">            System.out.println(&quot;s(show):显示队列&quot;);</span><br><span class="line">            System.out.println(&quot;e(exit):退出程序&quot;);</span><br><span class="line">            System.out.println(&quot;a(add):添加队列&quot;);</span><br><span class="line">            System.out.println(&quot;g(get):从队列取出数据&quot;);</span><br><span class="line">            System.out.println(&quot;h(head):查看队列头的数据&quot;);</span><br><span class="line">            key&#x3D;scanner.next().charAt(0); &#x2F;&#x2F;接收一个字符</span><br><span class="line">            switch (key)&#123;</span><br><span class="line">                case &#39;s&#39;:</span><br><span class="line">                    queue.showQueue();</span><br><span class="line">                    break;</span><br><span class="line"></span><br><span class="line">                case &#39;a&#39;:</span><br><span class="line">                    System.out.println(&quot;输入一个数字&quot;);</span><br><span class="line">                    int value&#x3D;scanner.nextInt();</span><br><span class="line">                    queue.addQueue(value);</span><br><span class="line">                    break;</span><br><span class="line">                case &#39;g&#39;: &#x2F;&#x2F;出去数据</span><br><span class="line">                    try&#123;</span><br><span class="line">                        int res&#x3D;queue.getQueue();</span><br><span class="line">                        System.out.printf(&quot;取出数据是%d&quot;,res);</span><br><span class="line">                    &#125;catch (Exception e)&#123;</span><br><span class="line">                        System.out.println(e.getMessage());</span><br><span class="line">                    &#125;</span><br><span class="line">                    break;</span><br><span class="line">                case &#39;h&#39;: &#x2F;&#x2F;出去数据</span><br><span class="line">                    try&#123;</span><br><span class="line">                        int res&#x3D;queue.headQueue();</span><br><span class="line">                        System.out.printf(&quot;队列的头数据是%d&quot;,res);</span><br><span class="line">                    &#125;catch (Exception e)&#123;</span><br><span class="line">                        System.out.println(e.getMessage());</span><br><span class="line">                    &#125;</span><br><span class="line">                    break;</span><br><span class="line">                case &#39;e&#39;: &#x2F;&#x2F;退出</span><br><span class="line">                    scanner.close();</span><br><span class="line">                    loop&#x3D;false;</span><br><span class="line">                    break;</span><br><span class="line">                default:</span><br><span class="line">                    break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot;程序退出&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;使用数组模拟队列-编写一个ArrayQueue类</span><br><span class="line">class ArrayQueue &#123;</span><br><span class="line">    private int maxSize;  &#x2F;&#x2F;表示数组的最大容量</span><br><span class="line">    private int front; &#x2F;&#x2F;执行队列头</span><br><span class="line">    private int rear; &#x2F;&#x2F;队列尾</span><br><span class="line">    private int[] arr;&#x2F;&#x2F;该数据用于存放数据,模拟队列</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;创建队列的一个构造器</span><br><span class="line">    public ArrayQueue(int arrMaxSize) &#123;</span><br><span class="line">        maxSize &#x3D; arrMaxSize;</span><br><span class="line">        arr &#x3D; new int[maxSize];</span><br><span class="line">        front &#x3D; -1; &#x2F;&#x2F;执行队列头部,分析出front时这指向队列头的前一个位置</span><br><span class="line">        rear &#x3D; -1; &#x2F;&#x2F;执行队列的尾部,即就是队列最后一个数据</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;判断队列是否慢</span><br><span class="line">    public boolean isFull() &#123;</span><br><span class="line">        return rear &#x3D;&#x3D; maxSize - 1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;判断队列是否为空</span><br><span class="line">    public boolean isEmpty() &#123;</span><br><span class="line">        return rear &#x3D;&#x3D; front;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;添加数据到队列</span><br><span class="line">    public void addQueue(int n) &#123;</span><br><span class="line">        &#x2F;&#x2F;判断队列是否慢</span><br><span class="line">        if (isFull()) &#123;</span><br><span class="line">            System.out.println(&quot;队列满,不能加入数据~&quot;);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        rear++;</span><br><span class="line">        arr[rear] &#x3D; n;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;数据出队列</span><br><span class="line">    public int getQueue() &#123;</span><br><span class="line">        &#x2F;&#x2F;判断是否为空</span><br><span class="line">        if (isEmpty()) &#123;</span><br><span class="line">            &#x2F;&#x2F;通过抛出异常</span><br><span class="line">            throw new RuntimeException(&quot;队列空,不能取数据&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        front++;</span><br><span class="line">        return arr[front];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;显示队列的所有数据</span><br><span class="line">    public void showQueue() &#123;</span><br><span class="line">        &#x2F;&#x2F;遍历数据</span><br><span class="line">        if (isEmpty()) &#123;</span><br><span class="line">            System.out.println(&quot;队列为空,没有数据~~~&quot;);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i &#x3D; 0; i &lt; arr.length; i++) &#123;</span><br><span class="line">            System.out.printf(&quot;arr[%d]&#x3D;%d\n&quot;, i, arr[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;显示队列头部数据,不是取出数据</span><br><span class="line"></span><br><span class="line">    public int headQueue() &#123;</span><br><span class="line">        &#x2F;&#x2F;判断</span><br><span class="line">        if (isEmpty()) &#123;</span><br><span class="line">            throw new RuntimeException(&quot;队列没有数据&quot;);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        return arr[front + 1];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="循环队列-1"><a href="#循环队列-1" class="headerlink" title="循环队列"></a>循环队列</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package com.csw.queue;</span><br><span class="line"></span><br><span class="line">import java.util.Scanner;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * @Auther: 行路</span><br><span class="line"> * @Date: Created on 2020&#x2F;4&#x2F;4 20:07 星期六</span><br><span class="line"> * @Description: com.csw.queue</span><br><span class="line"> * @version: 1.0</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class CircleArrayQueueDemo &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        &#x2F;&#x2F;测试数组模拟环形队列</span><br><span class="line">        CircleQueue queue&#x3D; new CircleQueue(4);</span><br><span class="line">        char key&#x3D;&#39; &#39;; &#x2F;&#x2F;接收用户输入</span><br><span class="line">        Scanner scanner &#x3D; new Scanner(System.in);</span><br><span class="line">        boolean loop&#x3D;true;</span><br><span class="line">        &#x2F;&#x2F;输出一个菜单</span><br><span class="line">        while(loop)&#123;</span><br><span class="line">            System.out.println(&quot;s(show):显示队列&quot;);</span><br><span class="line">            System.out.println(&quot;e(exit):退出程序&quot;);</span><br><span class="line">            System.out.println(&quot;a(add):添加队列&quot;);</span><br><span class="line">            System.out.println(&quot;g(get):从队列取出数据&quot;);</span><br><span class="line">            System.out.println(&quot;h(head):查看队列头的数据&quot;);</span><br><span class="line">            key&#x3D;scanner.next().charAt(0); &#x2F;&#x2F;接收一个字符</span><br><span class="line">            switch (key)&#123;</span><br><span class="line">                case &#39;s&#39;:</span><br><span class="line">                    queue.showQueue();</span><br><span class="line">                    break;</span><br><span class="line">                case &#39;a&#39;:</span><br><span class="line">                    System.out.println(&quot;输入一个数字&quot;);</span><br><span class="line">                    int value&#x3D;scanner.nextInt();</span><br><span class="line">                    queue.addQueue(value);</span><br><span class="line">                    break;</span><br><span class="line">                case &#39;g&#39;: &#x2F;&#x2F;出去数据</span><br><span class="line">                    try&#123;</span><br><span class="line">                        int res&#x3D;queue.getQueue();</span><br><span class="line">                        System.out.printf(&quot;取出数据是%d&quot;,res);</span><br><span class="line">                    &#125;catch (Exception e)&#123;</span><br><span class="line">                        System.out.println(e.getMessage());</span><br><span class="line">                    &#125;</span><br><span class="line">                    break;</span><br><span class="line">                case &#39;h&#39;: &#x2F;&#x2F;出去数据</span><br><span class="line">                    try&#123;</span><br><span class="line">                        int res&#x3D;queue.headQueue();</span><br><span class="line">                        System.out.printf(&quot;队列的头数据是%d&quot;,res);</span><br><span class="line">                    &#125;catch (Exception e)&#123;</span><br><span class="line">                        System.out.println(e.getMessage());</span><br><span class="line">                    &#125;</span><br><span class="line">                    break;</span><br><span class="line">                case &#39;e&#39;: &#x2F;&#x2F;退出</span><br><span class="line">                    scanner.close();</span><br><span class="line">                    loop&#x3D;false;</span><br><span class="line">                    break;</span><br><span class="line">                default:</span><br><span class="line">                    break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot;程序退出&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class CircleQueue&#123;</span><br><span class="line">    private int maxSize;  &#x2F;&#x2F;表示数组的最大容量</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;front 变量的含义做一个调整:front就指向队列的第一个元素,也就是arr[front]</span><br><span class="line">    &#x2F;&#x2F;front 的初始值为&#x3D;0</span><br><span class="line">    private int front; &#x2F;&#x2F;执行队列头</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;rear变量的含义做一个调整,rear指向队列的最后一个元素的后一个位置,因为希望空出一个位置</span><br><span class="line">    &#x2F;&#x2F;rear 的初始值为&#x3D;0</span><br><span class="line">    private int rear; &#x2F;&#x2F;队列尾</span><br><span class="line">    private int[] arr;&#x2F;&#x2F;该数据用于存放数据,模拟队列</span><br><span class="line"></span><br><span class="line">    public CircleQueue(int arrMaxSize) &#123;</span><br><span class="line">        maxSize&#x3D;arrMaxSize;</span><br><span class="line">        arr&#x3D;new int[maxSize];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;判断队列是否满</span><br><span class="line">    public boolean isFull()&#123;</span><br><span class="line">        return (rear+1)%maxSize&#x3D;&#x3D;front;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;判断队列是否为空</span><br><span class="line">    public boolean isEmpty()&#123;</span><br><span class="line">        return rear&#x3D;&#x3D;front;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;填加数据</span><br><span class="line">    public void addQueue(int n)&#123;</span><br><span class="line">        &#x2F;&#x2F;判断队列是否满</span><br><span class="line">        if(isFull())&#123;</span><br><span class="line">            System.out.println(&quot;队列满,不能加入数据~&quot;);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;直接将数据加入</span><br><span class="line">        arr[rear]&#x3D;n;</span><br><span class="line">        &#x2F;&#x2F;将rear后移,这里必须取模</span><br><span class="line">        rear&#x3D;(rear+1)%maxSize;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;获取队列的数据,出队列</span><br><span class="line">    public  int getQueue()&#123;</span><br><span class="line">        &#x2F;&#x2F;判断队列是否为空</span><br><span class="line">        if(isEmpty())&#123;</span><br><span class="line">            &#x2F;&#x2F;通过抛出异常</span><br><span class="line">            throw  new RuntimeException(&quot;队列空,不能取数据&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;这里需要分析front是指向队列的第一个元素</span><br><span class="line">        &#x2F;&#x2F;1.先把front对应的值保留到一个临时变量</span><br><span class="line">        &#x2F;&#x2F;2.将front后移，考虑取余</span><br><span class="line">        &#x2F;&#x2F;3.将零时的变量返回</span><br><span class="line">        int value&#x3D;arr[front];</span><br><span class="line">        front&#x3D;(front+1)%maxSize;</span><br><span class="line">        return value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;显示队列的所有数据</span><br><span class="line">    public void showQueue()&#123;</span><br><span class="line">        &#x2F;&#x2F;遍历</span><br><span class="line">        if(isEmpty())&#123;</span><br><span class="line">            System.out.println(&quot;队列空的,没有数据&quot;);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        for(int i&#x3D;front;i&lt;front+size();i++)&#123;</span><br><span class="line">            System.out.printf(&quot;arr[%d]&#x3D;%d\n&quot;,i%maxSize,arr[i%maxSize]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;求出当前队列的有效数据个数</span><br><span class="line">    public int size()&#123;</span><br><span class="line"></span><br><span class="line">        return (rear+maxSize-front)%maxSize;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;显示队列的头数据</span><br><span class="line">    public int headQueue()&#123;</span><br><span class="line">        &#x2F;&#x2F;判断</span><br><span class="line">        if(isEmpty())&#123;</span><br><span class="line">            throw new RuntimeException(&quot;队列为空,没有数据&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        return arr[front];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;数据结构之队列&quot;&gt;&lt;a href=&quot;#数据结构之队列&quot; class=&quot;headerlink&quot; title=&quot;数据结构之队列&quot;&gt;&lt;/a&gt;数据结构之队列&lt;/h1&gt;&lt;h2 id=&quot;队列介绍&quot;&gt;&lt;a href=&quot;#队列介绍&quot; class=&quot;headerlink&quot; titl
      
    
    </summary>
    
    
      <category term="数据结构" scheme="https://todcsw.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="学习" scheme="https://todcsw.github.io/tags/%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="java" scheme="https://todcsw.github.io/tags/java/"/>
    
      <category term="数据结构" scheme="https://todcsw.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>mysql存储过程</title>
    <link href="https://todcsw.github.io/2020/04/07/mysql%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B/"/>
    <id>https://todcsw.github.io/2020/04/07/mysql%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B/</id>
    <published>2020-04-07T01:22:36.000Z</published>
    <updated>2020-04-07T06:26:06.539Z</updated>
    
    <content type="html"><![CDATA[<h1 id="认识MySQL存储过程"><a href="#认识MySQL存储过程" class="headerlink" title="认识MySQL存储过程"></a>认识MySQL存储过程</h1><p>MySQL 5.0 版本开始支持存储过程。</p><p>存储过程（Stored Procedure）是一种在数据库中存储复杂程序，以便外部程序调用的一种数据库对象。</p><p>存储过程是为了完成特定功能的SQL语句集，经编译创建并保存在数据库中，用户可通过指定存储过程的名字并给定参数(需要时)来调用执行。</p><p>存储过程思想上很简单，就是数据库 SQL 语言层面的代码封装与重用。</p><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><ul><li>存储过程可封装，并隐藏复杂的商业逻辑。</li><li>存储过程可以回传值，并可以接受参数。</li><li>存储过程无法使用 SELECT 指令来运行，因为它是子程序，与查看表，数据表或用户定义函数不同。</li><li>存储过程可以用在数据检验，强制实行商业逻辑等。</li></ul><h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><ul><li>存储过程，往往定制化于特定的数据库上，因为支持的编程语言不同。当切换到其他厂商的数据库系统时，需要重写原有的存储过程。</li><li>存储过程的性能调校与撰写，受限于各种数据库系统。</li></ul><h1 id="存储过程的创建和调用"><a href="#存储过程的创建和调用" class="headerlink" title="存储过程的创建和调用"></a>存储过程的创建和调用</h1><p>存储过程就是具有名字的一段代码，用来完成一个特定的功能。<br>创建的存储过程保存在数据库的数据字典中。</p><h2 id="创建存储过程"><a href="#创建存储过程" class="headerlink" title="创建存储过程"></a>创建存储过程</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DELIMITER $$</span><br><span class="line">CREATE PROCEDURE insert_student(IN id INT,IN name VARCHAR(20),IN sex VARCHAR(3))</span><br><span class="line">BEGIN</span><br><span class="line">INSERT INTO xs VALUES(id,name,sex);</span><br><span class="line">END $$</span><br><span class="line">DELIMITER;</span><br></pre></td></tr></table></figure><p>##掉用存储过程</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CALL insert_student(1,&quot;陈&quot;,&quot;男&quot;);</span><br><span class="line">CALL insert_student(2,&quot;撒&quot;,&quot;女&quot;);</span><br><span class="line">&#x2F;&#x2F;调用完成后向student表插入 了两条数据</span><br></pre></td></tr></table></figure><h1 id="mysql存储过程的关键语法"><a href="#mysql存储过程的关键语法" class="headerlink" title="mysql存储过程的关键语法"></a>mysql存储过程的关键语法</h1><h2 id="声明语句结束符-可以自己定义"><a href="#声明语句结束符-可以自己定义" class="headerlink" title="声明语句结束符,可以自己定义"></a>声明语句结束符,可以自己定义</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DELIMITER $$</span><br><span class="line">或</span><br><span class="line">DELIMITER &#x2F;&#x2F;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;认识MySQL存储过程&quot;&gt;&lt;a href=&quot;#认识MySQL存储过程&quot; class=&quot;headerlink&quot; title=&quot;认识MySQL存储过程&quot;&gt;&lt;/a&gt;认识MySQL存储过程&lt;/h1&gt;&lt;p&gt;MySQL 5.0 版本开始支持存储过程。&lt;/p&gt;
&lt;p&gt;存储过程（
      
    
    </summary>
    
    
      <category term="mysql" scheme="https://todcsw.github.io/categories/mysql/"/>
    
    
      <category term="学习" scheme="https://todcsw.github.io/tags/%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="mysql" scheme="https://todcsw.github.io/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>使用hexo+nodejs+github搭建博客教程</title>
    <link href="https://todcsw.github.io/2020/04/03/%E4%BD%BF%E7%94%A8hexo-nodejs-github%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E6%95%99%E7%A8%8B/"/>
    <id>https://todcsw.github.io/2020/04/03/%E4%BD%BF%E7%94%A8hexo-nodejs-github%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E6%95%99%E7%A8%8B/</id>
    <published>2020-04-03T11:22:36.000Z</published>
    <updated>2020-04-04T05:32:57.538Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>我个人用了差不多一天的时间,搭建出来hexo+nodejs+github的个人博客网站,其中出现了无次数的错误和坑.但也在我的坚持下,不断的百度,思考和请教别人终于完成了。<br>其中也有过无次数的想放弃,但是我都坚持下来了。接下来为许多新手提供一个教程,不管你在后面遇到了什么困难都希望你能够坚持下来。</p><h1 id="安装相应软件"><a href="#安装相应软件" class="headerlink" title="安装相应软件"></a>安装相应软件</h1><h2 id="安装git"><a href="#安装git" class="headerlink" title="安装git"></a>安装git</h2><p>一  .Git是目前世界上最先进的分布式版本控制系统，可以有效、高速的处理从很小到非常大的项目版本管理。也就是用来管理你的hexo博客文章，上传到GitHub的工具。Git非常强大，我觉得建议每个人都去了解一下。<br>二  .windows:到git官网上下载, <a href="https://gitforwindows.org" target="_blank" rel="noopener">download git</a>,下载后会有一个Git Bash的命令行工具，以后就用这个工具来使用git.<a href="https://www.liaoxuefeng.com/wiki/896043488029600" target="_blank" rel="noopener">git教程</a><br>三  .安装好后，用git –version 来查看一下版本</p><h2 id="安装nodejs"><a href="#安装nodejs" class="headerlink" title="安装nodejs"></a>安装nodejs</h2><p>一  .Hexo是基于nodeJS编写的，所以需要安装一下nodeJs和里面的npm工具。<br>二  .windows:<a href="https://nodejs.org/en/download/" target="_blank" rel="noopener">nodejs下载</a>选择LTS版本就行了。<br>三  .安装完后，打开命令行输入如下命令</p><pre><code>node -vnpm -v</code></pre><p>四  .检查一下有没有安装成功,顺便说一下，windows在git安装完后，就可以直接使用git bash来敲命令行了，不用自带的cmd，cmd有点难用。<br>五  .配置一下环境变量,请查看目录2.3 的第八条内容</p><h2 id="安装hexo"><a href="#安装hexo" class="headerlink" title="安装hexo"></a>安装hexo</h2><p>一  .先创建一个文件夹blog，然后cd到这个文件夹下（或者在这个文件夹下直接右键git bash打开）。<br>二  .输入如下命令</p><pre><code>npm install -g hexo-cli</code></pre><p>三  .依旧用hexo -v查看一下版本,如果显示以下内容则代表成功。</p><p><img src="/" class="lazyload" data-src="/images/hexo%E5%AE%89%E8%A3%85%E6%88%90%E5%8A%9F.jpg"  alt=""></p><p>四  .如果上述不显示版本号则可能出现错误,按照以下内容配置</p><pre><code>npm config set prefix (设置全局目录)</code></pre><p>我输入到git中的命令如下:  因为我的blog是创建在d:\陈圣文\ 下的,所以设置如下这样.</p><pre><code>npm config set D:\陈圣文\blog</code></pre><p>并再次安装</p><pre><code>npm install -g hexo-cli</code></pre><p>完成后依旧用hexo -v查看一下版本<br>如果出现其他错误,请自行百度。<br>五  .接下来初始化一下hexo</p><pre><code>hexo init myblog</code></pre><p>六  .这个myblog可以自己取什么名字都行，myblog会生成在blog目录中</p><pre><code>cd myblog //进入这个myblog文件夹npm install</code></pre><p>七  .新建完成后，指定文件夹目录下有：</p><ul><li>node_modules: 依赖包</li><li>public：存放生成的页面</li><li>scaffolds：生成文章的一些模板</li><li>source：用来存放你的文章</li><li>themes：主题</li><li>_config.yml: 博客的配置文件**</li></ul><p>八  .设置如下系统环境变量</p><p><img src="/" class="lazyload" data-src="/images/%E7%B3%BB%E7%BB%9F%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E9%85%8D%E7%BD%AE.jpg"  alt=""></p><p>九  .输入如下命令</p><pre><code>hexo ghexo server</code></pre><p>十  .打开hexo的服务，在浏览器输入localhost:4000就可以看到你生成的博客了。</p><h1 id="github搭建个人仓库"><a href="#github搭建个人仓库" class="headerlink" title="github搭建个人仓库"></a>github搭建个人仓库</h1><h2 id="创建仓库"><a href="#创建仓库" class="headerlink" title="创建仓库"></a>创建仓库</h2><ul><li>首先，你先要有一个GitHub账户，去注册一个吧。</li><li>注册完登录后，在GitHub.com中看到一个New repository，新建仓库</li><li>创建一个和你用户名相同的仓库，后面加.github.io，只有这样，将来要部署到GitHub page的时候，才会被识别，也就是xxxx.github.io，其中xxx就是你注册GitHub的用户名。我这里是已经建过了。</li><li>点击create repository。</li></ul><h2 id="生成SSH添加到GitHub"><a href="#生成SSH添加到GitHub" class="headerlink" title="生成SSH添加到GitHub"></a>生成SSH添加到GitHub</h2><pre><code>git config --global user.name &quot;yourname&quot;git config --global user.email &quot;youremail&quot;</code></pre><p>这里的yourname输入你的GitHub用户名，youremail输入你GitHub的邮箱。这样GitHub才能知道你是不是对应它的账户。<br>可以用以下两条，检查一下你有没有输对</p><pre><code>git config user.namegit config user.email</code></pre><p>然后创建SSH,一路回车</p><pre><code>ssh-keygen -t rsa -C &quot;youremail&quot;</code></pre><p>这个时候它会告诉你已经生成了.ssh的文件夹。在你的电脑中找到这个文件夹。<br>例如我的.ssh文件夹在这个文件夹下 </p><pre><code>C:\Users\行路\.ssh</code></pre><p>ssh,就是一个秘钥，其中，id_rsa是你电脑的私人密钥,不能给别人看。id_rsa.pub是公共秘钥，可以随便给别人看。把这个公钥放在GitHub上，这样当你链接GitHub自己的账户时，它就会根据公钥匹配你的私钥，当能够相互匹配时，才能够顺利的通过git上传你的文件到GitHub上。<br>而后在GitHub的setting中，找到SSH keys的设置选项，点击New SSH key<br>把你的id_rsa.pub里面的信息复制进去。</p><p>在gitbash中，查看是否成功</p><pre><code>ssh -T git@github.com</code></pre><h1 id="将hexo部署到GitHub"><a href="#将hexo部署到GitHub" class="headerlink" title="将hexo部署到GitHub"></a>将hexo部署到GitHub</h1><h2 id="hexo和GitHub关联起来"><a href="#hexo和GitHub关联起来" class="headerlink" title="hexo和GitHub关联起来"></a>hexo和GitHub关联起来</h2><p>将hexo生成的文章部署到GitHub上，打开myblog下的(即站点配置文件)文件 _config.yml，翻到最后，修改为<br>YourgithubName就是你的GitHub账户</p><pre><code>deploy:  type: git  repo: https://github.com/YourgithubName/YourgithubName.github.io.git  branch: master</code></pre><h2 id="命令部署到GitHub"><a href="#命令部署到GitHub" class="headerlink" title="命令部署到GitHub"></a>命令部署到GitHub</h2><p>这个时候需要先安装deploy-git ，也就是部署的命令,这样你才能用命令部署到GitHub。</p><pre><code>npm install hexo-deployer-git --savehexo clean #清除本地myblog下的public文件夹下内容hexo generate #再次生成 public下的内容(包含首页的html)hexo deploy #上传到github上</code></pre><p>其中 hexo clean清除了你之前生成的东西，也可以不加。<br>hexo generate 顾名思义，生成静态文章，可以用 hexo g缩写<br>hexo deploy 部署文章，可以用hexo d缩写<br>注意deploy时可能要你输入username和password。<br>过一会儿就可以在<a href="http://yourname.github.io" target="_blank" rel="noopener">http://yourname.github.io</a> 这个网站看到你的博客了！！如果看到正确的页面显示就代表部署成功。</p><h1 id="设置个人域名"><a href="#设置个人域名" class="headerlink" title="设置个人域名"></a>设置个人域名</h1><p>现在你的个人网站的地址是yourname.github.io，如果觉得这个网址逼格不太够，这就需要你设置个人域名了。但是需要花钱。因为我本人并没有设置个人域名去访问,所以这方面的问题我就不再赘述,请自行百度。</p><h1 id="hexo的基本配置"><a href="#hexo的基本配置" class="headerlink" title="hexo的基本配置"></a>hexo的基本配置</h1><h2 id="下载主题"><a href="#下载主题" class="headerlink" title="下载主题"></a>下载主题</h2><p>在文件根目录(myblog)下的_config.yml,就是整个hexo框架的配置文件了。可以在里面修改大部分的配置。详细可参考<a href="https://hexo.io/zh-cn/docs/configuration" target="_blank" rel="noopener">官方的配置</a>描述.<br><a href="https://hexo.io/zh-cn/" target="_blank" rel="noopener">点击官网选择合适主题</a>进入以后点击主题,然后进入到该主题,该主题的博主在里面提供一个github下载地址(自己找一下地方,因为每一个主题放置下载地址位置不一样)。进入到github下载,点击下载或者clone<br>如果自己觉得下载慢,可以转到码云上下载,具体方法自己百度。主题的文件夹下内容如下</p><p><img src="/" class="lazyload" data-src="/images/config2.jpg"  alt=""></p><h2 id="更换主题"><a href="#更换主题" class="headerlink" title="更换主题"></a>更换主题</h2><p>下载完以后将下载后的文件夹拷贝到 (以我自己举例)myblog\themes\下<br>然后进入到myblog下的_config.yml下,更改如下</p><pre><code>theme: butterfly #(butterfly把这个更改为自己下载的主题文件夹名字)</code></pre><p>Hexo更改主题后启动服务器，</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo clean </span><br><span class="line">hexo g #在本地生成</span><br><span class="line">hexo d #上传到github上去</span><br><span class="line">#然后访问xxx.github.io 可以看到自己的博客了xxx是自己的github账户的名称</span><br></pre></td></tr></table></figure><p>如果界面显如下字符:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">extends includes&#x2F;layout.pug block content include includes&#x2F;recent-posts.pug include includes&#x2F;partial</span><br></pre></td></tr></table></figure><p>执行如下命令</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install --save hexo-renderer-jade hexo-generator-feed hexo-generator-sitemap hexo-browsersync hexo-generator-archive</span><br><span class="line">#然后再执行后查看</span><br><span class="line">hexo clean </span><br><span class="line">hexo g #在本地生成</span><br><span class="line">hexo d #上传到github上去</span><br></pre></td></tr></table></figure><h2 id="修改博客名称"><a href="#修改博客名称" class="headerlink" title="修改博客名称"></a>修改博客名称</h2><p>更改myblog下的_config.yml,更改如下,按照我的配置更改自己的</p><p><img src="/" class="lazyload" data-src="/images/config1.jpg"  alt=""></p><h1 id="博客的基本配置"><a href="#博客的基本配置" class="headerlink" title="博客的基本配置"></a>博客的基本配置</h1><p>站点配置文件_config.yml是hexo工作目录下的主配置文件(还不知道在哪里的自己重新看上面,这是博客下的)<br>以我自己主题为例butterfly.yml是Butterfly的配置文件,它需要你将主题下的_config.yml(主题下的,看清楚)文件 复制到工作目录下(myblog)下的source/_data/butterfly.yml,如果文件或者文件夹,不存在,自己创建。(言简意赅的意思就是把主题下的_config.yml,复制到上述的文件夹,重命名为butterfly.yml)</p><h2 id="更改菜单栏"><a href="#更改菜单栏" class="headerlink" title="更改菜单栏"></a>更改菜单栏</h2><p>butterfly.yml下,当然我觉得如果没有配置这个文件夹,在主题下的_config.yml文件下更改也是没有问题的<br>如果自己不了解yml的文件格式,自行百度。更改butterfly.yml如下内容</p>{% menu:  首页: / || fa fa-home  时间轴: /archives/ || fa fa-archive  标签: /tags/ || fa fa-tags  目录: /categories/ || fa fa-folder-open  友情链接: /link/ || fa fa-link  关于: /about/ || fa fa-heart  清单||fa fa-list:- 音乐 || /music/ || fa fa-music- 电影 || /movies/ || fa fa-film- 照片 || /gallery/ || fa fa-picture-o %}<h2 id="新建与菜单匹配的页面"><a href="#新建与菜单匹配的页面" class="headerlink" title="新建与菜单匹配的页面"></a>新建与菜单匹配的页面</h2><p>在myblog中右键(Git bash here)  (记住以后部署到github上也是在这个地方git bash here)<br>输入</p><pre><code>hexo new page tags</code></pre><p>你会找到source/tags/index.md这个文件<br>修改这个文件如下</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: 标签</span><br><span class="line">date: 2020-04-03 09:45:22</span><br><span class="line">type: &quot;tags&quot;</span><br><span class="line">---</span><br></pre></td></tr></table></figure><p>以此类推</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo new page categories</span><br><span class="line">hexo new page link</span><br><span class="line">hexo new page about</span><br><span class="line">hexo new page music #等,仿照上面的去修改生成的文件,如果运行到网页出现乱码,将这些生成的.md文件编码格式保存为utf-8</span><br></pre></td></tr></table></figure><h2 id="查看blog"><a href="#查看blog" class="headerlink" title="查看blog"></a>查看blog</h2><h3 id="在本地查看"><a href="#在本地查看" class="headerlink" title="在本地查看"></a>在本地查看</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo s --debugger</span><br><span class="line">#然后在网页中访问localhost:4000 </span><br><span class="line">#可以看到自己的blog,如果访问不了自行百度</span><br></pre></td></tr></table></figure><h3 id="部署到github上查看"><a href="#部署到github上查看" class="headerlink" title="部署到github上查看"></a>部署到github上查看</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo g #在本地生成</span><br><span class="line">hexo d #上传到github上去</span><br><span class="line">#其实上面已经介绍到了这些命令,期间可能会让你输入自己的github账号和密码</span><br></pre></td></tr></table></figure><p>然后访问xxx.github.io 可以看到自己的博客了xxx是自己的github账户的名称</p><h1 id="主题的具体样式配置"><a href="#主题的具体样式配置" class="headerlink" title="主题的具体样式配置"></a>主题的具体样式配置</h1><p>主题的具体配置我就不一一列举了<br>详情请访问以我这个主题为例写的说明文档，如果想配置的好看点,请仔细查看<br><a href="https://jerryc.me/posts/4aa8abbe/#%E8%AA%9E%E8%A8%80" target="_blank" rel="noopener">说明文档</a><br>这是这个主题<a href="https://jerryc.me/" target="_blank" rel="noopener">创建者的博客</a><br>这里是整个hexo 的<a href="https://hexo.io/zh-cn/docs/index.html" target="_blank" rel="noopener">说明文档</a><br>里面接收了怎样 使用 操作 部署</p><h1 id="写博客"><a href="#写博客" class="headerlink" title="写博客"></a>写博客</h1><h2 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo new [layout] &lt;title&gt;</span><br><span class="line"></span><br><span class="line">#layout默认是post直接发布</span><br><span class="line">#会在source&#x2F;_posts下生成一个&lt;title&gt;.md命名的博客,采用markdown的语法写作</span><br></pre></td></tr></table></figure><h2 id="写作"><a href="#写作" class="headerlink" title="写作"></a>写作</h2><p>以我的为一个小小的例子</p><p><img src="/" class="lazyload" data-src="/images/config3.jpg"  alt=""></p><h2 id="发布"><a href="#发布" class="headerlink" title="发布"></a>发布</h2><h3 id="本地先查看"><a href="#本地先查看" class="headerlink" title="本地先查看"></a>本地先查看</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo s --debugger</span><br></pre></td></tr></table></figure><p>访问localhost:4000在本地查看,如果再本地写的博客,没有目录,发布到github上访问会显示目录的。</p><h3 id="发布到github上"><a href="#发布到github上" class="headerlink" title="发布到github上"></a>发布到github上</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo g</span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure><p>访问自己的xxx.github.io即可,别人访问的就是这个</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;我个人用了差不多一天的时间,搭建出来hexo+nodejs+github的个人博客网站,其中出现了无次数的错误和坑.但也在我的坚持下,不断的
      
    
    </summary>
    
    
      <category term="教程" scheme="https://todcsw.github.io/categories/%E6%95%99%E7%A8%8B/"/>
    
    
      <category term="教程" scheme="https://todcsw.github.io/tags/%E6%95%99%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="https://todcsw.github.io/2020/04/02/hello-world/"/>
    <id>https://todcsw.github.io/2020/04/02/hello-world/</id>
    <published>2020-04-02T13:39:51.005Z</published>
    <updated>2020-04-02T13:39:51.005Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.
      
    
    </summary>
    
    
    
  </entry>
  
</feed>
